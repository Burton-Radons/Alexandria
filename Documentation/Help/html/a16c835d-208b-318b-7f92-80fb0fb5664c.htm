<html>
  <head>
    <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8" />
    <META NAME="save" CONTENT="history" />
    <title>ComputeShader Class</title>
    <meta name="Language" content="en-us" />
    <meta name="System.Keywords" content="ComputeShader class" />
    <meta name="System.Keywords" content="Glare.Graphics.ComputeShader class" />
    <meta name="System.Keywords" content="ComputeShader class, about ComputeShader class" />
    <meta name="Microsoft.Help.F1" content="Glare.Graphics.ComputeShader" />
    <meta name="Microsoft.Help.Id" content="T:Glare.Graphics.ComputeShader" />
    <meta name="Description" content="A shader stage that is used entirely for computing arbitrary information. While it can do rendering, it is generally used for tasks not directly related to drawing triangles and pixels." />
    <meta name="Microsoft.Help.ContentType" content="Reference" />
    <link rel="stylesheet" type="text/css" href="../styles/Presentation.css" />
    
    <script type="text/javascript" src="../scripts/EventUtilities.js"> </script>
    <script type="text/javascript" src="../scripts/SplitScreen.js"> </script>
    <script type="text/javascript" src="../scripts/Dropdown.js"> </script>
    <script type="text/javascript" src="../scripts/script_manifold.js"> </script>
    <script type="text/javascript" src="../scripts/script_feedBack.js"> </script>
    <script type="text/javascript" src="../scripts/CheckboxMenu.js"> </script>
    <script type="text/javascript" src="../scripts/CommonUtilities.js"> </script>
    <meta name="container" content="Glare.Graphics" />
    <meta name="file" content="a16c835d-208b-318b-7f92-80fb0fb5664c" />
    <meta name="guid" content="a16c835d-208b-318b-7f92-80fb0fb5664c" />
    
    <link type="text/css" rel="stylesheet" href="../styles/highlight.css" />
    <script type="text/javascript" src="../scripts/highlight.js"> </script>
  </head>
  <body>
    <input type="hidden" id="userDataCache" class="userDataStyle" />
    <input type="hidden" id="hiddenScrollOffset" />
    <img id="collapseImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" alt="Collapse image" title="Collapse image" />
    <img id="expandImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" alt="Expand Image" title="Expand Image" />
    <img id="collapseAllImage" style="display:none; height:0; width:0;" src="../icons/collapse_all.gif" />
    <img id="expandAllImage" style="display:none; height:0; width:0;" src="../icons/expand_all.gif" />
    <img id="dropDownImage" style="display:none; height:0; width:0;" src="../icons/dropdown.gif" />
    <img id="dropDownHoverImage" style="display:none; height:0; width:0;" src="../icons/dropdownHover.gif" />
    <img id="copyImage" style="display:none; height:0; width:0;" src="../icons/copycode.gif" alt="Copy image" title="Copy image" />
    <img id="copyHoverImage" style="display:none; height:0; width:0;" src="../icons/copycodeHighlight.gif" alt="CopyHover image" title="CopyHover image" />
    <div id="header">
      <table id="logoTable" border="0" width="100%" cellpadding="0" cellspacing="0">
        <tr>
          <td align="center" style="padding-right: 2px">
            <img src="../icons/Help.png" />
          </td>
          <td valign="top" width="100%">
            <table id="topTable" cellspacing="0" cellpadding="0">
              <tr>
                <td>
                  <span onclick="ExpandCollapseAll(toggleAllImage)" style="cursor:default;" onkeypress="ExpandCollapseAll_CheckKey(toggleAllImage, event)" tabindex="0">
                    <img ID="toggleAllImage" class="toggleAll" src="../icons/collapse_all.gif" /> <label id="collapseAllLabel" for="toggleAllImage" style="display: none;">Collapse All</label><label id="expandAllLabel" for="toggleAllImage" style="display: none;">Expand All</label> </span>
                  <span>    </span>
                  <span id="devlangsDropdown" class="filter" tabindex="0">
                    <img id="devlangsDropdownImage" src="../icons/dropdown.gif" /> <label id="devlangsMenuAllLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: All </nobr></label><label id="devlangsMenuMultipleLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Multiple </nobr></label><label id="devlangsMenuCSharpLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: C# </nobr></label><label id="devlangsMenuVisualBasicLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual Basic </nobr></label><label id="devlangsMenuManagedCPlusPlusLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: Visual C++ </nobr></label><label id="devlangsMenuFSharpLabel" for="devlangsDropdownImage" style="display: none;"><nobr>Code: F# </nobr></label></span>
                </td>
              </tr>
            </table>
            <div id="devlangsMenu">
              <input id="CSharpCheckbox" type="checkbox" data="CSharp,cs,'persist'" value="on" onClick="SetLanguage(this)" />
              <label class="checkboxLabel" for="CSharpCheckbox">C#</label>
              <br />
              <input id="VisualBasicCheckbox" type="checkbox" data="VisualBasic,vb,'persist'" value="on" onClick="SetLanguage(this)" />
              <label class="checkboxLabel" for="VisualBasicCheckbox">Visual Basic</label>
              <br />
              <input id="ManagedCPlusPlusCheckbox" type="checkbox" data="ManagedCPlusPlus,cpp,'persist'" value="on" onClick="SetLanguage(this)" />
              <label class="checkboxLabel" for="ManagedCPlusPlusCheckbox">Visual C++</label>
              <br />
              <input id="FSharpCheckbox" type="checkbox" data="FSharp,fs,'persist'" value="on" onClick="SetLanguage(this)" />
              <label class="checkboxLabel" for="FSharpCheckbox">F#</label>
              <br />
            </div>
            <table id="bottomTable" cellpadding="0" cellspacing="0">
              <tr id="headerTableRow1">
                <td align="left">
                  <span id="runningHeaderText">A Sandcastle Documented Class Library</span>
                </td>
              </tr>
              <tr id="headerTableRow2">
                <td align="left">
                  <span id="nsrTitle">ComputeShader Class</span>
                </td>
              </tr>
              <tr id="headerTableRow3">
                <td align="left">
                  <a href="bf5978ab-0690-e8f1-d8e8-3c205ce7a863.htm">Members</a> <a href="#seeAlsoToggle" onclick="OpenSection(seeAlsoToggle)">See Also</a> <span id="headfeedbackarea" class="feedbackhead"><a href="#" onclick="javascript:SubmitFeedback('','A Sandcastle Documented Class Library','','','','%0\dYour%20feedback%20is%20used%20to%20improve%20the%20documentation%20and%20the%20product.%20Your%20e-mail%20address%20will%20not%20be%20used%20for%20any%20other%20purpose%20and%20is%20disposed%20of%20after%20the%20issue%20you%20report%20is%20resolved.%20%20While%20working%20to%20resolve%20the%20issue%20that%20you%20report,%20you%20may%20be%20contacted%20via%20e-mail%20to%20get%20further%20details%20or%20clarification%20on%20the%20feedback%20you%20sent.%20After%20the%20issue%20you%20report%20has%20been%20addressed,%20you%20may%20receive%20an%20e-mail%20to%20let%20you%20know%20that%20your%20feedback%20has%20been%20addressed.%0\A%0\d','Customer%20Feedback'); return false;">Send Feedback</a></span></td>
              </tr>
            </table>
          </td>
        </tr>
      </table>
      <table id="gradientTable">
        <tr>
          <td class="nsrBottom" id="headerBottom">
            <img id="headerBottomImage" style="display: none;" src="../icons/gradient.gif" />
          </td>
        </tr>
      </table>
    </div>
    <div id="mainSection">
      <div id="mainBody">
        <div id="allHistory" class="saveHistory" onsave="saveAll()" onload="loadAll()" />
        <span style="color: DarkGray"></span>
        <div class="summary">
            A shader stage that is used entirely for computing arbitrary information. While it can do rendering, it is generally used for tasks not directly related to drawing triangles and pixels.
            </div>
        <p />
        <b>Namespace:</b> <a href="6481d6d2-ae69-898b-26de-7d5e1efe46fa.htm">Glare.Graphics</a><br /><b>Assembly:</b> <span sdata="assembly">Glare.Graphics</span> (in Glare.Graphics.dll) Version: 1.0.0.0 (1.0.0.0)<h1 class="heading"><span onclick="ExpandCollapse(syntaxToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(syntaxToggle, event)" tabindex="0"><img id="syntaxToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Syntax</span></h1><div id="syntaxSection" class="section" name="collapseableSection" style=""><div id="syntaxCodeBlocks" class="code"><span codeLanguage="CSharp"><table><tr><th>C#</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">public</span> <span class="keyword">class</span> <span class="identifier">ComputeShader</span> : <span class="identifier">Shader</span></pre></td></tr></table></span><span codeLanguage="VisualBasicDeclaration"><table><tr><th>Visual Basic</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">Public</span> <span class="keyword">Class</span> <span class="identifier">ComputeShader</span>
	<span class="keyword">Inherits</span> <span class="identifier">Shader</span></pre></td></tr></table></span><span codeLanguage="ManagedCPlusPlus"><table><tr><th>Visual C++</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">public</span> <span class="keyword">ref class</span> <span class="identifier">ComputeShader</span> : <span class="keyword">public</span> <span class="identifier">Shader</span></pre></td></tr></table></span><span codeLanguage="FSharp"><table><tr><th>F#</th></tr><tr><td><pre xml:space="preserve"><span class="keyword">type</span> <span class="identifier">ComputeShader</span> =  
    <span class="keyword">class</span>
        <span class="keyword">inherit</span> <span class="identifier">Shader</span>
    <span class="keyword">end</span></pre></td></tr></table></span></div></div><h1 class="heading"><span onclick="ExpandCollapse(remarksToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(remarksToggle, event)" tabindex="0"><img id="remarksToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Remarks</span></h1><div id="remarksSection" class="section" name="collapseableSection" style="">
            Compute shaders operate differently from other shader stages. All of the other shader stages have a well-defined set of input values, some built-in and some user-defined. They have a well-defined set of output values, some built-in and some user-defined. The frequency at which a shader stage executes is specified by the nature of that stage; vertex shaders execute once per input vertex, for example (though some executions can be skipped via caching). Fragment shader execution is defined by the fragments generated from the rasterization process.
            
            Compute shaders work very differently. The "space" that a compute shader operates on is largely abstract; it is up to each compute shader to decide what the space means. The number of compute shader executions is defined by the function used to execute the compute operation. Most important of all, compute shaders have no user-defined inputs and no outputs at all. The built-in inputs only define where in the "space" of execution a particular compute shader invocation is.
            
            Therefore, if a compute shader wants to take some values as input, it is up to the shader itself to fetch that data, via texture access, arbitrary image load, shader storage blocks, or other forms of interface. Similarly, if a compute shader is to actually compute anything, it must explicitly write to an image or shader storage block.
            
            <h1>Compute space</h1>
            The space that compute shaders operate within is abstract. There is the concept of a work group; this is the smallest amount of compute operations that the user can execute. Or to put it another way, the user can execute some number of work groups.
            
            The number of work groups that a compute operation is executed with is defined by the user when they invoke the compute operation. The space of these groups is three dimensional, so it has a number of "X", "Y", and "Z" groups. Any of these can be 1, so you can perform a two-dimensional or one-dimensional compute operation instead of a 3D one. This is useful for processing image data or linear arrays of a particle system or whatever.
            
            When the system actually computes the work groups, it can do so in any order. So if it is given a work group set of (3, 1, 2), it could execute group (0, 0, 0) first, then skip to group (1, 0, 1), then jump to (2, 0, 0), etc. So your compute shader should not rely on the order in which individual groups are processed.
            
            Do not think that a single work group is the same thing as a single compute shader invocation; there's a reason why it is called a "group". Within a single work group, there may be many compute shader invocations. How many is defined by the compute shader itself, not by the call that executes it. This is known as the local size of the work group.
            
            Every compute shader has a three-dimensional local size (again, sizes can be 1 to allow 2D or 1D local processing). This defines the number of invocations of the shader that will take place within each work group.
            
            Therefore, if the local size of a compute shader is (128, 1, 1), and you execute it with a work group count of (16, 8, 64), then you will get 1,048,576 separate shader invocations. Each invocation will have a set of inputs that uniquely identifies that specific invocation.
            
            This distinction is useful for doing various forms of image compression or decompression; the local size would be the size of a block of image data (8x8, for example), while the group count will be the image size divided by the block size. Each block is processed as a single work group.
            
            The individual invocations within a work group will be executed "in parallel". The main purpose of the distinction between work group count and local size is that the different compute shader invocations within a work group can communicate through a set of shared​ variables and special functions. Invocations in different work groups (within the same compute shader dispatch) cannot effectively communicate. Not without potentially deadlocking the system.
            
            <h1>Dispatch</h1>
            Compute shaders are not part of the regular rendering pipeline. So the usual vertex rendering functions do not work on them.
            
            A <a href="448f8a7e-0b39-754f-418e-8131312cdaff.htm">Program</a> object can have a <span class="selflink">ComputeShader</span> in it. The <span class="selflink">ComputeShader</span> linked with other Shader Stages (whether in a single program object or in a program pipeline) is effectively inert to rendering functions.
            
            There are two functions to initiate compute operations. They will use whichever compute shader is currently active (via glBindProgramPipeline​ or glUseProgram​, following the usual rules for determining the active program for a stage). For <span class="nolink">[!:Context.DispatchCompute(int, int, int)]</span> or <span class="nolink">[!:Context.DispatchCompute(Vector3i)]</span>, the numGroups*​ parameter[s] define the work group count, in three dimensions. These numbers cannot be zero. There are limitations on the number of work groups that can be dispatched.
            
            It is possible to execute dispatch operations where the work group count comes from information stored in a <a href="99d8de01-387e-d09d-dff9-399ae12521e3.htm">GraphicsBuffer</a> object with <span class="nolink">[!:Context.DispatchComputeIndirect]</span>. The indirect​ parameter is the byte-offset to the buffer currently assigned to the <span class="nolink">[!:DispatchIndirectBuffer]</span>​​ target. Note that the same limitations on work group counts (see below) still apply; however, indirect dispatch bypasses OpenGL's usual error checking. As such, attempting to dispatch with out-of-bounds work group sizes can cause a crash or even a GPU hard-lock.
            
             <h1>Inputs</h1>
             
            Compute shaders cannot have any user-defined input variables. Compute Shaders have the following built-in output variables.
            
            <div class="code"><span codeLanguage="other"><table width="100%" cellspacing="0" cellpadding="0"><tr><th> </th><th><span class="copyCode" onclick="CopyCode(this)" onkeypress="CopyCode_CheckKey(this, event)" onmouseover="ChangeCopyCodeIcon(this)" onmouseout="ChangeCopyCodeIcon(this)" tabindex="0"><img class="copyCodeImage" name="ccImage" align="absmiddle" alt="Copy image" title="Copy image" src="../icons/copycode.gif" />Copy</span></th></tr><tr><td colspan="2"><pre xml:space="preserve">in uvec3 gl_NumWorkGroups;
in uvec3 gl_WorkGroupID;
in uvec3 gl_LocalInvocationID;
in uvec3 gl_GlobalInvocationID;
in uint  gl_LocalInvocationIndex;</pre></td></tr></table></span></div><div class="tableSection"><table width="100%" cellspacing="2" cellpadding="5" frame="lhs"><tr><td>gl_NumWorkGroups​</td><td>This variable contains the number of work groups passed to the dispatch function.</td></tr><tr><td>gl_WorkGroupID​</td><td>This is the current work group for this shader invocation. Each of the XYZ components will be on the half-open range [0, gl_NumWorkGroups.xyz).</td></tr><tr><td>gl_LocalInvocationID​</td><td>This is the current invocation of the shader within the work group. Each of the XYZ components will be on the half-open range [0, gl_WorkGroupSize.xyz​).</td></tr><tr><td>gl_GlobalInvocationID​</td><td>This value uniquely identifies this particular invocation of the compute shader among all invocations of this compute dispatch call. It's a short-hand for the math computation: <span class="code">gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID</span>.</td></tr><tr><td>gl_LocalInvocationIndex​</td><td>This is a 1D version of gl_LocalInvocationID​. It identifies this invocation's index within the work group. It is short-hand for this math computation: <span class="code">gl_LocalInvocationID.z * gl_WorkGroupSize.x * gl_WorkGroupSize.y + gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x</span>.</td></tr></table></div><h1>Local size</h1>
             
            The local size of a compute shader is defined within the shader source, using a special layout input declaration: <span class="code">layout(local_size_x = X​, local_size_y = Y​, local_size_z = Z​) in;</span>
            
            By default, the local sizes are 1, so if you only want a 1D or 2D work group space, you can specify just the X​ or the X​ and Y​ components. They must be integral constant expressions of value greater than 0. Their values must abide by the limitations imposed below; if they do not, a compiler or linker error occurs. The local size is available to the shader as a compile-time constant variable, so you don't need to define it yourself: <span class="code">const uvec3 gl_WorkGroupSize;</span><h1>Shared variables</h1>
             
            Global variables in compute shaders can be declared with the shared​ storage qualifier. The value of such variables are shared between all invocations within a work group. You cannot declare any opaque types as shared, but aggregates (arrays and structs) are fine. At the beginning of a work group, these values are uninitialized, and the variable declaration cannot have initializers.
            
             <h1>Shared memory coherency</h1>
             Shared variable access uses the rules for incoherent memory access. This means that the user must perform certain synchronization in order to ensure that shared variables are visible.
             
            Shared variables are all implicitly declared coherent​, so you don't need to (and can't use) that qualifier. However, you still need to provide an appropriate memory barrier.
            
            The usual set of memory barriers is available to compute shaders, but they also have access to memoryBarrierShared()​; this barrier is specifically for shared variable ordering. groupMemoryBarrier()​ acts like memoryBarrier()​, ordering memory writes for all kinds of variables, but it only orders read/writes for the current work group.
            
            While all invocations within a work group are said to execute "in parallel", that doesn't mean that you can assume that all of them are executing in lock-step. If you need to ensure that an invocation has written to some variable so that you can read it, you need to synchronize execution with the invocations, not just issue a memory barrier (you still need the memory barrier though).
            
            To synchronize reads and writes between invocations within a work group, you must employ the barrier()​ function. This forces an explicit synchronization between all invocations in the work group. Execution within the work group will not proceed until all other invocations have reach this barrier. Once past the barrier()​, all shared variables previously written across all invocations in the group will be visible.
            
            There are limitations on how you can call barrier()​. However, compute shaders are not as limited as Tessellation Control Shaders in their use of this function. barrier()​ can be called from flow-control, but it can only be called from uniform flow control. All expressions that lead to the evaluation of a barrier()​ must be dynamically uniform.
            
            In short, if you execute the same compute shader, no matter how different the data they fetch is, every execution must hit the exact same set of barrier()​ calls in the exact same order. Otherwise badness happens.
            
             <h1>Atomic operations</h1>
             A number of atomic operations can be performed on shared variables of integral type (and vectors/arrays/structs of them). These functions are shared with Shader Storage Buffer Object atomics.
             All of the atomic functions return the original value. The term "nint" can be int​ or uint​.
            
            <div class="tableSection"><table width="100%" cellspacing="2" cellpadding="5" frame="lhs"><tr><td>nint atomicAdd(inout nint mem​, nint data​)</td><td>Adds data​ to mem​.</td></tr><tr><td>nint atomicMin(inout nint mem​, nint data​)</td><td>The mem​'s value is no lower than data​.</td></tr><tr><td>nint atomicMax(inout nint mem​, nint data​)</td><td>The mem​'s value is no greater than data​.</td></tr><tr><td>nint atomicAnd (inout nint mem​, nint data​)</td><td>mem​ becomes the bitwise-and between mem​ and data​.</td></tr><tr><td>nint atomicOr(inout nint mem​, nint data​)</td><td>mem​ becomes the bitwise-or between mem​ and data​.</td></tr><tr><td>nint atomicXor(inout nint mem​, nint data​)</td><td>mem​ becomes the bitwise-xor between mem​ and data​.</td></tr><tr><td>nint atomicExchange(inout nint mem​, nint data​)</td><td>Sets mem​'s value to data​.</td></tr><tr><td>nint atomicCompSwap(inout nint mem​, nint compare​, nint data​)</td><td>If the current value of mem​ is equal to compare​, then mem​ is set to data​. Otherwise it is left unchanged.</td></tr></table></div><h1>Limitations</h1>
            The number of work groups that can be dispatched in a single dispatch call is defined by <span class="nolink">[!:Context.MaxComputeWorkGroupCount]</span>​. Attempting to call <span class="nolink">[!:Context.DispatchCompute]</span>​ with values that exceed this range is an error. Attempting to call <span class="nolink">[!:Context.DispatchComputeIndirect]</span>​ is much worse; it may result in program termination or other badness.
            
            Note that the minimum these values must be is 65535 in all three axes. So you've probably got a lot of room to work with.
            
            There are limits on the local size as well; indeed, there are two sets of limitations. There is a general limitation on the local size dimensions, queried with <span class="nolink">[!:Context.MaxComputeWorkGroupSize]</span>. Note that the minimum requirements here are much smaller: 1024 for X and Y, and a mere 64 for Z.
            
            There is another limitation: the total number of invocations within a work group. That is, the product of the X, Y and Z components of the local size must be less than <span class="nolink">[!:Context.MaxComputeWorkGroupInvocations]</span>​. The minimum value here is 1024.
            
            There is also a limit on the total storage size for all shared variables in a compute shader. This is <span class="nolink">[!:MaxComputeSharedMemorySize]</span>​, which is in bytes. The OpenGL-required minimum is 32KB. OpenGL does not specify the exact mapping between GL types and shared variable storage, though you could use the std140 layout rules and UBO/SSBO sizes as a general guideline.
            </div><h1 class="heading"><span onclick="ExpandCollapse(familyToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(familyToggle, event)" tabindex="0"><img id="familyToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />Inheritance Hierarchy</span></h1><div id="familySection" class="section" name="collapseableSection" style=""><a href="http://msdn2.microsoft.com/en-us/library/e5kfa45b" target="_blank">System<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>Object</a><br />  <a href="2eda1f69-f2c4-8133-7d80-d7f4f9191c1f.htm">Glare<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>NamedObject</a><br />    <a href="d03669ce-3918-d19b-0154-d1d5a1568a63.htm">Glare<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>DisposableObject</a><br />      <a href="eed5b663-2ca9-56cd-8253-89274291dbfb.htm">Glare.Graphics<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>GraphicsResource</a><br />        <a href="1b51d80d-3b7c-ca00-5480-8294f99162f6.htm">Glare.Graphics<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>Shader</a><br />          <span class="selflink">Glare.Graphics<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ComputeShader</span><br /></div><h1 class="heading"><span onclick="ExpandCollapse(seeAlsoToggle)" style="cursor:default;" onkeypress="ExpandCollapse_CheckKey(seeAlsoToggle, event)" tabindex="0"><img id="seeAlsoToggle" class="toggle" name="toggleSwitch" src="../icons/collapse_all.gif" />See Also</span></h1><div id="seeAlsoSection" class="section" name="collapseableSection" style=""><div class="seeAlsoStyle"><a href="bf5978ab-0690-e8f1-d8e8-3c205ce7a863.htm">ComputeShader<span class="languageSpecificText"><span class="cs">.</span><span class="vb">.</span><span class="cpp">::</span><span class="nu">.</span><span class="fs">.</span></span>ComputeShader Members</a></div><div class="seeAlsoStyle"><a href="6481d6d2-ae69-898b-26de-7d5e1efe46fa.htm">Glare.Graphics Namespace</a></div><div class="seeAlsoStyle"><a href="http://www.opengl.org/wiki/Compute_Shader" target="_blank">OpenGL Wiki</a></div></div></div>
      <div id="footer">
        <div class="footerLine">
          <img width="100%" height="3px" src="../icons/footer.gif" alt="Footer image" title="Footer image" />
        </div>
        <A NAME="feedback"></A>
        <span id="fb" class="feedbackcss"></span>
      </div>
    </div>
  </body>
</html>