using System;
using System.Collections.Generic;
using Glare.Internal;

namespace Glare
{
	
	/// <summary>A two-dimensional vector type using <see cref="Length"/> elements.</summary>
	[VectorTypeAttribute(typeof(Length), 2, false)]
	public partial struct Vector2 : IEquatable<Vector2>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Area MagnitudeSquared { get { return (Area)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Length Magnitude {
				get {
					return Length.Universal(						Math.Sqrt(
															( X).InUniversal.Squared() 
							+								( Y).InUniversal.Squared() 
													));
				}
			}

										
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Length Sum { get { return (Length)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
												/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
					public static Vector2 Centimetres( double x ,  double y ) {
						return new Vector2( Length.Centimetres(x) ,  Length.Centimetres(y) );
					}
				
					/// <summary>Initialize the vector from the Centimetres value.</summary>.
					public static Vector2 Centimetres(double value) {
						return new Vector2(Length.Centimetres(value));
					}

											/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
						public static Vector2 Centimetres( Vector2d value) {
							return new Vector2(								Length.Centimetres(value.X)
							, 								Length.Centimetres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
						public static Vector2 Centimetres( ref  Vector2d value) {
							return new Vector2(								Length.Centimetres(value.X)
							, 								Length.Centimetres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Centimetres unit.</summary>
					public Vector2d InCentimetres {
						get {
							return new Vector2d(								X.InCentimetres
							, 								Y.InCentimetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Feet units.</summary>.
					public static Vector2 Feet( double x ,  double y ) {
						return new Vector2( Length.Feet(x) ,  Length.Feet(y) );
					}
				
					/// <summary>Initialize the vector from the Feet value.</summary>.
					public static Vector2 Feet(double value) {
						return new Vector2(Length.Feet(value));
					}

											/// <summary>Initialize the vector from values provided in Feet units.</summary>.
						public static Vector2 Feet( Vector2d value) {
							return new Vector2(								Length.Feet(value.X)
							, 								Length.Feet(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Feet units.</summary>.
						public static Vector2 Feet( ref  Vector2d value) {
							return new Vector2(								Length.Feet(value.X)
							, 								Length.Feet(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Feet unit.</summary>
					public Vector2d InFeet {
						get {
							return new Vector2d(								X.InFeet
							, 								Y.InFeet
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Inches units.</summary>.
					public static Vector2 Inches( double x ,  double y ) {
						return new Vector2( Length.Inches(x) ,  Length.Inches(y) );
					}
				
					/// <summary>Initialize the vector from the Inches value.</summary>.
					public static Vector2 Inches(double value) {
						return new Vector2(Length.Inches(value));
					}

											/// <summary>Initialize the vector from values provided in Inches units.</summary>.
						public static Vector2 Inches( Vector2d value) {
							return new Vector2(								Length.Inches(value.X)
							, 								Length.Inches(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Inches units.</summary>.
						public static Vector2 Inches( ref  Vector2d value) {
							return new Vector2(								Length.Inches(value.X)
							, 								Length.Inches(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Inches unit.</summary>
					public Vector2d InInches {
						get {
							return new Vector2d(								X.InInches
							, 								Y.InInches
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
					public static Vector2 Kilometres( double x ,  double y ) {
						return new Vector2( Length.Kilometres(x) ,  Length.Kilometres(y) );
					}
				
					/// <summary>Initialize the vector from the Kilometres value.</summary>.
					public static Vector2 Kilometres(double value) {
						return new Vector2(Length.Kilometres(value));
					}

											/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
						public static Vector2 Kilometres( Vector2d value) {
							return new Vector2(								Length.Kilometres(value.X)
							, 								Length.Kilometres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
						public static Vector2 Kilometres( ref  Vector2d value) {
							return new Vector2(								Length.Kilometres(value.X)
							, 								Length.Kilometres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Kilometres unit.</summary>
					public Vector2d InKilometres {
						get {
							return new Vector2d(								X.InKilometres
							, 								Y.InKilometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
					public static Vector2 Megametres( double x ,  double y ) {
						return new Vector2( Length.Megametres(x) ,  Length.Megametres(y) );
					}
				
					/// <summary>Initialize the vector from the Megametres value.</summary>.
					public static Vector2 Megametres(double value) {
						return new Vector2(Length.Megametres(value));
					}

											/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
						public static Vector2 Megametres( Vector2d value) {
							return new Vector2(								Length.Megametres(value.X)
							, 								Length.Megametres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
						public static Vector2 Megametres( ref  Vector2d value) {
							return new Vector2(								Length.Megametres(value.X)
							, 								Length.Megametres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Megametres unit.</summary>
					public Vector2d InMegametres {
						get {
							return new Vector2d(								X.InMegametres
							, 								Y.InMegametres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Metres units.</summary>.
					public static Vector2 Metres( double x ,  double y ) {
						return new Vector2( Length.Metres(x) ,  Length.Metres(y) );
					}
				
					/// <summary>Initialize the vector from the Metres value.</summary>.
					public static Vector2 Metres(double value) {
						return new Vector2(Length.Metres(value));
					}

											/// <summary>Initialize the vector from values provided in Metres units.</summary>.
						public static Vector2 Metres( Vector2d value) {
							return new Vector2(								Length.Metres(value.X)
							, 								Length.Metres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Metres units.</summary>.
						public static Vector2 Metres( ref  Vector2d value) {
							return new Vector2(								Length.Metres(value.X)
							, 								Length.Metres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Metres unit.</summary>
					public Vector2d InMetres {
						get {
							return new Vector2d(								X.InMetres
							, 								Y.InMetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
					public static Vector2 Micrometres( double x ,  double y ) {
						return new Vector2( Length.Micrometres(x) ,  Length.Micrometres(y) );
					}
				
					/// <summary>Initialize the vector from the Micrometres value.</summary>.
					public static Vector2 Micrometres(double value) {
						return new Vector2(Length.Micrometres(value));
					}

											/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
						public static Vector2 Micrometres( Vector2d value) {
							return new Vector2(								Length.Micrometres(value.X)
							, 								Length.Micrometres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
						public static Vector2 Micrometres( ref  Vector2d value) {
							return new Vector2(								Length.Micrometres(value.X)
							, 								Length.Micrometres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Micrometres unit.</summary>
					public Vector2d InMicrometres {
						get {
							return new Vector2d(								X.InMicrometres
							, 								Y.InMicrometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
					public static Vector2 Millimetres( double x ,  double y ) {
						return new Vector2( Length.Millimetres(x) ,  Length.Millimetres(y) );
					}
				
					/// <summary>Initialize the vector from the Millimetres value.</summary>.
					public static Vector2 Millimetres(double value) {
						return new Vector2(Length.Millimetres(value));
					}

											/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
						public static Vector2 Millimetres( Vector2d value) {
							return new Vector2(								Length.Millimetres(value.X)
							, 								Length.Millimetres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
						public static Vector2 Millimetres( ref  Vector2d value) {
							return new Vector2(								Length.Millimetres(value.X)
							, 								Length.Millimetres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Millimetres unit.</summary>
					public Vector2d InMillimetres {
						get {
							return new Vector2d(								X.InMillimetres
							, 								Y.InMillimetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
					public static Vector2 Nanometres( double x ,  double y ) {
						return new Vector2( Length.Nanometres(x) ,  Length.Nanometres(y) );
					}
				
					/// <summary>Initialize the vector from the Nanometres value.</summary>.
					public static Vector2 Nanometres(double value) {
						return new Vector2(Length.Nanometres(value));
					}

											/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
						public static Vector2 Nanometres( Vector2d value) {
							return new Vector2(								Length.Nanometres(value.X)
							, 								Length.Nanometres(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
						public static Vector2 Nanometres( ref  Vector2d value) {
							return new Vector2(								Length.Nanometres(value.X)
							, 								Length.Nanometres(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Nanometres unit.</summary>
					public Vector2d InNanometres {
						get {
							return new Vector2d(								X.InNanometres
							, 								Y.InNanometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Yards units.</summary>.
					public static Vector2 Yards( double x ,  double y ) {
						return new Vector2( Length.Yards(x) ,  Length.Yards(y) );
					}
				
					/// <summary>Initialize the vector from the Yards value.</summary>.
					public static Vector2 Yards(double value) {
						return new Vector2(Length.Yards(value));
					}

											/// <summary>Initialize the vector from values provided in Yards units.</summary>.
						public static Vector2 Yards( Vector2d value) {
							return new Vector2(								Length.Yards(value.X)
							, 								Length.Yards(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Yards units.</summary>.
						public static Vector2 Yards( ref  Vector2d value) {
							return new Vector2(								Length.Yards(value.X)
							, 								Length.Yards(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Yards unit.</summary>
					public Vector2d InYards {
						get {
							return new Vector2d(								X.InYards
							, 								Y.InYards
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Universal units.</summary>.
					public static Vector2 Universal( double x ,  double y ) {
						return new Vector2( Length.Universal(x) ,  Length.Universal(y) );
					}
				
					/// <summary>Initialize the vector from the Universal value.</summary>.
					public static Vector2 Universal(double value) {
						return new Vector2(Length.Universal(value));
					}

											/// <summary>Initialize the vector from values provided in Universal units.</summary>.
						public static Vector2 Universal( Vector2d value) {
							return new Vector2(								Length.Universal(value.X)
							, 								Length.Universal(value.Y)
							);
						}
											/// <summary>Initialize the vector from values provided in Universal units.</summary>.
						public static Vector2 Universal( ref  Vector2d value) {
							return new Vector2(								Length.Universal(value.X)
							, 								Length.Universal(value.Y)
							);
						}
									
					/// <summary>Convert into a vector in Universal unit.</summary>
					public Vector2d InUniversal {
						get {
							return new Vector2d(								X.InUniversal
							, 								Y.InUniversal
							);
						}
					}
				
			
			

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Area Dot( Vector2 other) { return (Area)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Area Dot( ref  Vector2 other) { return (Area)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2 Clamp( Vector2 min,  Vector2 max ) {
					Vector2 result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2 min,  ref  Vector2 max , out Vector2 result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Length Distance( Vector2 other) {
					return Length.Universal(						Math.Sqrt(
															( X - other.X ).InUniversal.Squared() 
							+								( Y - other.Y ).InUniversal.Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Area DistanceSquared( Vector2 other) {
					return (Area)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Length Distance( ref  Vector2 other) {
					return Length.Universal(						Math.Sqrt(
															( X - other.X ).InUniversal.Squared() 
							+								( Y - other.Y ).InUniversal.Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Area DistanceSquared( ref  Vector2 other) {
					return (Area)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
										
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2"/>.</summary>
		public Length X;
			/// <summary>The second axis of the <see cref="Vector2"/>.</summary>
		public Length Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2"/>.</summary>
	public static readonly Vector2 Zero = new Vector2(Length.Zero, Length.Zero);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2"/> from the provided values for each factor.</summary>
	public Vector2(Length x, Length y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2"/> from a list.</summary>
	public Vector2(IList<Length> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2"/> from a single scalar that is applied to all factors.</summary>
	public Vector2(Length value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2"/> has equal factors as the other <see cref="Vector2"/>.</summary>
	public bool Equals(Vector2 other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2"/> of the same type, get whether this <see cref="Vector2"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2)
			return Equals((Vector2)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2"/> to a string of the form "Vector2(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2"/> to a string of the form "Vector2(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2"/> values are equal.</summary>
	public static bool operator ==(Vector2 a, Vector2 b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2"/> values are unequal.</summary>
	public static bool operator !=(Vector2 a, Vector2 b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
			
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2 operator +(Vector2 a) { return new Vector2((Length)(+a.X), (Length)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2 operator -(Vector2 a) { return new Vector2((Length)(-a.X), (Length)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2 operator +(Vector2 a, Vector2 b) { return new Vector2((Length)(a.X + b.X), (Length)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2 operator +(Vector2 a, Length b) { return new Vector2((Length)(a.X + b), (Length)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2 operator +(Length a, Vector2 b) { return new Vector2((Length)(a + b.X), (Length)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2 operator -(Vector2 a, Vector2 b) { return new Vector2((Length)(a.X - b.X), (Length)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2 operator -(Vector2 a, Length b) { return new Vector2((Length)(a.X - b), (Length)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2 operator -(Length a, Vector2 b) { return new Vector2((Length)(a - b.X), (Length)(a - b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="Single"/> elements.</summary>
	[VectorTypeAttribute(typeof(Single), 2, false)]
	public partial struct Vector2f : IEquatable<Vector2f>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Single MagnitudeSquared { get { return (Single)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Single Magnitude {
				get {
					return (Single)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2f Normalized { get { Vector2f result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Single Product { get { return (Single)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Single Sum { get { return (Single)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2f One = new Vector2f((Single)1, (Single)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2f UnitX = new Vector2f((Single)1, (Single)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2f UnitY = new Vector2f((Single)0, (Single)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Single Dot( Vector2f other) { return (Single)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Single Dot( ref  Vector2f other) { return (Single)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2f Clamp( Vector2f min,  Vector2f max ) {
					Vector2f result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2f min,  ref  Vector2f max , out Vector2f result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Single Distance( Vector2f other) {
					return (Single)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Single DistanceSquared( Vector2f other) {
					return (Single)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Single Distance( ref  Vector2f other) {
					return (Single)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Single DistanceSquared( ref  Vector2f other) {
					return (Single)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2f result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (Single)(X * m);  result.Y = (Single)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Single m = (Single)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2f"/>.</summary>
		public Single X;
			/// <summary>The second axis of the <see cref="Vector2f"/>.</summary>
		public Single Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2f"/>.</summary>
	public static readonly Vector2f Zero = new Vector2f((Single)0, (Single)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2f"/> from the provided values for each factor.</summary>
	public Vector2f(Single x, Single y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2f"/> from a list.</summary>
	public Vector2f(IList<Single> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2f"/> from a single scalar that is applied to all factors.</summary>
	public Vector2f(Single value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2f"/> has equal factors as the other <see cref="Vector2f"/>.</summary>
	public bool Equals(Vector2f other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2f"/> of the same type, get whether this <see cref="Vector2f"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2f)
			return Equals((Vector2f)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2f"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2f"/> to a string of the form "Vector2f(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2f"/> to a string of the form "Vector2f(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2f(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2f"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2f"/> values are equal.</summary>
	public static bool operator ==(Vector2f a, Vector2f b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2f"/> values are unequal.</summary>
	public static bool operator !=(Vector2f a, Vector2f b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2f"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2f a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2f a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2f a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2f a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2f a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2f a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2f a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2f a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2f a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2f a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2f a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2f a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2f a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2f"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2f a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2f operator +(Vector2f a) { return new Vector2f((Single)(+a.X), (Single)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2f operator -(Vector2f a) { return new Vector2f((Single)(-a.X), (Single)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2f operator +(Vector2f a, Vector2f b) { return new Vector2f((Single)(a.X + b.X), (Single)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2f operator +(Vector2f a, Single b) { return new Vector2f((Single)(a.X + b), (Single)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2f operator +(Single a, Vector2f b) { return new Vector2f((Single)(a + b.X), (Single)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2f operator -(Vector2f a, Vector2f b) { return new Vector2f((Single)(a.X - b.X), (Single)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2f operator -(Vector2f a, Single b) { return new Vector2f((Single)(a.X - b), (Single)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2f operator -(Single a, Vector2f b) { return new Vector2f((Single)(a - b.X), (Single)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2f operator *(Vector2f a, Vector2f b) { return new Vector2f((Single)(a.X * b.X), (Single)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2f operator *(Vector2f a, Single b) { return new Vector2f((Single)(a.X * b), (Single)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2f operator *(Single a, Vector2f b) { return new Vector2f((Single)(a * b.X), (Single)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2f operator /(Vector2f a, Vector2f b) { return new Vector2f((Single)(a.X / b.X), (Single)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2f operator /(Vector2f a, Single b) { return new Vector2f((Single)(a.X / b), (Single)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2f operator /(Single a, Vector2f b) { return new Vector2f((Single)(a / b.X), (Single)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2f operator %(Vector2f a, Vector2f b) { return new Vector2f((Single)(a.X % b.X), (Single)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2f operator %(Vector2f a, Single b) { return new Vector2f((Single)(a.X % b), (Single)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2f operator %(Single a, Vector2f b) { return new Vector2f((Single)(a % b.X), (Single)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="Double"/> elements.</summary>
	[VectorTypeAttribute(typeof(Double), 2, false)]
	public partial struct Vector2d : IEquatable<Vector2d>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Double Magnitude {
				get {
					return (Double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2d Normalized { get { Vector2d result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Double Product { get { return (Double)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Double Sum { get { return (Double)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2d One = new Vector2d((Double)1, (Double)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2d UnitX = new Vector2d((Double)1, (Double)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2d UnitY = new Vector2d((Double)0, (Double)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2d other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2d other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2d Clamp( Vector2d min,  Vector2d max ) {
					Vector2d result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2d min,  ref  Vector2d max , out Vector2d result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Double Distance( Vector2d other) {
					return (Double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2d other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Double Distance( ref  Vector2d other) {
					return (Double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2d other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2d result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (Double)(X * m);  result.Y = (Double)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Double m = (Double)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2d"/>.</summary>
		public Double X;
			/// <summary>The second axis of the <see cref="Vector2d"/>.</summary>
		public Double Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2d"/>.</summary>
	public static readonly Vector2d Zero = new Vector2d((Double)0, (Double)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2d"/> from the provided values for each factor.</summary>
	public Vector2d(Double x, Double y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2d"/> from a list.</summary>
	public Vector2d(IList<Double> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2d"/> from a single scalar that is applied to all factors.</summary>
	public Vector2d(Double value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2d"/> has equal factors as the other <see cref="Vector2d"/>.</summary>
	public bool Equals(Vector2d other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2d"/> of the same type, get whether this <see cref="Vector2d"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2d)
			return Equals((Vector2d)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2d"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2d"/> to a string of the form "Vector2d(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2d"/> to a string of the form "Vector2d(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2d(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2d"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2d"/> values are equal.</summary>
	public static bool operator ==(Vector2d a, Vector2d b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2d"/> values are unequal.</summary>
	public static bool operator !=(Vector2d a, Vector2d b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2f(Vector2d a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2d a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2d a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2d a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2d a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2d a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2d a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2d a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2d a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2d a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2d a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2d a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2d a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2d"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2d a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2d operator +(Vector2d a) { return new Vector2d((Double)(+a.X), (Double)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2d operator -(Vector2d a) { return new Vector2d((Double)(-a.X), (Double)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2d operator +(Vector2d a, Vector2d b) { return new Vector2d((Double)(a.X + b.X), (Double)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2d operator +(Vector2d a, Double b) { return new Vector2d((Double)(a.X + b), (Double)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2d operator +(Double a, Vector2d b) { return new Vector2d((Double)(a + b.X), (Double)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2d operator -(Vector2d a, Vector2d b) { return new Vector2d((Double)(a.X - b.X), (Double)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2d operator -(Vector2d a, Double b) { return new Vector2d((Double)(a.X - b), (Double)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2d operator -(Double a, Vector2d b) { return new Vector2d((Double)(a - b.X), (Double)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2d operator *(Vector2d a, Vector2d b) { return new Vector2d((Double)(a.X * b.X), (Double)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2d operator *(Vector2d a, Double b) { return new Vector2d((Double)(a.X * b), (Double)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2d operator *(Double a, Vector2d b) { return new Vector2d((Double)(a * b.X), (Double)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2d operator /(Vector2d a, Vector2d b) { return new Vector2d((Double)(a.X / b.X), (Double)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2d operator /(Vector2d a, Double b) { return new Vector2d((Double)(a.X / b), (Double)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2d operator /(Double a, Vector2d b) { return new Vector2d((Double)(a / b.X), (Double)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2d operator %(Vector2d a, Vector2d b) { return new Vector2d((Double)(a.X % b.X), (Double)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2d operator %(Vector2d a, Double b) { return new Vector2d((Double)(a.X % b), (Double)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2d operator %(Double a, Vector2d b) { return new Vector2d((Double)(a % b.X), (Double)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="Int16"/> elements.</summary>
	[VectorTypeAttribute(typeof(Int16), 2, false)]
	public partial struct Vector2s : IEquatable<Vector2s>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Int16 MagnitudeSquared { get { return (Int16)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Int16 Product { get { return (Int16)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Int16 Sum { get { return (Int16)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2s One = new Vector2s((Int16)1, (Int16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2s UnitX = new Vector2s((Int16)1, (Int16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2s UnitY = new Vector2s((Int16)0, (Int16)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Int16 Dot( Vector2s other) { return (Int16)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Int16 Dot( ref  Vector2s other) { return (Int16)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2s Clamp( Vector2s min,  Vector2s max ) {
					Vector2s result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2s min,  ref  Vector2s max , out Vector2s result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2s other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int16 DistanceSquared( Vector2s other) {
					return (Int16)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2s other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int16 DistanceSquared( ref  Vector2s other) {
					return (Int16)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2s"/>.</summary>
		public Int16 X;
			/// <summary>The second axis of the <see cref="Vector2s"/>.</summary>
		public Int16 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2s"/>.</summary>
	public static readonly Vector2s Zero = new Vector2s((Int16)0, (Int16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2s"/> from the provided values for each factor.</summary>
	public Vector2s(Int16 x, Int16 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2s"/> from a list.</summary>
	public Vector2s(IList<Int16> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2s"/> from a single scalar that is applied to all factors.</summary>
	public Vector2s(Int16 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2s"/> has equal factors as the other <see cref="Vector2s"/>.</summary>
	public bool Equals(Vector2s other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2s"/> of the same type, get whether this <see cref="Vector2s"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2s)
			return Equals((Vector2s)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2s"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2s"/> to a string of the form "Vector2s(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2s"/> to a string of the form "Vector2s(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2s(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2s"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2s"/> values are equal.</summary>
	public static bool operator ==(Vector2s a, Vector2s b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2s"/> values are unequal.</summary>
	public static bool operator !=(Vector2s a, Vector2s b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2s"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2s a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2s"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2s a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2s a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2s a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2s a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2s a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2s a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2s a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2s a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2s a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2s a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2s a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2s a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2s"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2s a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2s operator +(Vector2s a) { return new Vector2s((Int16)(+a.X), (Int16)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2s operator -(Vector2s a) { return new Vector2s((Int16)(-a.X), (Int16)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2s operator +(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X + b.X), (Int16)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2s operator +(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X + b), (Int16)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2s operator +(Int16 a, Vector2s b) { return new Vector2s((Int16)(a + b.X), (Int16)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2s operator -(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X - b.X), (Int16)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2s operator -(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X - b), (Int16)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2s operator -(Int16 a, Vector2s b) { return new Vector2s((Int16)(a - b.X), (Int16)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2s operator *(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X * b.X), (Int16)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2s operator *(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X * b), (Int16)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2s operator *(Int16 a, Vector2s b) { return new Vector2s((Int16)(a * b.X), (Int16)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2s operator /(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X / b.X), (Int16)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2s operator /(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X / b), (Int16)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2s operator /(Int16 a, Vector2s b) { return new Vector2s((Int16)(a / b.X), (Int16)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2s operator %(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X % b.X), (Int16)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2s operator %(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X % b), (Int16)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2s operator %(Int16 a, Vector2s b) { return new Vector2s((Int16)(a % b.X), (Int16)(a % b.Y)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector2s operator &(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X & b.X), (Int16)(a.Y & b.Y)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector2s operator &(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X & b), (Int16)(a.Y & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector2s operator &(Int16 a, Vector2s b) { return new Vector2s((Int16)(a & b.X), (Int16)(a & b.Y)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector2s operator |(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X | b.X), (Int16)(a.Y | b.Y)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector2s operator |(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X | b), (Int16)(a.Y | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector2s operator |(Int16 a, Vector2s b) { return new Vector2s((Int16)(a | b.X), (Int16)(a | b.Y)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector2s operator ^(Vector2s a, Vector2s b) { return new Vector2s((Int16)(a.X ^ b.X), (Int16)(a.Y ^ b.Y)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector2s operator ^(Vector2s a, Int16 b) { return new Vector2s((Int16)(a.X ^ b), (Int16)(a.Y ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector2s operator ^(Int16 a, Vector2s b) { return new Vector2s((Int16)(a ^ b.X), (Int16)(a ^ b.Y)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector2s operator <<(Vector2s a, int b) { return new Vector2s((Int16)(a.X << b), (Int16)(a.Y << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector2s operator >>(Vector2s a, int b) { return new Vector2s((Int16)(a.X >> b), (Int16)(a.Y >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="UInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(UInt16), 2, false)]
	public partial struct Vector2us : IEquatable<Vector2us>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public UInt16 MagnitudeSquared { get { return (UInt16)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public UInt16 Product { get { return (UInt16)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public UInt16 Sum { get { return (UInt16)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2us One = new Vector2us((UInt16)1, (UInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2us UnitX = new Vector2us((UInt16)1, (UInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2us UnitY = new Vector2us((UInt16)0, (UInt16)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public UInt16 Dot( Vector2us other) { return (UInt16)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public UInt16 Dot( ref  Vector2us other) { return (UInt16)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2us Clamp( Vector2us min,  Vector2us max ) {
					Vector2us result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2us min,  ref  Vector2us max , out Vector2us result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2us other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt16 DistanceSquared( Vector2us other) {
					return (UInt16)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2us other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt16 DistanceSquared( ref  Vector2us other) {
					return (UInt16)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2us"/>.</summary>
		public UInt16 X;
			/// <summary>The second axis of the <see cref="Vector2us"/>.</summary>
		public UInt16 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2us"/>.</summary>
	public static readonly Vector2us Zero = new Vector2us((UInt16)0, (UInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2us"/> from the provided values for each factor.</summary>
	public Vector2us(UInt16 x, UInt16 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2us"/> from a list.</summary>
	public Vector2us(IList<UInt16> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2us"/> from a single scalar that is applied to all factors.</summary>
	public Vector2us(UInt16 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2us"/> has equal factors as the other <see cref="Vector2us"/>.</summary>
	public bool Equals(Vector2us other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2us"/> of the same type, get whether this <see cref="Vector2us"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2us)
			return Equals((Vector2us)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2us"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2us"/> to a string of the form "Vector2us(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2us"/> to a string of the form "Vector2us(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2us(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2us"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2us"/> values are equal.</summary>
	public static bool operator ==(Vector2us a, Vector2us b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2us"/> values are unequal.</summary>
	public static bool operator !=(Vector2us a, Vector2us b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2us"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2us a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2us"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2us a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2us a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2us a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2us a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2us a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2us a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2us a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2us a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2us a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2us a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2us a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2us a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2us"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2us a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2us operator +(Vector2us a) { return new Vector2us((UInt16)(+a.X), (UInt16)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2us operator -(Vector2us a) { return new Vector2us((UInt16)(-a.X), (UInt16)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2us operator +(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X + b.X), (UInt16)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2us operator +(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X + b), (UInt16)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2us operator +(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a + b.X), (UInt16)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2us operator -(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X - b.X), (UInt16)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2us operator -(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X - b), (UInt16)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2us operator -(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a - b.X), (UInt16)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2us operator *(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X * b.X), (UInt16)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2us operator *(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X * b), (UInt16)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2us operator *(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a * b.X), (UInt16)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2us operator /(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X / b.X), (UInt16)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2us operator /(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X / b), (UInt16)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2us operator /(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a / b.X), (UInt16)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2us operator %(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X % b.X), (UInt16)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2us operator %(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X % b), (UInt16)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2us operator %(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a % b.X), (UInt16)(a % b.Y)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector2us operator &(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X & b.X), (UInt16)(a.Y & b.Y)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector2us operator &(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X & b), (UInt16)(a.Y & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector2us operator &(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a & b.X), (UInt16)(a & b.Y)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector2us operator |(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X | b.X), (UInt16)(a.Y | b.Y)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector2us operator |(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X | b), (UInt16)(a.Y | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector2us operator |(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a | b.X), (UInt16)(a | b.Y)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector2us operator ^(Vector2us a, Vector2us b) { return new Vector2us((UInt16)(a.X ^ b.X), (UInt16)(a.Y ^ b.Y)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector2us operator ^(Vector2us a, UInt16 b) { return new Vector2us((UInt16)(a.X ^ b), (UInt16)(a.Y ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector2us operator ^(UInt16 a, Vector2us b) { return new Vector2us((UInt16)(a ^ b.X), (UInt16)(a ^ b.Y)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector2us operator <<(Vector2us a, int b) { return new Vector2us((UInt16)(a.X << b), (UInt16)(a.Y << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector2us operator >>(Vector2us a, int b) { return new Vector2us((UInt16)(a.X >> b), (UInt16)(a.Y >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="Int32"/> elements.</summary>
	[VectorTypeAttribute(typeof(Int32), 2, false)]
	public partial struct Vector2i : IEquatable<Vector2i>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Int32 MagnitudeSquared { get { return (Int32)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Int32 Product { get { return (Int32)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Int32 Sum { get { return (Int32)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2i One = new Vector2i((Int32)1, (Int32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2i UnitX = new Vector2i((Int32)1, (Int32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2i UnitY = new Vector2i((Int32)0, (Int32)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Int32 Dot( Vector2i other) { return (Int32)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Int32 Dot( ref  Vector2i other) { return (Int32)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2i Clamp( Vector2i min,  Vector2i max ) {
					Vector2i result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2i min,  ref  Vector2i max , out Vector2i result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2i other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int32 DistanceSquared( Vector2i other) {
					return (Int32)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2i other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int32 DistanceSquared( ref  Vector2i other) {
					return (Int32)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2i"/>.</summary>
		public Int32 X;
			/// <summary>The second axis of the <see cref="Vector2i"/>.</summary>
		public Int32 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2i"/>.</summary>
	public static readonly Vector2i Zero = new Vector2i((Int32)0, (Int32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2i"/> from the provided values for each factor.</summary>
	public Vector2i(Int32 x, Int32 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2i"/> from a list.</summary>
	public Vector2i(IList<Int32> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2i"/> from a single scalar that is applied to all factors.</summary>
	public Vector2i(Int32 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2i"/> has equal factors as the other <see cref="Vector2i"/>.</summary>
	public bool Equals(Vector2i other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2i"/> of the same type, get whether this <see cref="Vector2i"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2i)
			return Equals((Vector2i)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2i"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2i"/> to a string of the form "Vector2i(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2i"/> to a string of the form "Vector2i(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2i(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2i"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2i"/> values are equal.</summary>
	public static bool operator ==(Vector2i a, Vector2i b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2i"/> values are unequal.</summary>
	public static bool operator !=(Vector2i a, Vector2i b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2i"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2i a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2i"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2i a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2i a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2i a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2i a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2i a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2i a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2i a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2i a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2i a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2i a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2i a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2i a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2i"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2i a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2i operator +(Vector2i a) { return new Vector2i((Int32)(+a.X), (Int32)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2i operator -(Vector2i a) { return new Vector2i((Int32)(-a.X), (Int32)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2i operator +(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X + b.X), (Int32)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2i operator +(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X + b), (Int32)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2i operator +(Int32 a, Vector2i b) { return new Vector2i((Int32)(a + b.X), (Int32)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2i operator -(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X - b.X), (Int32)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2i operator -(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X - b), (Int32)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2i operator -(Int32 a, Vector2i b) { return new Vector2i((Int32)(a - b.X), (Int32)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2i operator *(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X * b.X), (Int32)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2i operator *(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X * b), (Int32)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2i operator *(Int32 a, Vector2i b) { return new Vector2i((Int32)(a * b.X), (Int32)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2i operator /(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X / b.X), (Int32)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2i operator /(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X / b), (Int32)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2i operator /(Int32 a, Vector2i b) { return new Vector2i((Int32)(a / b.X), (Int32)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2i operator %(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X % b.X), (Int32)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2i operator %(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X % b), (Int32)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2i operator %(Int32 a, Vector2i b) { return new Vector2i((Int32)(a % b.X), (Int32)(a % b.Y)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector2i operator &(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X & b.X), (Int32)(a.Y & b.Y)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector2i operator &(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X & b), (Int32)(a.Y & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector2i operator &(Int32 a, Vector2i b) { return new Vector2i((Int32)(a & b.X), (Int32)(a & b.Y)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector2i operator |(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X | b.X), (Int32)(a.Y | b.Y)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector2i operator |(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X | b), (Int32)(a.Y | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector2i operator |(Int32 a, Vector2i b) { return new Vector2i((Int32)(a | b.X), (Int32)(a | b.Y)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector2i operator ^(Vector2i a, Vector2i b) { return new Vector2i((Int32)(a.X ^ b.X), (Int32)(a.Y ^ b.Y)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector2i operator ^(Vector2i a, Int32 b) { return new Vector2i((Int32)(a.X ^ b), (Int32)(a.Y ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector2i operator ^(Int32 a, Vector2i b) { return new Vector2i((Int32)(a ^ b.X), (Int32)(a ^ b.Y)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector2i operator <<(Vector2i a, int b) { return new Vector2i((Int32)(a.X << b), (Int32)(a.Y << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector2i operator >>(Vector2i a, int b) { return new Vector2i((Int32)(a.X >> b), (Int32)(a.Y >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="UInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(UInt32), 2, false)]
	public partial struct Vector2ui : IEquatable<Vector2ui>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public UInt32 MagnitudeSquared { get { return (UInt32)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public UInt32 Product { get { return (UInt32)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public UInt32 Sum { get { return (UInt32)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2ui One = new Vector2ui((UInt32)1, (UInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2ui UnitX = new Vector2ui((UInt32)1, (UInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2ui UnitY = new Vector2ui((UInt32)0, (UInt32)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public UInt32 Dot( Vector2ui other) { return (UInt32)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public UInt32 Dot( ref  Vector2ui other) { return (UInt32)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2ui Clamp( Vector2ui min,  Vector2ui max ) {
					Vector2ui result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2ui min,  ref  Vector2ui max , out Vector2ui result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2ui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt32 DistanceSquared( Vector2ui other) {
					return (UInt32)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2ui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt32 DistanceSquared( ref  Vector2ui other) {
					return (UInt32)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2ui"/>.</summary>
		public UInt32 X;
			/// <summary>The second axis of the <see cref="Vector2ui"/>.</summary>
		public UInt32 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2ui"/>.</summary>
	public static readonly Vector2ui Zero = new Vector2ui((UInt32)0, (UInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2ui"/> from the provided values for each factor.</summary>
	public Vector2ui(UInt32 x, UInt32 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2ui"/> from a list.</summary>
	public Vector2ui(IList<UInt32> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2ui"/> from a single scalar that is applied to all factors.</summary>
	public Vector2ui(UInt32 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2ui"/> has equal factors as the other <see cref="Vector2ui"/>.</summary>
	public bool Equals(Vector2ui other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2ui"/> of the same type, get whether this <see cref="Vector2ui"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2ui)
			return Equals((Vector2ui)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2ui"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2ui"/> to a string of the form "Vector2ui(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2ui"/> to a string of the form "Vector2ui(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2ui(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2ui"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2ui"/> values are equal.</summary>
	public static bool operator ==(Vector2ui a, Vector2ui b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2ui"/> values are unequal.</summary>
	public static bool operator !=(Vector2ui a, Vector2ui b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2ui"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2ui a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2ui"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2ui a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2ui a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2ui a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2ui a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2ui a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2ui a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2ui a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2ui a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2ui a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2ui a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2ui a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2ui a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ui"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2ui a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2ui operator +(Vector2ui a) { return new Vector2ui((UInt32)(+a.X), (UInt32)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2ui operator -(Vector2ui a) { return new Vector2ui((UInt32)(-a.X), (UInt32)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2ui operator +(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X + b.X), (UInt32)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2ui operator +(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X + b), (UInt32)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2ui operator +(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a + b.X), (UInt32)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2ui operator -(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X - b.X), (UInt32)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2ui operator -(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X - b), (UInt32)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2ui operator -(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a - b.X), (UInt32)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2ui operator *(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X * b.X), (UInt32)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2ui operator *(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X * b), (UInt32)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2ui operator *(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a * b.X), (UInt32)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2ui operator /(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X / b.X), (UInt32)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2ui operator /(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X / b), (UInt32)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2ui operator /(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a / b.X), (UInt32)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2ui operator %(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X % b.X), (UInt32)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2ui operator %(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X % b), (UInt32)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2ui operator %(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a % b.X), (UInt32)(a % b.Y)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector2ui operator &(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X & b.X), (UInt32)(a.Y & b.Y)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector2ui operator &(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X & b), (UInt32)(a.Y & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector2ui operator &(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a & b.X), (UInt32)(a & b.Y)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector2ui operator |(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X | b.X), (UInt32)(a.Y | b.Y)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector2ui operator |(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X | b), (UInt32)(a.Y | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector2ui operator |(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a | b.X), (UInt32)(a | b.Y)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector2ui operator ^(Vector2ui a, Vector2ui b) { return new Vector2ui((UInt32)(a.X ^ b.X), (UInt32)(a.Y ^ b.Y)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector2ui operator ^(Vector2ui a, UInt32 b) { return new Vector2ui((UInt32)(a.X ^ b), (UInt32)(a.Y ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector2ui operator ^(UInt32 a, Vector2ui b) { return new Vector2ui((UInt32)(a ^ b.X), (UInt32)(a ^ b.Y)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector2ui operator <<(Vector2ui a, int b) { return new Vector2ui((UInt32)(a.X << b), (UInt32)(a.Y << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector2ui operator >>(Vector2ui a, int b) { return new Vector2ui((UInt32)(a.X >> b), (UInt32)(a.Y >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="Byte"/> elements.</summary>
	[VectorTypeAttribute(typeof(Byte), 2, false)]
	public partial struct Vector2b : IEquatable<Vector2b>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public int MagnitudeSquared { get { return (int)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Byte Product { get { return (Byte)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Byte Sum { get { return (Byte)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2b One = new Vector2b((Byte)1, (Byte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2b UnitX = new Vector2b((Byte)1, (Byte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2b UnitY = new Vector2b((Byte)0, (Byte)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public int Dot( Vector2b other) { return (int)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public int Dot( ref  Vector2b other) { return (int)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2b Clamp( Vector2b min,  Vector2b max ) {
					Vector2b result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2b min,  ref  Vector2b max , out Vector2b result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2b other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( Vector2b other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2b other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( ref  Vector2b other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2b"/>.</summary>
		public Byte X;
			/// <summary>The second axis of the <see cref="Vector2b"/>.</summary>
		public Byte Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2b"/>.</summary>
	public static readonly Vector2b Zero = new Vector2b((Byte)0, (Byte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2b"/> from the provided values for each factor.</summary>
	public Vector2b(Byte x, Byte y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2b"/> from a list.</summary>
	public Vector2b(IList<Byte> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2b"/> from a single scalar that is applied to all factors.</summary>
	public Vector2b(Byte value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2b"/> has equal factors as the other <see cref="Vector2b"/>.</summary>
	public bool Equals(Vector2b other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2b"/> of the same type, get whether this <see cref="Vector2b"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2b)
			return Equals((Vector2b)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2b"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2b"/> to a string of the form "Vector2b(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2b"/> to a string of the form "Vector2b(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2b(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2b"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2b"/> values are equal.</summary>
	public static bool operator ==(Vector2b a, Vector2b b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2b"/> values are unequal.</summary>
	public static bool operator !=(Vector2b a, Vector2b b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2b"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2b a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2b"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2b a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2b a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2b a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2b a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2b a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2b a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2b a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2b a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2b a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2b a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2b a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2b a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2b"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2b a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2b operator +(Vector2b a) { return new Vector2b((Byte)(+a.X), (Byte)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2b operator -(Vector2b a) { return new Vector2b((Byte)(-a.X), (Byte)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2b operator +(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X + b.X), (Byte)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2b operator +(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X + b), (Byte)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2b operator +(Byte a, Vector2b b) { return new Vector2b((Byte)(a + b.X), (Byte)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2b operator -(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X - b.X), (Byte)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2b operator -(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X - b), (Byte)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2b operator -(Byte a, Vector2b b) { return new Vector2b((Byte)(a - b.X), (Byte)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2b operator *(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X * b.X), (Byte)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2b operator *(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X * b), (Byte)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2b operator *(Byte a, Vector2b b) { return new Vector2b((Byte)(a * b.X), (Byte)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2b operator /(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X / b.X), (Byte)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2b operator /(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X / b), (Byte)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2b operator /(Byte a, Vector2b b) { return new Vector2b((Byte)(a / b.X), (Byte)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2b operator %(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X % b.X), (Byte)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2b operator %(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X % b), (Byte)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2b operator %(Byte a, Vector2b b) { return new Vector2b((Byte)(a % b.X), (Byte)(a % b.Y)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector2b operator &(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X & b.X), (Byte)(a.Y & b.Y)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector2b operator &(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X & b), (Byte)(a.Y & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector2b operator &(Byte a, Vector2b b) { return new Vector2b((Byte)(a & b.X), (Byte)(a & b.Y)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector2b operator |(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X | b.X), (Byte)(a.Y | b.Y)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector2b operator |(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X | b), (Byte)(a.Y | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector2b operator |(Byte a, Vector2b b) { return new Vector2b((Byte)(a | b.X), (Byte)(a | b.Y)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector2b operator ^(Vector2b a, Vector2b b) { return new Vector2b((Byte)(a.X ^ b.X), (Byte)(a.Y ^ b.Y)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector2b operator ^(Vector2b a, Byte b) { return new Vector2b((Byte)(a.X ^ b), (Byte)(a.Y ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector2b operator ^(Byte a, Vector2b b) { return new Vector2b((Byte)(a ^ b.X), (Byte)(a ^ b.Y)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector2b operator <<(Vector2b a, int b) { return new Vector2b((Byte)(a.X << b), (Byte)(a.Y << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector2b operator >>(Vector2b a, int b) { return new Vector2b((Byte)(a.X >> b), (Byte)(a.Y >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="NormalizedByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedByte), 2, false)]
	public partial struct Vector2nb : IEquatable<Vector2nb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2nb Normalized { get { Vector2nb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedByte Product { get { return (NormalizedByte)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedByte Sum { get { return (NormalizedByte)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector2nb(double x, double y) : this((NormalizedByte)x, (NormalizedByte)y) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nb( Vector2d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nb( ref  Vector2d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2nb One = new Vector2nb((NormalizedByte)1, (NormalizedByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2nb UnitX = new Vector2nb((NormalizedByte)1, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2nb UnitY = new Vector2nb((NormalizedByte)0, (NormalizedByte)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2nb other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2nb other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2nb Clamp( Vector2nb min,  Vector2nb max ) {
					Vector2nb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2nb min,  ref  Vector2nb max , out Vector2nb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2nb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2nb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2nb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2nb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2nb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (NormalizedByte)(X * m);  result.Y = (NormalizedByte)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedByte m = (NormalizedByte)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2nb"/>.</summary>
		public NormalizedByte X;
			/// <summary>The second axis of the <see cref="Vector2nb"/>.</summary>
		public NormalizedByte Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2nb"/>.</summary>
	public static readonly Vector2nb Zero = new Vector2nb((NormalizedByte)0, (NormalizedByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2nb"/> from the provided values for each factor.</summary>
	public Vector2nb(NormalizedByte x, NormalizedByte y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2nb"/> from a list.</summary>
	public Vector2nb(IList<NormalizedByte> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2nb"/> from a single scalar that is applied to all factors.</summary>
	public Vector2nb(NormalizedByte value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2nb"/> has equal factors as the other <see cref="Vector2nb"/>.</summary>
	public bool Equals(Vector2nb other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2nb"/> of the same type, get whether this <see cref="Vector2nb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2nb)
			return Equals((Vector2nb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2nb"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2nb"/> to a string of the form "Vector2nb(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2nb"/> to a string of the form "Vector2nb(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2nb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2nb"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2nb"/> values are equal.</summary>
	public static bool operator ==(Vector2nb a, Vector2nb b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2nb"/> values are unequal.</summary>
	public static bool operator !=(Vector2nb a, Vector2nb b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2nb"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2nb a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2nb"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2nb a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2nb a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2nb a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2nb a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2nb a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2nb a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2nb a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2nb a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2nb a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2nb a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2nb a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2nb a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nb"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2nb a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2nb operator +(Vector2nb a) { return new Vector2nb((NormalizedByte)(+a.X), (NormalizedByte)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2nb operator -(Vector2nb a) { return new Vector2nb((NormalizedByte)(-a.X), (NormalizedByte)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2nb operator +(Vector2nb a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a.X + b.X), (NormalizedByte)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2nb operator +(Vector2nb a, NormalizedByte b) { return new Vector2nb((NormalizedByte)(a.X + b), (NormalizedByte)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2nb operator +(NormalizedByte a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a + b.X), (NormalizedByte)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2nb operator -(Vector2nb a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a.X - b.X), (NormalizedByte)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2nb operator -(Vector2nb a, NormalizedByte b) { return new Vector2nb((NormalizedByte)(a.X - b), (NormalizedByte)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2nb operator -(NormalizedByte a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a - b.X), (NormalizedByte)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2nb operator *(Vector2nb a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a.X * b.X), (NormalizedByte)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2nb operator *(Vector2nb a, NormalizedByte b) { return new Vector2nb((NormalizedByte)(a.X * b), (NormalizedByte)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2nb operator *(NormalizedByte a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a * b.X), (NormalizedByte)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2nb operator /(Vector2nb a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a.X / b.X), (NormalizedByte)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2nb operator /(Vector2nb a, NormalizedByte b) { return new Vector2nb((NormalizedByte)(a.X / b), (NormalizedByte)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2nb operator /(NormalizedByte a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a / b.X), (NormalizedByte)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2nb operator %(Vector2nb a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a.X % b.X), (NormalizedByte)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2nb operator %(Vector2nb a, NormalizedByte b) { return new Vector2nb((NormalizedByte)(a.X % b), (NormalizedByte)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2nb operator %(NormalizedByte a, Vector2nb b) { return new Vector2nb((NormalizedByte)(a % b.X), (NormalizedByte)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="NormalizedSByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedSByte), 2, false)]
	public partial struct Vector2nsb : IEquatable<Vector2nsb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2nsb Normalized { get { Vector2nsb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedSByte Product { get { return (NormalizedSByte)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedSByte Sum { get { return (NormalizedSByte)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector2nsb(double x, double y) : this((NormalizedSByte)x, (NormalizedSByte)y) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nsb( Vector2d value) : this((NormalizedSByte)value.X, (NormalizedSByte)value.Y) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nsb( ref  Vector2d value) : this((NormalizedSByte)value.X, (NormalizedSByte)value.Y) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2nsb One = new Vector2nsb((NormalizedSByte)1, (NormalizedSByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2nsb UnitX = new Vector2nsb((NormalizedSByte)1, (NormalizedSByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2nsb UnitY = new Vector2nsb((NormalizedSByte)0, (NormalizedSByte)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2nsb other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2nsb other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2nsb Clamp( Vector2nsb min,  Vector2nsb max ) {
					Vector2nsb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2nsb min,  ref  Vector2nsb max , out Vector2nsb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2nsb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2nsb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2nsb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2nsb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2nsb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (NormalizedSByte)(X * m);  result.Y = (NormalizedSByte)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedSByte m = (NormalizedSByte)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2nsb"/>.</summary>
		public NormalizedSByte X;
			/// <summary>The second axis of the <see cref="Vector2nsb"/>.</summary>
		public NormalizedSByte Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2nsb"/>.</summary>
	public static readonly Vector2nsb Zero = new Vector2nsb((NormalizedSByte)0, (NormalizedSByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2nsb"/> from the provided values for each factor.</summary>
	public Vector2nsb(NormalizedSByte x, NormalizedSByte y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2nsb"/> from a list.</summary>
	public Vector2nsb(IList<NormalizedSByte> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2nsb"/> from a single scalar that is applied to all factors.</summary>
	public Vector2nsb(NormalizedSByte value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2nsb"/> has equal factors as the other <see cref="Vector2nsb"/>.</summary>
	public bool Equals(Vector2nsb other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2nsb"/> of the same type, get whether this <see cref="Vector2nsb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2nsb)
			return Equals((Vector2nsb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2nsb"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2nsb"/> to a string of the form "Vector2nsb(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2nsb"/> to a string of the form "Vector2nsb(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2nsb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2nsb"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2nsb"/> values are equal.</summary>
	public static bool operator ==(Vector2nsb a, Vector2nsb b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2nsb"/> values are unequal.</summary>
	public static bool operator !=(Vector2nsb a, Vector2nsb b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2nsb a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2nsb a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2nsb a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2nsb a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2nsb a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2nsb a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2nsb a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2nsb a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2nsb a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2nsb a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2nsb a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2nsb a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2nsb a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nsb"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2nsb a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2nsb operator +(Vector2nsb a) { return new Vector2nsb((NormalizedSByte)(+a.X), (NormalizedSByte)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2nsb operator -(Vector2nsb a) { return new Vector2nsb((NormalizedSByte)(-a.X), (NormalizedSByte)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2nsb operator +(Vector2nsb a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a.X + b.X), (NormalizedSByte)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2nsb operator +(Vector2nsb a, NormalizedSByte b) { return new Vector2nsb((NormalizedSByte)(a.X + b), (NormalizedSByte)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2nsb operator +(NormalizedSByte a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a + b.X), (NormalizedSByte)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2nsb operator -(Vector2nsb a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a.X - b.X), (NormalizedSByte)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2nsb operator -(Vector2nsb a, NormalizedSByte b) { return new Vector2nsb((NormalizedSByte)(a.X - b), (NormalizedSByte)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2nsb operator -(NormalizedSByte a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a - b.X), (NormalizedSByte)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2nsb operator *(Vector2nsb a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a.X * b.X), (NormalizedSByte)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2nsb operator *(Vector2nsb a, NormalizedSByte b) { return new Vector2nsb((NormalizedSByte)(a.X * b), (NormalizedSByte)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2nsb operator *(NormalizedSByte a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a * b.X), (NormalizedSByte)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2nsb operator /(Vector2nsb a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a.X / b.X), (NormalizedSByte)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2nsb operator /(Vector2nsb a, NormalizedSByte b) { return new Vector2nsb((NormalizedSByte)(a.X / b), (NormalizedSByte)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2nsb operator /(NormalizedSByte a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a / b.X), (NormalizedSByte)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2nsb operator %(Vector2nsb a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a.X % b.X), (NormalizedSByte)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2nsb operator %(Vector2nsb a, NormalizedSByte b) { return new Vector2nsb((NormalizedSByte)(a.X % b), (NormalizedSByte)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2nsb operator %(NormalizedSByte a, Vector2nsb b) { return new Vector2nsb((NormalizedSByte)(a % b.X), (NormalizedSByte)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="NormalizedInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedInt16), 2, false)]
	public partial struct Vector2ns : IEquatable<Vector2ns>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2ns Normalized { get { Vector2ns result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedInt16 Product { get { return (NormalizedInt16)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedInt16 Sum { get { return (NormalizedInt16)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector2ns(double x, double y) : this((NormalizedInt16)x, (NormalizedInt16)y) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2ns( Vector2d value) : this((NormalizedInt16)value.X, (NormalizedInt16)value.Y) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2ns( ref  Vector2d value) : this((NormalizedInt16)value.X, (NormalizedInt16)value.Y) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2ns One = new Vector2ns((NormalizedInt16)1, (NormalizedInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2ns UnitX = new Vector2ns((NormalizedInt16)1, (NormalizedInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2ns UnitY = new Vector2ns((NormalizedInt16)0, (NormalizedInt16)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2ns other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2ns other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2ns Clamp( Vector2ns min,  Vector2ns max ) {
					Vector2ns result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2ns min,  ref  Vector2ns max , out Vector2ns result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2ns other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2ns other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2ns other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2ns other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2ns result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (NormalizedInt16)(X * m);  result.Y = (NormalizedInt16)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedInt16 m = (NormalizedInt16)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2ns"/>.</summary>
		public NormalizedInt16 X;
			/// <summary>The second axis of the <see cref="Vector2ns"/>.</summary>
		public NormalizedInt16 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2ns"/>.</summary>
	public static readonly Vector2ns Zero = new Vector2ns((NormalizedInt16)0, (NormalizedInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2ns"/> from the provided values for each factor.</summary>
	public Vector2ns(NormalizedInt16 x, NormalizedInt16 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2ns"/> from a list.</summary>
	public Vector2ns(IList<NormalizedInt16> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2ns"/> from a single scalar that is applied to all factors.</summary>
	public Vector2ns(NormalizedInt16 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2ns"/> has equal factors as the other <see cref="Vector2ns"/>.</summary>
	public bool Equals(Vector2ns other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2ns"/> of the same type, get whether this <see cref="Vector2ns"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2ns)
			return Equals((Vector2ns)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2ns"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2ns"/> to a string of the form "Vector2ns(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2ns"/> to a string of the form "Vector2ns(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2ns(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2ns"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2ns"/> values are equal.</summary>
	public static bool operator ==(Vector2ns a, Vector2ns b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2ns"/> values are unequal.</summary>
	public static bool operator !=(Vector2ns a, Vector2ns b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2ns"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2ns a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2ns"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2ns a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2ns a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2ns a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2ns a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2ns a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2ns a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2ns a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2ns a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2ns a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2ns a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2ns a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2ns a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ns"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2ns a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2ns operator +(Vector2ns a) { return new Vector2ns((NormalizedInt16)(+a.X), (NormalizedInt16)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2ns operator -(Vector2ns a) { return new Vector2ns((NormalizedInt16)(-a.X), (NormalizedInt16)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2ns operator +(Vector2ns a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a.X + b.X), (NormalizedInt16)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2ns operator +(Vector2ns a, NormalizedInt16 b) { return new Vector2ns((NormalizedInt16)(a.X + b), (NormalizedInt16)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2ns operator +(NormalizedInt16 a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a + b.X), (NormalizedInt16)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2ns operator -(Vector2ns a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a.X - b.X), (NormalizedInt16)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2ns operator -(Vector2ns a, NormalizedInt16 b) { return new Vector2ns((NormalizedInt16)(a.X - b), (NormalizedInt16)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2ns operator -(NormalizedInt16 a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a - b.X), (NormalizedInt16)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2ns operator *(Vector2ns a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a.X * b.X), (NormalizedInt16)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2ns operator *(Vector2ns a, NormalizedInt16 b) { return new Vector2ns((NormalizedInt16)(a.X * b), (NormalizedInt16)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2ns operator *(NormalizedInt16 a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a * b.X), (NormalizedInt16)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2ns operator /(Vector2ns a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a.X / b.X), (NormalizedInt16)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2ns operator /(Vector2ns a, NormalizedInt16 b) { return new Vector2ns((NormalizedInt16)(a.X / b), (NormalizedInt16)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2ns operator /(NormalizedInt16 a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a / b.X), (NormalizedInt16)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2ns operator %(Vector2ns a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a.X % b.X), (NormalizedInt16)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2ns operator %(Vector2ns a, NormalizedInt16 b) { return new Vector2ns((NormalizedInt16)(a.X % b), (NormalizedInt16)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2ns operator %(NormalizedInt16 a, Vector2ns b) { return new Vector2ns((NormalizedInt16)(a % b.X), (NormalizedInt16)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="NormalizedInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedInt32), 2, false)]
	public partial struct Vector2ni : IEquatable<Vector2ni>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2ni Normalized { get { Vector2ni result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedInt32 Product { get { return (NormalizedInt32)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedInt32 Sum { get { return (NormalizedInt32)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector2ni(double x, double y) : this((NormalizedInt32)x, (NormalizedInt32)y) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2ni( Vector2d value) : this((NormalizedInt32)value.X, (NormalizedInt32)value.Y) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2ni( ref  Vector2d value) : this((NormalizedInt32)value.X, (NormalizedInt32)value.Y) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2ni One = new Vector2ni((NormalizedInt32)1, (NormalizedInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2ni UnitX = new Vector2ni((NormalizedInt32)1, (NormalizedInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2ni UnitY = new Vector2ni((NormalizedInt32)0, (NormalizedInt32)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2ni other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2ni other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2ni Clamp( Vector2ni min,  Vector2ni max ) {
					Vector2ni result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2ni min,  ref  Vector2ni max , out Vector2ni result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2ni other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2ni other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2ni other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2ni other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2ni result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (NormalizedInt32)(X * m);  result.Y = (NormalizedInt32)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedInt32 m = (NormalizedInt32)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2ni"/>.</summary>
		public NormalizedInt32 X;
			/// <summary>The second axis of the <see cref="Vector2ni"/>.</summary>
		public NormalizedInt32 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2ni"/>.</summary>
	public static readonly Vector2ni Zero = new Vector2ni((NormalizedInt32)0, (NormalizedInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2ni"/> from the provided values for each factor.</summary>
	public Vector2ni(NormalizedInt32 x, NormalizedInt32 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2ni"/> from a list.</summary>
	public Vector2ni(IList<NormalizedInt32> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2ni"/> from a single scalar that is applied to all factors.</summary>
	public Vector2ni(NormalizedInt32 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2ni"/> has equal factors as the other <see cref="Vector2ni"/>.</summary>
	public bool Equals(Vector2ni other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2ni"/> of the same type, get whether this <see cref="Vector2ni"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2ni)
			return Equals((Vector2ni)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2ni"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2ni"/> to a string of the form "Vector2ni(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2ni"/> to a string of the form "Vector2ni(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2ni(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2ni"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2ni"/> values are equal.</summary>
	public static bool operator ==(Vector2ni a, Vector2ni b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2ni"/> values are unequal.</summary>
	public static bool operator !=(Vector2ni a, Vector2ni b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2ni"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2ni a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2ni"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2ni a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2ni a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2ni a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2ni a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2ni a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2ni a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2ni a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2ni a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2ni a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2ni a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2ni a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2ni a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2ni"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2ni a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2ni operator +(Vector2ni a) { return new Vector2ni((NormalizedInt32)(+a.X), (NormalizedInt32)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2ni operator -(Vector2ni a) { return new Vector2ni((NormalizedInt32)(-a.X), (NormalizedInt32)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2ni operator +(Vector2ni a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a.X + b.X), (NormalizedInt32)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2ni operator +(Vector2ni a, NormalizedInt32 b) { return new Vector2ni((NormalizedInt32)(a.X + b), (NormalizedInt32)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2ni operator +(NormalizedInt32 a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a + b.X), (NormalizedInt32)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2ni operator -(Vector2ni a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a.X - b.X), (NormalizedInt32)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2ni operator -(Vector2ni a, NormalizedInt32 b) { return new Vector2ni((NormalizedInt32)(a.X - b), (NormalizedInt32)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2ni operator -(NormalizedInt32 a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a - b.X), (NormalizedInt32)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2ni operator *(Vector2ni a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a.X * b.X), (NormalizedInt32)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2ni operator *(Vector2ni a, NormalizedInt32 b) { return new Vector2ni((NormalizedInt32)(a.X * b), (NormalizedInt32)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2ni operator *(NormalizedInt32 a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a * b.X), (NormalizedInt32)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2ni operator /(Vector2ni a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a.X / b.X), (NormalizedInt32)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2ni operator /(Vector2ni a, NormalizedInt32 b) { return new Vector2ni((NormalizedInt32)(a.X / b), (NormalizedInt32)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2ni operator /(NormalizedInt32 a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a / b.X), (NormalizedInt32)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2ni operator %(Vector2ni a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a.X % b.X), (NormalizedInt32)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2ni operator %(Vector2ni a, NormalizedInt32 b) { return new Vector2ni((NormalizedInt32)(a.X % b), (NormalizedInt32)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2ni operator %(NormalizedInt32 a, Vector2ni b) { return new Vector2ni((NormalizedInt32)(a % b.X), (NormalizedInt32)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="NormalizedUInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedUInt16), 2, false)]
	public partial struct Vector2nus : IEquatable<Vector2nus>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2nus Normalized { get { Vector2nus result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedUInt16 Product { get { return (NormalizedUInt16)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedUInt16 Sum { get { return (NormalizedUInt16)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector2nus(double x, double y) : this((NormalizedUInt16)x, (NormalizedUInt16)y) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nus( Vector2d value) : this((NormalizedUInt16)value.X, (NormalizedUInt16)value.Y) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nus( ref  Vector2d value) : this((NormalizedUInt16)value.X, (NormalizedUInt16)value.Y) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2nus One = new Vector2nus((NormalizedUInt16)1, (NormalizedUInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2nus UnitX = new Vector2nus((NormalizedUInt16)1, (NormalizedUInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2nus UnitY = new Vector2nus((NormalizedUInt16)0, (NormalizedUInt16)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2nus other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2nus other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2nus Clamp( Vector2nus min,  Vector2nus max ) {
					Vector2nus result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2nus min,  ref  Vector2nus max , out Vector2nus result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2nus other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2nus other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2nus other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2nus other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2nus result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (NormalizedUInt16)(X * m);  result.Y = (NormalizedUInt16)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedUInt16 m = (NormalizedUInt16)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2nus"/>.</summary>
		public NormalizedUInt16 X;
			/// <summary>The second axis of the <see cref="Vector2nus"/>.</summary>
		public NormalizedUInt16 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2nus"/>.</summary>
	public static readonly Vector2nus Zero = new Vector2nus((NormalizedUInt16)0, (NormalizedUInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2nus"/> from the provided values for each factor.</summary>
	public Vector2nus(NormalizedUInt16 x, NormalizedUInt16 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2nus"/> from a list.</summary>
	public Vector2nus(IList<NormalizedUInt16> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2nus"/> from a single scalar that is applied to all factors.</summary>
	public Vector2nus(NormalizedUInt16 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2nus"/> has equal factors as the other <see cref="Vector2nus"/>.</summary>
	public bool Equals(Vector2nus other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2nus"/> of the same type, get whether this <see cref="Vector2nus"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2nus)
			return Equals((Vector2nus)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2nus"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2nus"/> to a string of the form "Vector2nus(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2nus"/> to a string of the form "Vector2nus(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2nus(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2nus"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2nus"/> values are equal.</summary>
	public static bool operator ==(Vector2nus a, Vector2nus b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2nus"/> values are unequal.</summary>
	public static bool operator !=(Vector2nus a, Vector2nus b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2nus"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2nus a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2nus"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2nus a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2nus a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2nus a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2nus a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2nus a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2nus a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2nus a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2nus a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2nus a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2nus a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2nus a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2nus a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nus"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2nus a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2nus operator +(Vector2nus a) { return new Vector2nus((NormalizedUInt16)(+a.X), (NormalizedUInt16)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2nus operator -(Vector2nus a) { return new Vector2nus((NormalizedUInt16)(-a.X), (NormalizedUInt16)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2nus operator +(Vector2nus a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a.X + b.X), (NormalizedUInt16)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2nus operator +(Vector2nus a, NormalizedUInt16 b) { return new Vector2nus((NormalizedUInt16)(a.X + b), (NormalizedUInt16)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2nus operator +(NormalizedUInt16 a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a + b.X), (NormalizedUInt16)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2nus operator -(Vector2nus a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a.X - b.X), (NormalizedUInt16)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2nus operator -(Vector2nus a, NormalizedUInt16 b) { return new Vector2nus((NormalizedUInt16)(a.X - b), (NormalizedUInt16)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2nus operator -(NormalizedUInt16 a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a - b.X), (NormalizedUInt16)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2nus operator *(Vector2nus a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a.X * b.X), (NormalizedUInt16)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2nus operator *(Vector2nus a, NormalizedUInt16 b) { return new Vector2nus((NormalizedUInt16)(a.X * b), (NormalizedUInt16)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2nus operator *(NormalizedUInt16 a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a * b.X), (NormalizedUInt16)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2nus operator /(Vector2nus a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a.X / b.X), (NormalizedUInt16)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2nus operator /(Vector2nus a, NormalizedUInt16 b) { return new Vector2nus((NormalizedUInt16)(a.X / b), (NormalizedUInt16)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2nus operator /(NormalizedUInt16 a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a / b.X), (NormalizedUInt16)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2nus operator %(Vector2nus a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a.X % b.X), (NormalizedUInt16)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2nus operator %(Vector2nus a, NormalizedUInt16 b) { return new Vector2nus((NormalizedUInt16)(a.X % b), (NormalizedUInt16)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2nus operator %(NormalizedUInt16 a, Vector2nus b) { return new Vector2nus((NormalizedUInt16)(a % b.X), (NormalizedUInt16)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="NormalizedUInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedUInt32), 2, false)]
	public partial struct Vector2nui : IEquatable<Vector2nui>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2nui Normalized { get { Vector2nui result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedUInt32 Product { get { return (NormalizedUInt32)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedUInt32 Sum { get { return (NormalizedUInt32)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector2nui(double x, double y) : this((NormalizedUInt32)x, (NormalizedUInt32)y) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nui( Vector2d value) : this((NormalizedUInt32)value.X, (NormalizedUInt32)value.Y) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector2nui( ref  Vector2d value) : this((NormalizedUInt32)value.X, (NormalizedUInt32)value.Y) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2nui One = new Vector2nui((NormalizedUInt32)1, (NormalizedUInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2nui UnitX = new Vector2nui((NormalizedUInt32)1, (NormalizedUInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2nui UnitY = new Vector2nui((NormalizedUInt32)0, (NormalizedUInt32)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector2nui other) { return (Double)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector2nui other) { return (Double)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2nui Clamp( Vector2nui min,  Vector2nui max ) {
					Vector2nui result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2nui min,  ref  Vector2nui max , out Vector2nui result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2nui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector2nui other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2nui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector2nui other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2nui result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (NormalizedUInt32)(X * m);  result.Y = (NormalizedUInt32)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedUInt32 m = (NormalizedUInt32)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2nui"/>.</summary>
		public NormalizedUInt32 X;
			/// <summary>The second axis of the <see cref="Vector2nui"/>.</summary>
		public NormalizedUInt32 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2nui"/>.</summary>
	public static readonly Vector2nui Zero = new Vector2nui((NormalizedUInt32)0, (NormalizedUInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2nui"/> from the provided values for each factor.</summary>
	public Vector2nui(NormalizedUInt32 x, NormalizedUInt32 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2nui"/> from a list.</summary>
	public Vector2nui(IList<NormalizedUInt32> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2nui"/> from a single scalar that is applied to all factors.</summary>
	public Vector2nui(NormalizedUInt32 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2nui"/> has equal factors as the other <see cref="Vector2nui"/>.</summary>
	public bool Equals(Vector2nui other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2nui"/> of the same type, get whether this <see cref="Vector2nui"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2nui)
			return Equals((Vector2nui)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2nui"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2nui"/> to a string of the form "Vector2nui(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2nui"/> to a string of the form "Vector2nui(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2nui(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2nui"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2nui"/> values are equal.</summary>
	public static bool operator ==(Vector2nui a, Vector2nui b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2nui"/> values are unequal.</summary>
	public static bool operator !=(Vector2nui a, Vector2nui b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2nui"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2nui a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2nui"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2nui a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2nui a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2nui a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2nui a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2nui a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2nui a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2nui a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2nui a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2nui a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2nui a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2nui a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2nui a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2nui"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2nui a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2nui operator +(Vector2nui a) { return new Vector2nui((NormalizedUInt32)(+a.X), (NormalizedUInt32)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2nui operator -(Vector2nui a) { return new Vector2nui((NormalizedUInt32)(-a.X), (NormalizedUInt32)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2nui operator +(Vector2nui a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a.X + b.X), (NormalizedUInt32)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2nui operator +(Vector2nui a, NormalizedUInt32 b) { return new Vector2nui((NormalizedUInt32)(a.X + b), (NormalizedUInt32)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2nui operator +(NormalizedUInt32 a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a + b.X), (NormalizedUInt32)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2nui operator -(Vector2nui a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a.X - b.X), (NormalizedUInt32)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2nui operator -(Vector2nui a, NormalizedUInt32 b) { return new Vector2nui((NormalizedUInt32)(a.X - b), (NormalizedUInt32)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2nui operator -(NormalizedUInt32 a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a - b.X), (NormalizedUInt32)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2nui operator *(Vector2nui a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a.X * b.X), (NormalizedUInt32)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2nui operator *(Vector2nui a, NormalizedUInt32 b) { return new Vector2nui((NormalizedUInt32)(a.X * b), (NormalizedUInt32)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2nui operator *(NormalizedUInt32 a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a * b.X), (NormalizedUInt32)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2nui operator /(Vector2nui a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a.X / b.X), (NormalizedUInt32)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2nui operator /(Vector2nui a, NormalizedUInt32 b) { return new Vector2nui((NormalizedUInt32)(a.X / b), (NormalizedUInt32)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2nui operator /(NormalizedUInt32 a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a / b.X), (NormalizedUInt32)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2nui operator %(Vector2nui a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a.X % b.X), (NormalizedUInt32)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2nui operator %(Vector2nui a, NormalizedUInt32 b) { return new Vector2nui((NormalizedUInt32)(a.X % b), (NormalizedUInt32)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2nui operator %(NormalizedUInt32 a, Vector2nui b) { return new Vector2nui((NormalizedUInt32)(a % b.X), (NormalizedUInt32)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="Float16"/> elements.</summary>
	[VectorTypeAttribute(typeof(Float16), 2, false)]
	public partial struct Vector2h : IEquatable<Vector2h>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Float16 MagnitudeSquared { get { return (Float16)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Float16 Magnitude {
				get {
					return (Float16)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector2h Normalized { get { Vector2h result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Float16 Product { get { return (Float16)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Float16 Sum { get { return (Float16)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2h One = new Vector2h((Float16)1, (Float16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2h UnitX = new Vector2h((Float16)1, (Float16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2h UnitY = new Vector2h((Float16)0, (Float16)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Float16 Dot( Vector2h other) { return (Float16)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Float16 Dot( ref  Vector2h other) { return (Float16)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2h Clamp( Vector2h min,  Vector2h max ) {
					Vector2h result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2h min,  ref  Vector2h max , out Vector2h result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Float16 Distance( Vector2h other) {
					return (Float16)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Float16 DistanceSquared( Vector2h other) {
					return (Float16)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Float16 Distance( ref  Vector2h other) {
					return (Float16)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Float16 DistanceSquared( ref  Vector2h other) {
					return (Float16)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector2h result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y );
						 result.X = (Float16)(X * m);  result.Y = (Float16)(Y * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Float16 m = (Float16)(1.0 / Math.Sqrt( X * X + Y * Y ));
						 X *= m;  Y *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2h"/>.</summary>
		public Float16 X;
			/// <summary>The second axis of the <see cref="Vector2h"/>.</summary>
		public Float16 Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2h"/>.</summary>
	public static readonly Vector2h Zero = new Vector2h((Float16)0, (Float16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2h"/> from the provided values for each factor.</summary>
	public Vector2h(Float16 x, Float16 y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2h"/> from a list.</summary>
	public Vector2h(IList<Float16> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2h"/> from a single scalar that is applied to all factors.</summary>
	public Vector2h(Float16 value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2h"/> has equal factors as the other <see cref="Vector2h"/>.</summary>
	public bool Equals(Vector2h other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2h"/> of the same type, get whether this <see cref="Vector2h"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2h)
			return Equals((Vector2h)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2h"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2h"/> to a string of the form "Vector2h(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2h"/> to a string of the form "Vector2h(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2h(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2h"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2h"/> values are equal.</summary>
	public static bool operator ==(Vector2h a, Vector2h b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2h"/> values are unequal.</summary>
	public static bool operator !=(Vector2h a, Vector2h b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2h"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2h a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2h"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2h a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2h a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2h a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2h a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2h a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2h a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2h a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2h a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2h a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2h a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2h a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2h a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2h"/> to <see cref="Vector2sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2sb(Vector2h a) {
						return new Vector2sb((SByte)a.X, (SByte)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2h operator +(Vector2h a) { return new Vector2h((Float16)(+a.X), (Float16)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2h operator -(Vector2h a) { return new Vector2h((Float16)(-a.X), (Float16)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2h operator +(Vector2h a, Vector2h b) { return new Vector2h((Float16)(a.X + b.X), (Float16)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2h operator +(Vector2h a, Float16 b) { return new Vector2h((Float16)(a.X + b), (Float16)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2h operator +(Float16 a, Vector2h b) { return new Vector2h((Float16)(a + b.X), (Float16)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2h operator -(Vector2h a, Vector2h b) { return new Vector2h((Float16)(a.X - b.X), (Float16)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2h operator -(Vector2h a, Float16 b) { return new Vector2h((Float16)(a.X - b), (Float16)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2h operator -(Float16 a, Vector2h b) { return new Vector2h((Float16)(a - b.X), (Float16)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2h operator *(Vector2h a, Vector2h b) { return new Vector2h((Float16)(a.X * b.X), (Float16)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2h operator *(Vector2h a, Float16 b) { return new Vector2h((Float16)(a.X * b), (Float16)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2h operator *(Float16 a, Vector2h b) { return new Vector2h((Float16)(a * b.X), (Float16)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2h operator /(Vector2h a, Vector2h b) { return new Vector2h((Float16)(a.X / b.X), (Float16)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2h operator /(Vector2h a, Float16 b) { return new Vector2h((Float16)(a.X / b), (Float16)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2h operator /(Float16 a, Vector2h b) { return new Vector2h((Float16)(a / b.X), (Float16)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2h operator %(Vector2h a, Vector2h b) { return new Vector2h((Float16)(a.X % b.X), (Float16)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2h operator %(Vector2h a, Float16 b) { return new Vector2h((Float16)(a.X % b), (Float16)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2h operator %(Float16 a, Vector2h b) { return new Vector2h((Float16)(a % b.X), (Float16)(a % b.Y)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A two-dimensional vector type using <see cref="SByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(SByte), 2, false)]
	public partial struct Vector2sb : IEquatable<Vector2sb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public int MagnitudeSquared { get { return (int)( X * X + Y * Y ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public SByte Product { get { return (SByte)( X * Y ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public SByte Sum { get { return (SByte)( X + Y ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector2sb One = new Vector2sb((SByte)1, (SByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector2sb UnitX = new Vector2sb((SByte)1, (SByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector2sb UnitY = new Vector2sb((SByte)0, (SByte)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public int Dot( Vector2sb other) { return (int)( X * other.X + Y * other.Y ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public int Dot( ref  Vector2sb other) { return (int)( X * other.X + Y * other.Y ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector2sb Clamp( Vector2sb min,  Vector2sb max ) {
					Vector2sb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector2sb min,  ref  Vector2sb max , out Vector2sb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector2sb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( Vector2sb other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector2sb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( ref  Vector2sb other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector2sb"/>.</summary>
		public SByte X;
			/// <summary>The second axis of the <see cref="Vector2sb"/>.</summary>
		public SByte Y;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector2sb"/>.</summary>
	public static readonly Vector2sb Zero = new Vector2sb((SByte)0, (SByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector2sb"/> from the provided values for each factor.</summary>
	public Vector2sb(SByte x, SByte y)
	{
					X = x;
					Y = y;
			}

	/// <summary>Initialise a <see cref="Vector2sb"/> from a list.</summary>
	public Vector2sb(IList<SByte> list, int index = 0) : this(list[index + 0], list[index + 1]) { }

	/// <summary>Initialise a <see cref="Vector2sb"/> from a single scalar that is applied to all factors.</summary>
	public Vector2sb(SByte value) : this(value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector2sb"/> has equal factors as the other <see cref="Vector2sb"/>.</summary>
	public bool Equals(Vector2sb other) {
		return  X == other.X && Y == other.Y ;
	}

	/// <summary>If the other object is a <see cref="Vector2sb"/> of the same type, get whether this <see cref="Vector2sb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector2sb)
			return Equals((Vector2sb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector2sb"/> to a string of the form "X, Y".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector2sb"/> to a string of the form "Vector2sb(X, Y)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector2sb"/> to a string of the form "Vector2sb(X, Y)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector2sb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector2sb"/> to a string of the form "{X, Y".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector2sb"/> values are equal.</summary>
	public static bool operator ==(Vector2sb a, Vector2sb b) { return a.X == b.X&&a.Y == b.Y; }

	/// <summary>Get whether the <see cref="Vector2sb"/> values are unequal.</summary>
	public static bool operator !=(Vector2sb a, Vector2sb b) { return a.X != b.X||a.Y != b.Y; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector2sb"/> to <see cref="Vector2f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2f(Vector2sb a) {
						return new Vector2f((Single)a.X, (Single)a.Y);
					}
					/// <summary>An implicit cast from <see cref="Vector2sb"/> to <see cref="Vector2d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector2d(Vector2sb a) {
						return new Vector2d((Double)a.X, (Double)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2s(Vector2sb a) {
						return new Vector2s((Int16)a.X, (Int16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2us(Vector2sb a) {
						return new Vector2us((UInt16)a.X, (UInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2i(Vector2sb a) {
						return new Vector2i((Int32)a.X, (Int32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ui(Vector2sb a) {
						return new Vector2ui((UInt32)a.X, (UInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2b(Vector2sb a) {
						return new Vector2b((Byte)a.X, (Byte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nb(Vector2sb a) {
						return new Vector2nb((NormalizedByte)a.X, (NormalizedByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nsb(Vector2sb a) {
						return new Vector2nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ns(Vector2sb a) {
						return new Vector2ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2ni(Vector2sb a) {
						return new Vector2ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nus(Vector2sb a) {
						return new Vector2nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2nui(Vector2sb a) {
						return new Vector2nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y);
					}
					/// <summary>An explicit cast from <see cref="Vector2sb"/> to <see cref="Vector2h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector2h(Vector2sb a) {
						return new Vector2h((Float16)a.X, (Float16)a.Y);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector2sb operator +(Vector2sb a) { return new Vector2sb((SByte)(+a.X), (SByte)(+a.Y)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector2sb operator -(Vector2sb a) { return new Vector2sb((SByte)(-a.X), (SByte)(-a.Y)); }
								/// <summary>Add the vector.</summary>
					public static Vector2sb operator +(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X + b.X), (SByte)(a.Y + b.Y)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector2sb operator +(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X + b), (SByte)(a.Y + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector2sb operator +(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a + b.X), (SByte)(a + b.Y)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector2sb operator -(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X - b.X), (SByte)(a.Y - b.Y)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector2sb operator -(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X - b), (SByte)(a.Y - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector2sb operator -(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a - b.X), (SByte)(a - b.Y)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector2sb operator *(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X * b.X), (SByte)(a.Y * b.Y)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector2sb operator *(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X * b), (SByte)(a.Y * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector2sb operator *(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a * b.X), (SByte)(a * b.Y)); }
									/// <summary>Divide the vector.</summary>
					public static Vector2sb operator /(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X / b.X), (SByte)(a.Y / b.Y)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector2sb operator /(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X / b), (SByte)(a.Y / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector2sb operator /(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a / b.X), (SByte)(a / b.Y)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector2sb operator %(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X % b.X), (SByte)(a.Y % b.Y)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector2sb operator %(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X % b), (SByte)(a.Y % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector2sb operator %(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a % b.X), (SByte)(a % b.Y)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector2sb operator &(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X & b.X), (SByte)(a.Y & b.Y)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector2sb operator &(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X & b), (SByte)(a.Y & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector2sb operator &(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a & b.X), (SByte)(a & b.Y)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector2sb operator |(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X | b.X), (SByte)(a.Y | b.Y)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector2sb operator |(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X | b), (SByte)(a.Y | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector2sb operator |(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a | b.X), (SByte)(a | b.Y)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector2sb operator ^(Vector2sb a, Vector2sb b) { return new Vector2sb((SByte)(a.X ^ b.X), (SByte)(a.Y ^ b.Y)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector2sb operator ^(Vector2sb a, SByte b) { return new Vector2sb((SByte)(a.X ^ b), (SByte)(a.Y ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector2sb operator ^(SByte a, Vector2sb b) { return new Vector2sb((SByte)(a ^ b.X), (SByte)(a ^ b.Y)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector2sb operator <<(Vector2sb a, int b) { return new Vector2sb((SByte)(a.X << b), (SByte)(a.Y << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector2sb operator >>(Vector2sb a, int b) { return new Vector2sb((SByte)(a.X >> b), (SByte)(a.Y >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Length"/> elements.</summary>
	[VectorTypeAttribute(typeof(Length), 3, false)]
	public partial struct Vector3 : IEquatable<Vector3>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Area MagnitudeSquared { get { return (Area)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Length Magnitude {
				get {
					return Length.Universal(						Math.Sqrt(
															( X).InUniversal.Squared() 
							+								( Y).InUniversal.Squared() 
							+								( Z).InUniversal.Squared() 
													));
				}
			}

										
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Length Sum { get { return (Length)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
												/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
					public static Vector3 Centimetres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Centimetres(x) ,  Length.Centimetres(y) ,  Length.Centimetres(z) );
					}
				
					/// <summary>Initialize the vector from the Centimetres value.</summary>.
					public static Vector3 Centimetres(double value) {
						return new Vector3(Length.Centimetres(value));
					}

											/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
						public static Vector3 Centimetres( Vector3d value) {
							return new Vector3(								Length.Centimetres(value.X)
							, 								Length.Centimetres(value.Y)
							, 								Length.Centimetres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
						public static Vector3 Centimetres( ref  Vector3d value) {
							return new Vector3(								Length.Centimetres(value.X)
							, 								Length.Centimetres(value.Y)
							, 								Length.Centimetres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Centimetres unit.</summary>
					public Vector3d InCentimetres {
						get {
							return new Vector3d(								X.InCentimetres
							, 								Y.InCentimetres
							, 								Z.InCentimetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Feet units.</summary>.
					public static Vector3 Feet( double x ,  double y ,  double z ) {
						return new Vector3( Length.Feet(x) ,  Length.Feet(y) ,  Length.Feet(z) );
					}
				
					/// <summary>Initialize the vector from the Feet value.</summary>.
					public static Vector3 Feet(double value) {
						return new Vector3(Length.Feet(value));
					}

											/// <summary>Initialize the vector from values provided in Feet units.</summary>.
						public static Vector3 Feet( Vector3d value) {
							return new Vector3(								Length.Feet(value.X)
							, 								Length.Feet(value.Y)
							, 								Length.Feet(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Feet units.</summary>.
						public static Vector3 Feet( ref  Vector3d value) {
							return new Vector3(								Length.Feet(value.X)
							, 								Length.Feet(value.Y)
							, 								Length.Feet(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Feet unit.</summary>
					public Vector3d InFeet {
						get {
							return new Vector3d(								X.InFeet
							, 								Y.InFeet
							, 								Z.InFeet
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Inches units.</summary>.
					public static Vector3 Inches( double x ,  double y ,  double z ) {
						return new Vector3( Length.Inches(x) ,  Length.Inches(y) ,  Length.Inches(z) );
					}
				
					/// <summary>Initialize the vector from the Inches value.</summary>.
					public static Vector3 Inches(double value) {
						return new Vector3(Length.Inches(value));
					}

											/// <summary>Initialize the vector from values provided in Inches units.</summary>.
						public static Vector3 Inches( Vector3d value) {
							return new Vector3(								Length.Inches(value.X)
							, 								Length.Inches(value.Y)
							, 								Length.Inches(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Inches units.</summary>.
						public static Vector3 Inches( ref  Vector3d value) {
							return new Vector3(								Length.Inches(value.X)
							, 								Length.Inches(value.Y)
							, 								Length.Inches(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Inches unit.</summary>
					public Vector3d InInches {
						get {
							return new Vector3d(								X.InInches
							, 								Y.InInches
							, 								Z.InInches
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
					public static Vector3 Kilometres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Kilometres(x) ,  Length.Kilometres(y) ,  Length.Kilometres(z) );
					}
				
					/// <summary>Initialize the vector from the Kilometres value.</summary>.
					public static Vector3 Kilometres(double value) {
						return new Vector3(Length.Kilometres(value));
					}

											/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
						public static Vector3 Kilometres( Vector3d value) {
							return new Vector3(								Length.Kilometres(value.X)
							, 								Length.Kilometres(value.Y)
							, 								Length.Kilometres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
						public static Vector3 Kilometres( ref  Vector3d value) {
							return new Vector3(								Length.Kilometres(value.X)
							, 								Length.Kilometres(value.Y)
							, 								Length.Kilometres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Kilometres unit.</summary>
					public Vector3d InKilometres {
						get {
							return new Vector3d(								X.InKilometres
							, 								Y.InKilometres
							, 								Z.InKilometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
					public static Vector3 Megametres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Megametres(x) ,  Length.Megametres(y) ,  Length.Megametres(z) );
					}
				
					/// <summary>Initialize the vector from the Megametres value.</summary>.
					public static Vector3 Megametres(double value) {
						return new Vector3(Length.Megametres(value));
					}

											/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
						public static Vector3 Megametres( Vector3d value) {
							return new Vector3(								Length.Megametres(value.X)
							, 								Length.Megametres(value.Y)
							, 								Length.Megametres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
						public static Vector3 Megametres( ref  Vector3d value) {
							return new Vector3(								Length.Megametres(value.X)
							, 								Length.Megametres(value.Y)
							, 								Length.Megametres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Megametres unit.</summary>
					public Vector3d InMegametres {
						get {
							return new Vector3d(								X.InMegametres
							, 								Y.InMegametres
							, 								Z.InMegametres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Metres units.</summary>.
					public static Vector3 Metres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Metres(x) ,  Length.Metres(y) ,  Length.Metres(z) );
					}
				
					/// <summary>Initialize the vector from the Metres value.</summary>.
					public static Vector3 Metres(double value) {
						return new Vector3(Length.Metres(value));
					}

											/// <summary>Initialize the vector from values provided in Metres units.</summary>.
						public static Vector3 Metres( Vector3d value) {
							return new Vector3(								Length.Metres(value.X)
							, 								Length.Metres(value.Y)
							, 								Length.Metres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Metres units.</summary>.
						public static Vector3 Metres( ref  Vector3d value) {
							return new Vector3(								Length.Metres(value.X)
							, 								Length.Metres(value.Y)
							, 								Length.Metres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Metres unit.</summary>
					public Vector3d InMetres {
						get {
							return new Vector3d(								X.InMetres
							, 								Y.InMetres
							, 								Z.InMetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
					public static Vector3 Micrometres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Micrometres(x) ,  Length.Micrometres(y) ,  Length.Micrometres(z) );
					}
				
					/// <summary>Initialize the vector from the Micrometres value.</summary>.
					public static Vector3 Micrometres(double value) {
						return new Vector3(Length.Micrometres(value));
					}

											/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
						public static Vector3 Micrometres( Vector3d value) {
							return new Vector3(								Length.Micrometres(value.X)
							, 								Length.Micrometres(value.Y)
							, 								Length.Micrometres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
						public static Vector3 Micrometres( ref  Vector3d value) {
							return new Vector3(								Length.Micrometres(value.X)
							, 								Length.Micrometres(value.Y)
							, 								Length.Micrometres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Micrometres unit.</summary>
					public Vector3d InMicrometres {
						get {
							return new Vector3d(								X.InMicrometres
							, 								Y.InMicrometres
							, 								Z.InMicrometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
					public static Vector3 Millimetres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Millimetres(x) ,  Length.Millimetres(y) ,  Length.Millimetres(z) );
					}
				
					/// <summary>Initialize the vector from the Millimetres value.</summary>.
					public static Vector3 Millimetres(double value) {
						return new Vector3(Length.Millimetres(value));
					}

											/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
						public static Vector3 Millimetres( Vector3d value) {
							return new Vector3(								Length.Millimetres(value.X)
							, 								Length.Millimetres(value.Y)
							, 								Length.Millimetres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
						public static Vector3 Millimetres( ref  Vector3d value) {
							return new Vector3(								Length.Millimetres(value.X)
							, 								Length.Millimetres(value.Y)
							, 								Length.Millimetres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Millimetres unit.</summary>
					public Vector3d InMillimetres {
						get {
							return new Vector3d(								X.InMillimetres
							, 								Y.InMillimetres
							, 								Z.InMillimetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
					public static Vector3 Nanometres( double x ,  double y ,  double z ) {
						return new Vector3( Length.Nanometres(x) ,  Length.Nanometres(y) ,  Length.Nanometres(z) );
					}
				
					/// <summary>Initialize the vector from the Nanometres value.</summary>.
					public static Vector3 Nanometres(double value) {
						return new Vector3(Length.Nanometres(value));
					}

											/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
						public static Vector3 Nanometres( Vector3d value) {
							return new Vector3(								Length.Nanometres(value.X)
							, 								Length.Nanometres(value.Y)
							, 								Length.Nanometres(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
						public static Vector3 Nanometres( ref  Vector3d value) {
							return new Vector3(								Length.Nanometres(value.X)
							, 								Length.Nanometres(value.Y)
							, 								Length.Nanometres(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Nanometres unit.</summary>
					public Vector3d InNanometres {
						get {
							return new Vector3d(								X.InNanometres
							, 								Y.InNanometres
							, 								Z.InNanometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Yards units.</summary>.
					public static Vector3 Yards( double x ,  double y ,  double z ) {
						return new Vector3( Length.Yards(x) ,  Length.Yards(y) ,  Length.Yards(z) );
					}
				
					/// <summary>Initialize the vector from the Yards value.</summary>.
					public static Vector3 Yards(double value) {
						return new Vector3(Length.Yards(value));
					}

											/// <summary>Initialize the vector from values provided in Yards units.</summary>.
						public static Vector3 Yards( Vector3d value) {
							return new Vector3(								Length.Yards(value.X)
							, 								Length.Yards(value.Y)
							, 								Length.Yards(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Yards units.</summary>.
						public static Vector3 Yards( ref  Vector3d value) {
							return new Vector3(								Length.Yards(value.X)
							, 								Length.Yards(value.Y)
							, 								Length.Yards(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Yards unit.</summary>
					public Vector3d InYards {
						get {
							return new Vector3d(								X.InYards
							, 								Y.InYards
							, 								Z.InYards
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Universal units.</summary>.
					public static Vector3 Universal( double x ,  double y ,  double z ) {
						return new Vector3( Length.Universal(x) ,  Length.Universal(y) ,  Length.Universal(z) );
					}
				
					/// <summary>Initialize the vector from the Universal value.</summary>.
					public static Vector3 Universal(double value) {
						return new Vector3(Length.Universal(value));
					}

											/// <summary>Initialize the vector from values provided in Universal units.</summary>.
						public static Vector3 Universal( Vector3d value) {
							return new Vector3(								Length.Universal(value.X)
							, 								Length.Universal(value.Y)
							, 								Length.Universal(value.Z)
							);
						}
											/// <summary>Initialize the vector from values provided in Universal units.</summary>.
						public static Vector3 Universal( ref  Vector3d value) {
							return new Vector3(								Length.Universal(value.X)
							, 								Length.Universal(value.Y)
							, 								Length.Universal(value.Z)
							);
						}
									
					/// <summary>Convert into a vector in Universal unit.</summary>
					public Vector3d InUniversal {
						get {
							return new Vector3d(								X.InUniversal
							, 								Y.InUniversal
							, 								Z.InUniversal
							);
						}
					}
				
			
			

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3( Vector2 xy, Length z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3(Length x,  Vector2 y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3( ref  Vector2 xy, Length z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3(Length x,  ref  Vector2 y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Area Dot( Vector3 other) { return (Area)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Area Dot( ref  Vector3 other) { return (Area)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3 Clamp( Vector3 min,  Vector3 max ) {
					Vector3 result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3 min,  ref  Vector3 max , out Vector3 result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Length Distance( Vector3 other) {
					return Length.Universal(						Math.Sqrt(
															( X - other.X ).InUniversal.Squared() 
							+								( Y - other.Y ).InUniversal.Squared() 
							+								( Z - other.Z ).InUniversal.Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Area DistanceSquared( Vector3 other) {
					return (Area)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Length Distance( ref  Vector3 other) {
					return Length.Universal(						Math.Sqrt(
															( X - other.X ).InUniversal.Squared() 
							+								( Y - other.Y ).InUniversal.Squared() 
							+								( Z - other.Z ).InUniversal.Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Area DistanceSquared( ref  Vector3 other) {
					return (Area)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
										
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3"/>.</summary>
		public Length X;
			/// <summary>The second axis of the <see cref="Vector3"/>.</summary>
		public Length Y;
			/// <summary>The third axis of the <see cref="Vector3"/>.</summary>
		public Length Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3"/>.</summary>
	public static readonly Vector3 Zero = new Vector3(Length.Zero, Length.Zero, Length.Zero);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3"/> from the provided values for each factor.</summary>
	public Vector3(Length x, Length y, Length z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3"/> from a list.</summary>
	public Vector3(IList<Length> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3"/> from a single scalar that is applied to all factors.</summary>
	public Vector3(Length value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3"/> has equal factors as the other <see cref="Vector3"/>.</summary>
	public bool Equals(Vector3 other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3"/> of the same type, get whether this <see cref="Vector3"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3)
			return Equals((Vector3)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3"/> to a string of the form "Vector3(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3"/> to a string of the form "Vector3(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3"/> values are equal.</summary>
	public static bool operator ==(Vector3 a, Vector3 b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3"/> values are unequal.</summary>
	public static bool operator !=(Vector3 a, Vector3 b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
			
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3 operator +(Vector3 a) { return new Vector3((Length)(+a.X), (Length)(+a.Y), (Length)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3 operator -(Vector3 a) { return new Vector3((Length)(-a.X), (Length)(-a.Y), (Length)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3 operator +(Vector3 a, Vector3 b) { return new Vector3((Length)(a.X + b.X), (Length)(a.Y + b.Y), (Length)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3 operator +(Vector3 a, Length b) { return new Vector3((Length)(a.X + b), (Length)(a.Y + b), (Length)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3 operator +(Length a, Vector3 b) { return new Vector3((Length)(a + b.X), (Length)(a + b.Y), (Length)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3 operator -(Vector3 a, Vector3 b) { return new Vector3((Length)(a.X - b.X), (Length)(a.Y - b.Y), (Length)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3 operator -(Vector3 a, Length b) { return new Vector3((Length)(a.X - b), (Length)(a.Y - b), (Length)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3 operator -(Length a, Vector3 b) { return new Vector3((Length)(a - b.X), (Length)(a - b.Y), (Length)(a - b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Single"/> elements.</summary>
	[VectorTypeAttribute(typeof(Single), 3, false)]
	public partial struct Vector3f : IEquatable<Vector3f>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Single MagnitudeSquared { get { return (Single)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Single Magnitude {
				get {
					return (Single)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3f Normalized { get { Vector3f result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Single Product { get { return (Single)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Single Sum { get { return (Single)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3f One = new Vector3f((Single)1, (Single)1, (Single)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3f UnitX = new Vector3f((Single)1, (Single)0, (Single)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3f UnitY = new Vector3f((Single)0, (Single)1, (Single)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3f UnitZ = new Vector3f((Single)0, (Single)0, (Single)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3f( Vector2f xy, Single z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3f(Single x,  Vector2f y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3f( ref  Vector2f xy, Single z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3f(Single x,  ref  Vector2f y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Single Dot( Vector3f other) { return (Single)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Single Dot( ref  Vector3f other) { return (Single)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3f Clamp( Vector3f min,  Vector3f max ) {
					Vector3f result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3f min,  ref  Vector3f max , out Vector3f result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Single Distance( Vector3f other) {
					return (Single)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Single DistanceSquared( Vector3f other) {
					return (Single)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Single Distance( ref  Vector3f other) {
					return (Single)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Single DistanceSquared( ref  Vector3f other) {
					return (Single)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3f result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (Single)(X * m);  result.Y = (Single)(Y * m);  result.Z = (Single)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Single m = (Single)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3f Cross(Vector3f other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3f other, out Vector3f result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3f other, out Vector3f result) {
							Single x = (Single)(Y * other.Z - Z * other.Y), y = (Single)(Z * other.X - X * other.Z), z = (Single)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3f"/>.</summary>
		public Single X;
			/// <summary>The second axis of the <see cref="Vector3f"/>.</summary>
		public Single Y;
			/// <summary>The third axis of the <see cref="Vector3f"/>.</summary>
		public Single Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3f"/>.</summary>
	public static readonly Vector3f Zero = new Vector3f((Single)0, (Single)0, (Single)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3f"/> from the provided values for each factor.</summary>
	public Vector3f(Single x, Single y, Single z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3f"/> from a list.</summary>
	public Vector3f(IList<Single> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3f"/> from a single scalar that is applied to all factors.</summary>
	public Vector3f(Single value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3f"/> has equal factors as the other <see cref="Vector3f"/>.</summary>
	public bool Equals(Vector3f other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3f"/> of the same type, get whether this <see cref="Vector3f"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3f)
			return Equals((Vector3f)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3f"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3f"/> to a string of the form "Vector3f(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3f"/> to a string of the form "Vector3f(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3f(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3f"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3f"/> values are equal.</summary>
	public static bool operator ==(Vector3f a, Vector3f b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3f"/> values are unequal.</summary>
	public static bool operator !=(Vector3f a, Vector3f b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3f"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3f a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3f a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3f a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3f a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3f a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3f a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3f a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3f a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3f a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3f a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3f a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3f a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3f a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3f a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3f"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3f a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2f(Vector3f a) {
						return new Vector2f(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3f operator +(Vector3f a) { return new Vector3f((Single)(+a.X), (Single)(+a.Y), (Single)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3f operator -(Vector3f a) { return new Vector3f((Single)(-a.X), (Single)(-a.Y), (Single)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3f operator +(Vector3f a, Vector3f b) { return new Vector3f((Single)(a.X + b.X), (Single)(a.Y + b.Y), (Single)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3f operator +(Vector3f a, Single b) { return new Vector3f((Single)(a.X + b), (Single)(a.Y + b), (Single)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3f operator +(Single a, Vector3f b) { return new Vector3f((Single)(a + b.X), (Single)(a + b.Y), (Single)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3f operator -(Vector3f a, Vector3f b) { return new Vector3f((Single)(a.X - b.X), (Single)(a.Y - b.Y), (Single)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3f operator -(Vector3f a, Single b) { return new Vector3f((Single)(a.X - b), (Single)(a.Y - b), (Single)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3f operator -(Single a, Vector3f b) { return new Vector3f((Single)(a - b.X), (Single)(a - b.Y), (Single)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3f operator *(Vector3f a, Vector3f b) { return new Vector3f((Single)(a.X * b.X), (Single)(a.Y * b.Y), (Single)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3f operator *(Vector3f a, Single b) { return new Vector3f((Single)(a.X * b), (Single)(a.Y * b), (Single)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3f operator *(Single a, Vector3f b) { return new Vector3f((Single)(a * b.X), (Single)(a * b.Y), (Single)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3f operator /(Vector3f a, Vector3f b) { return new Vector3f((Single)(a.X / b.X), (Single)(a.Y / b.Y), (Single)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3f operator /(Vector3f a, Single b) { return new Vector3f((Single)(a.X / b), (Single)(a.Y / b), (Single)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3f operator /(Single a, Vector3f b) { return new Vector3f((Single)(a / b.X), (Single)(a / b.Y), (Single)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3f operator %(Vector3f a, Vector3f b) { return new Vector3f((Single)(a.X % b.X), (Single)(a.Y % b.Y), (Single)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3f operator %(Vector3f a, Single b) { return new Vector3f((Single)(a.X % b), (Single)(a.Y % b), (Single)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3f operator %(Single a, Vector3f b) { return new Vector3f((Single)(a % b.X), (Single)(a % b.Y), (Single)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Double"/> elements.</summary>
	[VectorTypeAttribute(typeof(Double), 3, false)]
	public partial struct Vector3d : IEquatable<Vector3d>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Double Magnitude {
				get {
					return (Double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3d Normalized { get { Vector3d result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Double Product { get { return (Double)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Double Sum { get { return (Double)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3d One = new Vector3d((Double)1, (Double)1, (Double)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3d UnitX = new Vector3d((Double)1, (Double)0, (Double)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3d UnitY = new Vector3d((Double)0, (Double)1, (Double)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3d UnitZ = new Vector3d((Double)0, (Double)0, (Double)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3d( Vector2d xy, Double z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3d(Double x,  Vector2d y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3d( ref  Vector2d xy, Double z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3d(Double x,  ref  Vector2d y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3d other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3d other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3d Clamp( Vector3d min,  Vector3d max ) {
					Vector3d result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3d min,  ref  Vector3d max , out Vector3d result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Double Distance( Vector3d other) {
					return (Double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3d other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Double Distance( ref  Vector3d other) {
					return (Double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3d other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3d result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (Double)(X * m);  result.Y = (Double)(Y * m);  result.Z = (Double)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Double m = (Double)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3d Cross(Vector3d other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3d other, out Vector3d result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3d other, out Vector3d result) {
							Double x = (Double)(Y * other.Z - Z * other.Y), y = (Double)(Z * other.X - X * other.Z), z = (Double)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3d"/>.</summary>
		public Double X;
			/// <summary>The second axis of the <see cref="Vector3d"/>.</summary>
		public Double Y;
			/// <summary>The third axis of the <see cref="Vector3d"/>.</summary>
		public Double Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3d"/>.</summary>
	public static readonly Vector3d Zero = new Vector3d((Double)0, (Double)0, (Double)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3d"/> from the provided values for each factor.</summary>
	public Vector3d(Double x, Double y, Double z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3d"/> from a list.</summary>
	public Vector3d(IList<Double> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3d"/> from a single scalar that is applied to all factors.</summary>
	public Vector3d(Double value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3d"/> has equal factors as the other <see cref="Vector3d"/>.</summary>
	public bool Equals(Vector3d other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3d"/> of the same type, get whether this <see cref="Vector3d"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3d)
			return Equals((Vector3d)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3d"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3d"/> to a string of the form "Vector3d(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3d"/> to a string of the form "Vector3d(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3d(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3d"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3d"/> values are equal.</summary>
	public static bool operator ==(Vector3d a, Vector3d b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3d"/> values are unequal.</summary>
	public static bool operator !=(Vector3d a, Vector3d b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3f(Vector3d a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3d a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3d a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3d a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3d a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3d a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3d a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3d a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3d a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3d a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3d a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3d a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3d a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3d a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3d"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3d a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2d(Vector3d a) {
						return new Vector2d(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3d operator +(Vector3d a) { return new Vector3d((Double)(+a.X), (Double)(+a.Y), (Double)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3d operator -(Vector3d a) { return new Vector3d((Double)(-a.X), (Double)(-a.Y), (Double)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3d operator +(Vector3d a, Vector3d b) { return new Vector3d((Double)(a.X + b.X), (Double)(a.Y + b.Y), (Double)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3d operator +(Vector3d a, Double b) { return new Vector3d((Double)(a.X + b), (Double)(a.Y + b), (Double)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3d operator +(Double a, Vector3d b) { return new Vector3d((Double)(a + b.X), (Double)(a + b.Y), (Double)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3d operator -(Vector3d a, Vector3d b) { return new Vector3d((Double)(a.X - b.X), (Double)(a.Y - b.Y), (Double)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3d operator -(Vector3d a, Double b) { return new Vector3d((Double)(a.X - b), (Double)(a.Y - b), (Double)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3d operator -(Double a, Vector3d b) { return new Vector3d((Double)(a - b.X), (Double)(a - b.Y), (Double)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3d operator *(Vector3d a, Vector3d b) { return new Vector3d((Double)(a.X * b.X), (Double)(a.Y * b.Y), (Double)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3d operator *(Vector3d a, Double b) { return new Vector3d((Double)(a.X * b), (Double)(a.Y * b), (Double)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3d operator *(Double a, Vector3d b) { return new Vector3d((Double)(a * b.X), (Double)(a * b.Y), (Double)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3d operator /(Vector3d a, Vector3d b) { return new Vector3d((Double)(a.X / b.X), (Double)(a.Y / b.Y), (Double)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3d operator /(Vector3d a, Double b) { return new Vector3d((Double)(a.X / b), (Double)(a.Y / b), (Double)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3d operator /(Double a, Vector3d b) { return new Vector3d((Double)(a / b.X), (Double)(a / b.Y), (Double)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3d operator %(Vector3d a, Vector3d b) { return new Vector3d((Double)(a.X % b.X), (Double)(a.Y % b.Y), (Double)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3d operator %(Vector3d a, Double b) { return new Vector3d((Double)(a.X % b), (Double)(a.Y % b), (Double)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3d operator %(Double a, Vector3d b) { return new Vector3d((Double)(a % b.X), (Double)(a % b.Y), (Double)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Int16"/> elements.</summary>
	[VectorTypeAttribute(typeof(Int16), 3, false)]
	public partial struct Vector3s : IEquatable<Vector3s>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Int16 MagnitudeSquared { get { return (Int16)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Int16 Product { get { return (Int16)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Int16 Sum { get { return (Int16)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3s One = new Vector3s((Int16)1, (Int16)1, (Int16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3s UnitX = new Vector3s((Int16)1, (Int16)0, (Int16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3s UnitY = new Vector3s((Int16)0, (Int16)1, (Int16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3s UnitZ = new Vector3s((Int16)0, (Int16)0, (Int16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3s( Vector2s xy, Int16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3s(Int16 x,  Vector2s y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3s( ref  Vector2s xy, Int16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3s(Int16 x,  ref  Vector2s y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Int16 Dot( Vector3s other) { return (Int16)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Int16 Dot( ref  Vector3s other) { return (Int16)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3s Clamp( Vector3s min,  Vector3s max ) {
					Vector3s result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3s min,  ref  Vector3s max , out Vector3s result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3s other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int16 DistanceSquared( Vector3s other) {
					return (Int16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3s other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int16 DistanceSquared( ref  Vector3s other) {
					return (Int16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3s"/>.</summary>
		public Int16 X;
			/// <summary>The second axis of the <see cref="Vector3s"/>.</summary>
		public Int16 Y;
			/// <summary>The third axis of the <see cref="Vector3s"/>.</summary>
		public Int16 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3s"/>.</summary>
	public static readonly Vector3s Zero = new Vector3s((Int16)0, (Int16)0, (Int16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3s"/> from the provided values for each factor.</summary>
	public Vector3s(Int16 x, Int16 y, Int16 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3s"/> from a list.</summary>
	public Vector3s(IList<Int16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3s"/> from a single scalar that is applied to all factors.</summary>
	public Vector3s(Int16 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3s"/> has equal factors as the other <see cref="Vector3s"/>.</summary>
	public bool Equals(Vector3s other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3s"/> of the same type, get whether this <see cref="Vector3s"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3s)
			return Equals((Vector3s)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3s"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3s"/> to a string of the form "Vector3s(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3s"/> to a string of the form "Vector3s(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3s(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3s"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3s"/> values are equal.</summary>
	public static bool operator ==(Vector3s a, Vector3s b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3s"/> values are unequal.</summary>
	public static bool operator !=(Vector3s a, Vector3s b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3s"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3s a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3s"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3s a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3s a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3s a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3s a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3s a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3s a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3s a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3s a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3s a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3s a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3s a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3s a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3s a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3s"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3s a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2s(Vector3s a) {
						return new Vector2s(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3s operator +(Vector3s a) { return new Vector3s((Int16)(+a.X), (Int16)(+a.Y), (Int16)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3s operator -(Vector3s a) { return new Vector3s((Int16)(-a.X), (Int16)(-a.Y), (Int16)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3s operator +(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X + b.X), (Int16)(a.Y + b.Y), (Int16)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3s operator +(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X + b), (Int16)(a.Y + b), (Int16)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3s operator +(Int16 a, Vector3s b) { return new Vector3s((Int16)(a + b.X), (Int16)(a + b.Y), (Int16)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3s operator -(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X - b.X), (Int16)(a.Y - b.Y), (Int16)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3s operator -(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X - b), (Int16)(a.Y - b), (Int16)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3s operator -(Int16 a, Vector3s b) { return new Vector3s((Int16)(a - b.X), (Int16)(a - b.Y), (Int16)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3s operator *(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X * b.X), (Int16)(a.Y * b.Y), (Int16)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3s operator *(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X * b), (Int16)(a.Y * b), (Int16)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3s operator *(Int16 a, Vector3s b) { return new Vector3s((Int16)(a * b.X), (Int16)(a * b.Y), (Int16)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3s operator /(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X / b.X), (Int16)(a.Y / b.Y), (Int16)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3s operator /(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X / b), (Int16)(a.Y / b), (Int16)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3s operator /(Int16 a, Vector3s b) { return new Vector3s((Int16)(a / b.X), (Int16)(a / b.Y), (Int16)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3s operator %(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X % b.X), (Int16)(a.Y % b.Y), (Int16)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3s operator %(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X % b), (Int16)(a.Y % b), (Int16)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3s operator %(Int16 a, Vector3s b) { return new Vector3s((Int16)(a % b.X), (Int16)(a % b.Y), (Int16)(a % b.Z)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector3s operator &(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X & b.X), (Int16)(a.Y & b.Y), (Int16)(a.Z & b.Z)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector3s operator &(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X & b), (Int16)(a.Y & b), (Int16)(a.Z & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector3s operator &(Int16 a, Vector3s b) { return new Vector3s((Int16)(a & b.X), (Int16)(a & b.Y), (Int16)(a & b.Z)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector3s operator |(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X | b.X), (Int16)(a.Y | b.Y), (Int16)(a.Z | b.Z)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector3s operator |(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X | b), (Int16)(a.Y | b), (Int16)(a.Z | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector3s operator |(Int16 a, Vector3s b) { return new Vector3s((Int16)(a | b.X), (Int16)(a | b.Y), (Int16)(a | b.Z)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector3s operator ^(Vector3s a, Vector3s b) { return new Vector3s((Int16)(a.X ^ b.X), (Int16)(a.Y ^ b.Y), (Int16)(a.Z ^ b.Z)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector3s operator ^(Vector3s a, Int16 b) { return new Vector3s((Int16)(a.X ^ b), (Int16)(a.Y ^ b), (Int16)(a.Z ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector3s operator ^(Int16 a, Vector3s b) { return new Vector3s((Int16)(a ^ b.X), (Int16)(a ^ b.Y), (Int16)(a ^ b.Z)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector3s operator <<(Vector3s a, int b) { return new Vector3s((Int16)(a.X << b), (Int16)(a.Y << b), (Int16)(a.Z << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector3s operator >>(Vector3s a, int b) { return new Vector3s((Int16)(a.X >> b), (Int16)(a.Y >> b), (Int16)(a.Z >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="UInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(UInt16), 3, false)]
	public partial struct Vector3us : IEquatable<Vector3us>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public UInt16 MagnitudeSquared { get { return (UInt16)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public UInt16 Product { get { return (UInt16)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public UInt16 Sum { get { return (UInt16)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3us One = new Vector3us((UInt16)1, (UInt16)1, (UInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3us UnitX = new Vector3us((UInt16)1, (UInt16)0, (UInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3us UnitY = new Vector3us((UInt16)0, (UInt16)1, (UInt16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3us UnitZ = new Vector3us((UInt16)0, (UInt16)0, (UInt16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3us( Vector2us xy, UInt16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3us(UInt16 x,  Vector2us y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3us( ref  Vector2us xy, UInt16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3us(UInt16 x,  ref  Vector2us y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public UInt16 Dot( Vector3us other) { return (UInt16)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public UInt16 Dot( ref  Vector3us other) { return (UInt16)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3us Clamp( Vector3us min,  Vector3us max ) {
					Vector3us result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3us min,  ref  Vector3us max , out Vector3us result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3us other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt16 DistanceSquared( Vector3us other) {
					return (UInt16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3us other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt16 DistanceSquared( ref  Vector3us other) {
					return (UInt16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3us"/>.</summary>
		public UInt16 X;
			/// <summary>The second axis of the <see cref="Vector3us"/>.</summary>
		public UInt16 Y;
			/// <summary>The third axis of the <see cref="Vector3us"/>.</summary>
		public UInt16 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3us"/>.</summary>
	public static readonly Vector3us Zero = new Vector3us((UInt16)0, (UInt16)0, (UInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3us"/> from the provided values for each factor.</summary>
	public Vector3us(UInt16 x, UInt16 y, UInt16 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3us"/> from a list.</summary>
	public Vector3us(IList<UInt16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3us"/> from a single scalar that is applied to all factors.</summary>
	public Vector3us(UInt16 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3us"/> has equal factors as the other <see cref="Vector3us"/>.</summary>
	public bool Equals(Vector3us other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3us"/> of the same type, get whether this <see cref="Vector3us"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3us)
			return Equals((Vector3us)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3us"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3us"/> to a string of the form "Vector3us(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3us"/> to a string of the form "Vector3us(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3us(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3us"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3us"/> values are equal.</summary>
	public static bool operator ==(Vector3us a, Vector3us b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3us"/> values are unequal.</summary>
	public static bool operator !=(Vector3us a, Vector3us b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3us"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3us a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3us"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3us a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3us a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3us a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3us a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3us a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3us a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3us a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3us a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3us a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3us a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3us a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3us a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3us a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3us"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3us a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2us(Vector3us a) {
						return new Vector2us(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3us operator +(Vector3us a) { return new Vector3us((UInt16)(+a.X), (UInt16)(+a.Y), (UInt16)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3us operator -(Vector3us a) { return new Vector3us((UInt16)(-a.X), (UInt16)(-a.Y), (UInt16)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3us operator +(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X + b.X), (UInt16)(a.Y + b.Y), (UInt16)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3us operator +(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X + b), (UInt16)(a.Y + b), (UInt16)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3us operator +(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a + b.X), (UInt16)(a + b.Y), (UInt16)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3us operator -(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X - b.X), (UInt16)(a.Y - b.Y), (UInt16)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3us operator -(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X - b), (UInt16)(a.Y - b), (UInt16)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3us operator -(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a - b.X), (UInt16)(a - b.Y), (UInt16)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3us operator *(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X * b.X), (UInt16)(a.Y * b.Y), (UInt16)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3us operator *(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X * b), (UInt16)(a.Y * b), (UInt16)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3us operator *(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a * b.X), (UInt16)(a * b.Y), (UInt16)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3us operator /(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X / b.X), (UInt16)(a.Y / b.Y), (UInt16)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3us operator /(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X / b), (UInt16)(a.Y / b), (UInt16)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3us operator /(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a / b.X), (UInt16)(a / b.Y), (UInt16)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3us operator %(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X % b.X), (UInt16)(a.Y % b.Y), (UInt16)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3us operator %(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X % b), (UInt16)(a.Y % b), (UInt16)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3us operator %(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a % b.X), (UInt16)(a % b.Y), (UInt16)(a % b.Z)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector3us operator &(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X & b.X), (UInt16)(a.Y & b.Y), (UInt16)(a.Z & b.Z)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector3us operator &(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X & b), (UInt16)(a.Y & b), (UInt16)(a.Z & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector3us operator &(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a & b.X), (UInt16)(a & b.Y), (UInt16)(a & b.Z)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector3us operator |(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X | b.X), (UInt16)(a.Y | b.Y), (UInt16)(a.Z | b.Z)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector3us operator |(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X | b), (UInt16)(a.Y | b), (UInt16)(a.Z | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector3us operator |(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a | b.X), (UInt16)(a | b.Y), (UInt16)(a | b.Z)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector3us operator ^(Vector3us a, Vector3us b) { return new Vector3us((UInt16)(a.X ^ b.X), (UInt16)(a.Y ^ b.Y), (UInt16)(a.Z ^ b.Z)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector3us operator ^(Vector3us a, UInt16 b) { return new Vector3us((UInt16)(a.X ^ b), (UInt16)(a.Y ^ b), (UInt16)(a.Z ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector3us operator ^(UInt16 a, Vector3us b) { return new Vector3us((UInt16)(a ^ b.X), (UInt16)(a ^ b.Y), (UInt16)(a ^ b.Z)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector3us operator <<(Vector3us a, int b) { return new Vector3us((UInt16)(a.X << b), (UInt16)(a.Y << b), (UInt16)(a.Z << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector3us operator >>(Vector3us a, int b) { return new Vector3us((UInt16)(a.X >> b), (UInt16)(a.Y >> b), (UInt16)(a.Z >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Int32"/> elements.</summary>
	[VectorTypeAttribute(typeof(Int32), 3, false)]
	public partial struct Vector3i : IEquatable<Vector3i>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Int32 MagnitudeSquared { get { return (Int32)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Int32 Product { get { return (Int32)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Int32 Sum { get { return (Int32)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3i One = new Vector3i((Int32)1, (Int32)1, (Int32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3i UnitX = new Vector3i((Int32)1, (Int32)0, (Int32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3i UnitY = new Vector3i((Int32)0, (Int32)1, (Int32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3i UnitZ = new Vector3i((Int32)0, (Int32)0, (Int32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3i( Vector2i xy, Int32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3i(Int32 x,  Vector2i y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3i( ref  Vector2i xy, Int32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3i(Int32 x,  ref  Vector2i y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Int32 Dot( Vector3i other) { return (Int32)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Int32 Dot( ref  Vector3i other) { return (Int32)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3i Clamp( Vector3i min,  Vector3i max ) {
					Vector3i result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3i min,  ref  Vector3i max , out Vector3i result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3i other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int32 DistanceSquared( Vector3i other) {
					return (Int32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3i other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int32 DistanceSquared( ref  Vector3i other) {
					return (Int32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3i"/>.</summary>
		public Int32 X;
			/// <summary>The second axis of the <see cref="Vector3i"/>.</summary>
		public Int32 Y;
			/// <summary>The third axis of the <see cref="Vector3i"/>.</summary>
		public Int32 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3i"/>.</summary>
	public static readonly Vector3i Zero = new Vector3i((Int32)0, (Int32)0, (Int32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3i"/> from the provided values for each factor.</summary>
	public Vector3i(Int32 x, Int32 y, Int32 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3i"/> from a list.</summary>
	public Vector3i(IList<Int32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3i"/> from a single scalar that is applied to all factors.</summary>
	public Vector3i(Int32 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3i"/> has equal factors as the other <see cref="Vector3i"/>.</summary>
	public bool Equals(Vector3i other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3i"/> of the same type, get whether this <see cref="Vector3i"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3i)
			return Equals((Vector3i)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3i"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3i"/> to a string of the form "Vector3i(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3i"/> to a string of the form "Vector3i(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3i(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3i"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3i"/> values are equal.</summary>
	public static bool operator ==(Vector3i a, Vector3i b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3i"/> values are unequal.</summary>
	public static bool operator !=(Vector3i a, Vector3i b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3i"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3i a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3i"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3i a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3i a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3i a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3i a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3i a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3i a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3i a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3i a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3i a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3i a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3i a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3i a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3i a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3i"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3i a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2i(Vector3i a) {
						return new Vector2i(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3i operator +(Vector3i a) { return new Vector3i((Int32)(+a.X), (Int32)(+a.Y), (Int32)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3i operator -(Vector3i a) { return new Vector3i((Int32)(-a.X), (Int32)(-a.Y), (Int32)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3i operator +(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X + b.X), (Int32)(a.Y + b.Y), (Int32)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3i operator +(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X + b), (Int32)(a.Y + b), (Int32)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3i operator +(Int32 a, Vector3i b) { return new Vector3i((Int32)(a + b.X), (Int32)(a + b.Y), (Int32)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3i operator -(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X - b.X), (Int32)(a.Y - b.Y), (Int32)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3i operator -(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X - b), (Int32)(a.Y - b), (Int32)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3i operator -(Int32 a, Vector3i b) { return new Vector3i((Int32)(a - b.X), (Int32)(a - b.Y), (Int32)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3i operator *(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X * b.X), (Int32)(a.Y * b.Y), (Int32)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3i operator *(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X * b), (Int32)(a.Y * b), (Int32)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3i operator *(Int32 a, Vector3i b) { return new Vector3i((Int32)(a * b.X), (Int32)(a * b.Y), (Int32)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3i operator /(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X / b.X), (Int32)(a.Y / b.Y), (Int32)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3i operator /(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X / b), (Int32)(a.Y / b), (Int32)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3i operator /(Int32 a, Vector3i b) { return new Vector3i((Int32)(a / b.X), (Int32)(a / b.Y), (Int32)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3i operator %(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X % b.X), (Int32)(a.Y % b.Y), (Int32)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3i operator %(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X % b), (Int32)(a.Y % b), (Int32)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3i operator %(Int32 a, Vector3i b) { return new Vector3i((Int32)(a % b.X), (Int32)(a % b.Y), (Int32)(a % b.Z)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector3i operator &(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X & b.X), (Int32)(a.Y & b.Y), (Int32)(a.Z & b.Z)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector3i operator &(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X & b), (Int32)(a.Y & b), (Int32)(a.Z & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector3i operator &(Int32 a, Vector3i b) { return new Vector3i((Int32)(a & b.X), (Int32)(a & b.Y), (Int32)(a & b.Z)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector3i operator |(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X | b.X), (Int32)(a.Y | b.Y), (Int32)(a.Z | b.Z)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector3i operator |(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X | b), (Int32)(a.Y | b), (Int32)(a.Z | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector3i operator |(Int32 a, Vector3i b) { return new Vector3i((Int32)(a | b.X), (Int32)(a | b.Y), (Int32)(a | b.Z)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector3i operator ^(Vector3i a, Vector3i b) { return new Vector3i((Int32)(a.X ^ b.X), (Int32)(a.Y ^ b.Y), (Int32)(a.Z ^ b.Z)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector3i operator ^(Vector3i a, Int32 b) { return new Vector3i((Int32)(a.X ^ b), (Int32)(a.Y ^ b), (Int32)(a.Z ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector3i operator ^(Int32 a, Vector3i b) { return new Vector3i((Int32)(a ^ b.X), (Int32)(a ^ b.Y), (Int32)(a ^ b.Z)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector3i operator <<(Vector3i a, int b) { return new Vector3i((Int32)(a.X << b), (Int32)(a.Y << b), (Int32)(a.Z << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector3i operator >>(Vector3i a, int b) { return new Vector3i((Int32)(a.X >> b), (Int32)(a.Y >> b), (Int32)(a.Z >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="UInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(UInt32), 3, false)]
	public partial struct Vector3ui : IEquatable<Vector3ui>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public UInt32 MagnitudeSquared { get { return (UInt32)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public UInt32 Product { get { return (UInt32)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public UInt32 Sum { get { return (UInt32)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3ui One = new Vector3ui((UInt32)1, (UInt32)1, (UInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3ui UnitX = new Vector3ui((UInt32)1, (UInt32)0, (UInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3ui UnitY = new Vector3ui((UInt32)0, (UInt32)1, (UInt32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3ui UnitZ = new Vector3ui((UInt32)0, (UInt32)0, (UInt32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3ui( Vector2ui xy, UInt32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3ui(UInt32 x,  Vector2ui y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3ui( ref  Vector2ui xy, UInt32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3ui(UInt32 x,  ref  Vector2ui y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public UInt32 Dot( Vector3ui other) { return (UInt32)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public UInt32 Dot( ref  Vector3ui other) { return (UInt32)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3ui Clamp( Vector3ui min,  Vector3ui max ) {
					Vector3ui result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3ui min,  ref  Vector3ui max , out Vector3ui result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3ui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt32 DistanceSquared( Vector3ui other) {
					return (UInt32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3ui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt32 DistanceSquared( ref  Vector3ui other) {
					return (UInt32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3ui"/>.</summary>
		public UInt32 X;
			/// <summary>The second axis of the <see cref="Vector3ui"/>.</summary>
		public UInt32 Y;
			/// <summary>The third axis of the <see cref="Vector3ui"/>.</summary>
		public UInt32 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3ui"/>.</summary>
	public static readonly Vector3ui Zero = new Vector3ui((UInt32)0, (UInt32)0, (UInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3ui"/> from the provided values for each factor.</summary>
	public Vector3ui(UInt32 x, UInt32 y, UInt32 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3ui"/> from a list.</summary>
	public Vector3ui(IList<UInt32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3ui"/> from a single scalar that is applied to all factors.</summary>
	public Vector3ui(UInt32 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3ui"/> has equal factors as the other <see cref="Vector3ui"/>.</summary>
	public bool Equals(Vector3ui other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3ui"/> of the same type, get whether this <see cref="Vector3ui"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3ui)
			return Equals((Vector3ui)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3ui"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3ui"/> to a string of the form "Vector3ui(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3ui"/> to a string of the form "Vector3ui(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3ui(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3ui"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3ui"/> values are equal.</summary>
	public static bool operator ==(Vector3ui a, Vector3ui b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3ui"/> values are unequal.</summary>
	public static bool operator !=(Vector3ui a, Vector3ui b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3ui"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3ui a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3ui"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3ui a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3ui a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3ui a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3ui a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3ui a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3ui a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3ui a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3ui a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3ui a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3ui a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3ui a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3ui a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3ui a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ui"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3ui a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2ui(Vector3ui a) {
						return new Vector2ui(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3ui operator +(Vector3ui a) { return new Vector3ui((UInt32)(+a.X), (UInt32)(+a.Y), (UInt32)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3ui operator -(Vector3ui a) { return new Vector3ui((UInt32)(-a.X), (UInt32)(-a.Y), (UInt32)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3ui operator +(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X + b.X), (UInt32)(a.Y + b.Y), (UInt32)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3ui operator +(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X + b), (UInt32)(a.Y + b), (UInt32)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3ui operator +(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a + b.X), (UInt32)(a + b.Y), (UInt32)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3ui operator -(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X - b.X), (UInt32)(a.Y - b.Y), (UInt32)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3ui operator -(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X - b), (UInt32)(a.Y - b), (UInt32)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3ui operator -(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a - b.X), (UInt32)(a - b.Y), (UInt32)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3ui operator *(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X * b.X), (UInt32)(a.Y * b.Y), (UInt32)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3ui operator *(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X * b), (UInt32)(a.Y * b), (UInt32)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3ui operator *(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a * b.X), (UInt32)(a * b.Y), (UInt32)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3ui operator /(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X / b.X), (UInt32)(a.Y / b.Y), (UInt32)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3ui operator /(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X / b), (UInt32)(a.Y / b), (UInt32)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3ui operator /(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a / b.X), (UInt32)(a / b.Y), (UInt32)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3ui operator %(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X % b.X), (UInt32)(a.Y % b.Y), (UInt32)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3ui operator %(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X % b), (UInt32)(a.Y % b), (UInt32)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3ui operator %(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a % b.X), (UInt32)(a % b.Y), (UInt32)(a % b.Z)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector3ui operator &(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X & b.X), (UInt32)(a.Y & b.Y), (UInt32)(a.Z & b.Z)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector3ui operator &(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X & b), (UInt32)(a.Y & b), (UInt32)(a.Z & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector3ui operator &(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a & b.X), (UInt32)(a & b.Y), (UInt32)(a & b.Z)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector3ui operator |(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X | b.X), (UInt32)(a.Y | b.Y), (UInt32)(a.Z | b.Z)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector3ui operator |(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X | b), (UInt32)(a.Y | b), (UInt32)(a.Z | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector3ui operator |(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a | b.X), (UInt32)(a | b.Y), (UInt32)(a | b.Z)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector3ui operator ^(Vector3ui a, Vector3ui b) { return new Vector3ui((UInt32)(a.X ^ b.X), (UInt32)(a.Y ^ b.Y), (UInt32)(a.Z ^ b.Z)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector3ui operator ^(Vector3ui a, UInt32 b) { return new Vector3ui((UInt32)(a.X ^ b), (UInt32)(a.Y ^ b), (UInt32)(a.Z ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector3ui operator ^(UInt32 a, Vector3ui b) { return new Vector3ui((UInt32)(a ^ b.X), (UInt32)(a ^ b.Y), (UInt32)(a ^ b.Z)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector3ui operator <<(Vector3ui a, int b) { return new Vector3ui((UInt32)(a.X << b), (UInt32)(a.Y << b), (UInt32)(a.Z << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector3ui operator >>(Vector3ui a, int b) { return new Vector3ui((UInt32)(a.X >> b), (UInt32)(a.Y >> b), (UInt32)(a.Z >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Byte"/> elements.</summary>
	[VectorTypeAttribute(typeof(Byte), 3, false)]
	public partial struct Vector3b : IEquatable<Vector3b>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public int MagnitudeSquared { get { return (int)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Byte Product { get { return (Byte)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Byte Sum { get { return (Byte)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3b One = new Vector3b((Byte)1, (Byte)1, (Byte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3b UnitX = new Vector3b((Byte)1, (Byte)0, (Byte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3b UnitY = new Vector3b((Byte)0, (Byte)1, (Byte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3b UnitZ = new Vector3b((Byte)0, (Byte)0, (Byte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3b( Vector2b xy, Byte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3b(Byte x,  Vector2b y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3b( ref  Vector2b xy, Byte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3b(Byte x,  ref  Vector2b y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public int Dot( Vector3b other) { return (int)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public int Dot( ref  Vector3b other) { return (int)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3b Clamp( Vector3b min,  Vector3b max ) {
					Vector3b result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3b min,  ref  Vector3b max , out Vector3b result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3b other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( Vector3b other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3b other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( ref  Vector3b other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3b"/>.</summary>
		public Byte X;
			/// <summary>The second axis of the <see cref="Vector3b"/>.</summary>
		public Byte Y;
			/// <summary>The third axis of the <see cref="Vector3b"/>.</summary>
		public Byte Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3b"/>.</summary>
	public static readonly Vector3b Zero = new Vector3b((Byte)0, (Byte)0, (Byte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3b"/> from the provided values for each factor.</summary>
	public Vector3b(Byte x, Byte y, Byte z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3b"/> from a list.</summary>
	public Vector3b(IList<Byte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3b"/> from a single scalar that is applied to all factors.</summary>
	public Vector3b(Byte value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3b"/> has equal factors as the other <see cref="Vector3b"/>.</summary>
	public bool Equals(Vector3b other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3b"/> of the same type, get whether this <see cref="Vector3b"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3b)
			return Equals((Vector3b)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3b"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3b"/> to a string of the form "Vector3b(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3b"/> to a string of the form "Vector3b(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3b(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3b"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3b"/> values are equal.</summary>
	public static bool operator ==(Vector3b a, Vector3b b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3b"/> values are unequal.</summary>
	public static bool operator !=(Vector3b a, Vector3b b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3b"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3b a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3b"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3b a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3b a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3b a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3b a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3b a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3b a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3b a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3b a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3b a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3b a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3b a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3b a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3b a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3b"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3b a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2b(Vector3b a) {
						return new Vector2b(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3b operator +(Vector3b a) { return new Vector3b((Byte)(+a.X), (Byte)(+a.Y), (Byte)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3b operator -(Vector3b a) { return new Vector3b((Byte)(-a.X), (Byte)(-a.Y), (Byte)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3b operator +(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X + b.X), (Byte)(a.Y + b.Y), (Byte)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3b operator +(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X + b), (Byte)(a.Y + b), (Byte)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3b operator +(Byte a, Vector3b b) { return new Vector3b((Byte)(a + b.X), (Byte)(a + b.Y), (Byte)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3b operator -(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X - b.X), (Byte)(a.Y - b.Y), (Byte)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3b operator -(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X - b), (Byte)(a.Y - b), (Byte)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3b operator -(Byte a, Vector3b b) { return new Vector3b((Byte)(a - b.X), (Byte)(a - b.Y), (Byte)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3b operator *(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X * b.X), (Byte)(a.Y * b.Y), (Byte)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3b operator *(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X * b), (Byte)(a.Y * b), (Byte)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3b operator *(Byte a, Vector3b b) { return new Vector3b((Byte)(a * b.X), (Byte)(a * b.Y), (Byte)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3b operator /(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X / b.X), (Byte)(a.Y / b.Y), (Byte)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3b operator /(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X / b), (Byte)(a.Y / b), (Byte)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3b operator /(Byte a, Vector3b b) { return new Vector3b((Byte)(a / b.X), (Byte)(a / b.Y), (Byte)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3b operator %(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X % b.X), (Byte)(a.Y % b.Y), (Byte)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3b operator %(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X % b), (Byte)(a.Y % b), (Byte)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3b operator %(Byte a, Vector3b b) { return new Vector3b((Byte)(a % b.X), (Byte)(a % b.Y), (Byte)(a % b.Z)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector3b operator &(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X & b.X), (Byte)(a.Y & b.Y), (Byte)(a.Z & b.Z)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector3b operator &(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X & b), (Byte)(a.Y & b), (Byte)(a.Z & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector3b operator &(Byte a, Vector3b b) { return new Vector3b((Byte)(a & b.X), (Byte)(a & b.Y), (Byte)(a & b.Z)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector3b operator |(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X | b.X), (Byte)(a.Y | b.Y), (Byte)(a.Z | b.Z)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector3b operator |(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X | b), (Byte)(a.Y | b), (Byte)(a.Z | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector3b operator |(Byte a, Vector3b b) { return new Vector3b((Byte)(a | b.X), (Byte)(a | b.Y), (Byte)(a | b.Z)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector3b operator ^(Vector3b a, Vector3b b) { return new Vector3b((Byte)(a.X ^ b.X), (Byte)(a.Y ^ b.Y), (Byte)(a.Z ^ b.Z)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector3b operator ^(Vector3b a, Byte b) { return new Vector3b((Byte)(a.X ^ b), (Byte)(a.Y ^ b), (Byte)(a.Z ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector3b operator ^(Byte a, Vector3b b) { return new Vector3b((Byte)(a ^ b.X), (Byte)(a ^ b.Y), (Byte)(a ^ b.Z)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector3b operator <<(Vector3b a, int b) { return new Vector3b((Byte)(a.X << b), (Byte)(a.Y << b), (Byte)(a.Z << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector3b operator >>(Vector3b a, int b) { return new Vector3b((Byte)(a.X >> b), (Byte)(a.Y >> b), (Byte)(a.Z >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedByte), 3, false)]
	public partial struct Vector3nb : IEquatable<Vector3nb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3nb Normalized { get { Vector3nb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedByte Product { get { return (NormalizedByte)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedByte Sum { get { return (NormalizedByte)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3nb(double x, double y, double z) : this((NormalizedByte)x, (NormalizedByte)y, (NormalizedByte)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nb( Vector3d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nb( ref  Vector3d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3nb One = new Vector3nb((NormalizedByte)1, (NormalizedByte)1, (NormalizedByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3nb UnitX = new Vector3nb((NormalizedByte)1, (NormalizedByte)0, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3nb UnitY = new Vector3nb((NormalizedByte)0, (NormalizedByte)1, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3nb UnitZ = new Vector3nb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3nb( Vector2nb xy, NormalizedByte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nb(NormalizedByte x,  Vector2nb y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3nb( ref  Vector2nb xy, NormalizedByte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nb(NormalizedByte x,  ref  Vector2nb y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3nb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3nb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3nb Clamp( Vector3nb min,  Vector3nb max ) {
					Vector3nb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3nb min,  ref  Vector3nb max , out Vector3nb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3nb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3nb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3nb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3nb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3nb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedByte)(X * m);  result.Y = (NormalizedByte)(Y * m);  result.Z = (NormalizedByte)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedByte m = (NormalizedByte)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3nb Cross(Vector3nb other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3nb other, out Vector3nb result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3nb other, out Vector3nb result) {
							NormalizedByte x = (NormalizedByte)(Y * other.Z - Z * other.Y), y = (NormalizedByte)(Z * other.X - X * other.Z), z = (NormalizedByte)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3nb"/>.</summary>
		public NormalizedByte X;
			/// <summary>The second axis of the <see cref="Vector3nb"/>.</summary>
		public NormalizedByte Y;
			/// <summary>The third axis of the <see cref="Vector3nb"/>.</summary>
		public NormalizedByte Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3nb"/>.</summary>
	public static readonly Vector3nb Zero = new Vector3nb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3nb"/> from the provided values for each factor.</summary>
	public Vector3nb(NormalizedByte x, NormalizedByte y, NormalizedByte z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3nb"/> from a list.</summary>
	public Vector3nb(IList<NormalizedByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3nb"/> from a single scalar that is applied to all factors.</summary>
	public Vector3nb(NormalizedByte value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3nb"/> has equal factors as the other <see cref="Vector3nb"/>.</summary>
	public bool Equals(Vector3nb other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3nb"/> of the same type, get whether this <see cref="Vector3nb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3nb)
			return Equals((Vector3nb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3nb"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3nb"/> to a string of the form "Vector3nb(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3nb"/> to a string of the form "Vector3nb(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3nb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3nb"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3nb"/> values are equal.</summary>
	public static bool operator ==(Vector3nb a, Vector3nb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3nb"/> values are unequal.</summary>
	public static bool operator !=(Vector3nb a, Vector3nb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3nb"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3nb a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3nb"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3nb a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3nb a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3nb a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3nb a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3nb a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3nb a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3nb a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3nb a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3nb a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3nb a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3nb a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3nb a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3nb a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nb"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3nb a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nb(Vector3nb a) {
						return new Vector2nb(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3nb operator +(Vector3nb a) { return new Vector3nb((NormalizedByte)(+a.X), (NormalizedByte)(+a.Y), (NormalizedByte)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3nb operator -(Vector3nb a) { return new Vector3nb((NormalizedByte)(-a.X), (NormalizedByte)(-a.Y), (NormalizedByte)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3nb operator +(Vector3nb a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a.X + b.X), (NormalizedByte)(a.Y + b.Y), (NormalizedByte)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3nb operator +(Vector3nb a, NormalizedByte b) { return new Vector3nb((NormalizedByte)(a.X + b), (NormalizedByte)(a.Y + b), (NormalizedByte)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3nb operator +(NormalizedByte a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a + b.X), (NormalizedByte)(a + b.Y), (NormalizedByte)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3nb operator -(Vector3nb a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a.X - b.X), (NormalizedByte)(a.Y - b.Y), (NormalizedByte)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3nb operator -(Vector3nb a, NormalizedByte b) { return new Vector3nb((NormalizedByte)(a.X - b), (NormalizedByte)(a.Y - b), (NormalizedByte)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3nb operator -(NormalizedByte a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a - b.X), (NormalizedByte)(a - b.Y), (NormalizedByte)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3nb operator *(Vector3nb a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a.X * b.X), (NormalizedByte)(a.Y * b.Y), (NormalizedByte)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3nb operator *(Vector3nb a, NormalizedByte b) { return new Vector3nb((NormalizedByte)(a.X * b), (NormalizedByte)(a.Y * b), (NormalizedByte)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3nb operator *(NormalizedByte a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a * b.X), (NormalizedByte)(a * b.Y), (NormalizedByte)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3nb operator /(Vector3nb a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a.X / b.X), (NormalizedByte)(a.Y / b.Y), (NormalizedByte)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3nb operator /(Vector3nb a, NormalizedByte b) { return new Vector3nb((NormalizedByte)(a.X / b), (NormalizedByte)(a.Y / b), (NormalizedByte)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3nb operator /(NormalizedByte a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a / b.X), (NormalizedByte)(a / b.Y), (NormalizedByte)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3nb operator %(Vector3nb a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a.X % b.X), (NormalizedByte)(a.Y % b.Y), (NormalizedByte)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3nb operator %(Vector3nb a, NormalizedByte b) { return new Vector3nb((NormalizedByte)(a.X % b), (NormalizedByte)(a.Y % b), (NormalizedByte)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3nb operator %(NormalizedByte a, Vector3nb b) { return new Vector3nb((NormalizedByte)(a % b.X), (NormalizedByte)(a % b.Y), (NormalizedByte)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedSByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedSByte), 3, false)]
	public partial struct Vector3nsb : IEquatable<Vector3nsb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3nsb Normalized { get { Vector3nsb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedSByte Product { get { return (NormalizedSByte)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedSByte Sum { get { return (NormalizedSByte)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3nsb(double x, double y, double z) : this((NormalizedSByte)x, (NormalizedSByte)y, (NormalizedSByte)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nsb( Vector3d value) : this((NormalizedSByte)value.X, (NormalizedSByte)value.Y, (NormalizedSByte)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nsb( ref  Vector3d value) : this((NormalizedSByte)value.X, (NormalizedSByte)value.Y, (NormalizedSByte)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3nsb One = new Vector3nsb((NormalizedSByte)1, (NormalizedSByte)1, (NormalizedSByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3nsb UnitX = new Vector3nsb((NormalizedSByte)1, (NormalizedSByte)0, (NormalizedSByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3nsb UnitY = new Vector3nsb((NormalizedSByte)0, (NormalizedSByte)1, (NormalizedSByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3nsb UnitZ = new Vector3nsb((NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3nsb( Vector2nsb xy, NormalizedSByte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nsb(NormalizedSByte x,  Vector2nsb y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3nsb( ref  Vector2nsb xy, NormalizedSByte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nsb(NormalizedSByte x,  ref  Vector2nsb y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3nsb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3nsb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3nsb Clamp( Vector3nsb min,  Vector3nsb max ) {
					Vector3nsb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3nsb min,  ref  Vector3nsb max , out Vector3nsb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3nsb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3nsb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3nsb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3nsb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3nsb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedSByte)(X * m);  result.Y = (NormalizedSByte)(Y * m);  result.Z = (NormalizedSByte)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedSByte m = (NormalizedSByte)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3nsb Cross(Vector3nsb other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3nsb other, out Vector3nsb result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3nsb other, out Vector3nsb result) {
							NormalizedSByte x = (NormalizedSByte)(Y * other.Z - Z * other.Y), y = (NormalizedSByte)(Z * other.X - X * other.Z), z = (NormalizedSByte)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3nsb"/>.</summary>
		public NormalizedSByte X;
			/// <summary>The second axis of the <see cref="Vector3nsb"/>.</summary>
		public NormalizedSByte Y;
			/// <summary>The third axis of the <see cref="Vector3nsb"/>.</summary>
		public NormalizedSByte Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3nsb"/>.</summary>
	public static readonly Vector3nsb Zero = new Vector3nsb((NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3nsb"/> from the provided values for each factor.</summary>
	public Vector3nsb(NormalizedSByte x, NormalizedSByte y, NormalizedSByte z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3nsb"/> from a list.</summary>
	public Vector3nsb(IList<NormalizedSByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3nsb"/> from a single scalar that is applied to all factors.</summary>
	public Vector3nsb(NormalizedSByte value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3nsb"/> has equal factors as the other <see cref="Vector3nsb"/>.</summary>
	public bool Equals(Vector3nsb other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3nsb"/> of the same type, get whether this <see cref="Vector3nsb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3nsb)
			return Equals((Vector3nsb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3nsb"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3nsb"/> to a string of the form "Vector3nsb(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3nsb"/> to a string of the form "Vector3nsb(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3nsb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3nsb"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3nsb"/> values are equal.</summary>
	public static bool operator ==(Vector3nsb a, Vector3nsb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3nsb"/> values are unequal.</summary>
	public static bool operator !=(Vector3nsb a, Vector3nsb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3nsb a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3nsb a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3nsb a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3nsb a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3nsb a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3nsb a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3nsb a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3nsb a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3nsb a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3nsb a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3nsb a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3nsb a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3nsb a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3nsb a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nsb"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3nsb a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nsb(Vector3nsb a) {
						return new Vector2nsb(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3nsb operator +(Vector3nsb a) { return new Vector3nsb((NormalizedSByte)(+a.X), (NormalizedSByte)(+a.Y), (NormalizedSByte)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3nsb operator -(Vector3nsb a) { return new Vector3nsb((NormalizedSByte)(-a.X), (NormalizedSByte)(-a.Y), (NormalizedSByte)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3nsb operator +(Vector3nsb a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a.X + b.X), (NormalizedSByte)(a.Y + b.Y), (NormalizedSByte)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3nsb operator +(Vector3nsb a, NormalizedSByte b) { return new Vector3nsb((NormalizedSByte)(a.X + b), (NormalizedSByte)(a.Y + b), (NormalizedSByte)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3nsb operator +(NormalizedSByte a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a + b.X), (NormalizedSByte)(a + b.Y), (NormalizedSByte)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3nsb operator -(Vector3nsb a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a.X - b.X), (NormalizedSByte)(a.Y - b.Y), (NormalizedSByte)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3nsb operator -(Vector3nsb a, NormalizedSByte b) { return new Vector3nsb((NormalizedSByte)(a.X - b), (NormalizedSByte)(a.Y - b), (NormalizedSByte)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3nsb operator -(NormalizedSByte a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a - b.X), (NormalizedSByte)(a - b.Y), (NormalizedSByte)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3nsb operator *(Vector3nsb a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a.X * b.X), (NormalizedSByte)(a.Y * b.Y), (NormalizedSByte)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3nsb operator *(Vector3nsb a, NormalizedSByte b) { return new Vector3nsb((NormalizedSByte)(a.X * b), (NormalizedSByte)(a.Y * b), (NormalizedSByte)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3nsb operator *(NormalizedSByte a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a * b.X), (NormalizedSByte)(a * b.Y), (NormalizedSByte)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3nsb operator /(Vector3nsb a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a.X / b.X), (NormalizedSByte)(a.Y / b.Y), (NormalizedSByte)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3nsb operator /(Vector3nsb a, NormalizedSByte b) { return new Vector3nsb((NormalizedSByte)(a.X / b), (NormalizedSByte)(a.Y / b), (NormalizedSByte)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3nsb operator /(NormalizedSByte a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a / b.X), (NormalizedSByte)(a / b.Y), (NormalizedSByte)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3nsb operator %(Vector3nsb a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a.X % b.X), (NormalizedSByte)(a.Y % b.Y), (NormalizedSByte)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3nsb operator %(Vector3nsb a, NormalizedSByte b) { return new Vector3nsb((NormalizedSByte)(a.X % b), (NormalizedSByte)(a.Y % b), (NormalizedSByte)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3nsb operator %(NormalizedSByte a, Vector3nsb b) { return new Vector3nsb((NormalizedSByte)(a % b.X), (NormalizedSByte)(a % b.Y), (NormalizedSByte)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedInt16), 3, false)]
	public partial struct Vector3ns : IEquatable<Vector3ns>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3ns Normalized { get { Vector3ns result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedInt16 Product { get { return (NormalizedInt16)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedInt16 Sum { get { return (NormalizedInt16)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3ns(double x, double y, double z) : this((NormalizedInt16)x, (NormalizedInt16)y, (NormalizedInt16)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3ns( Vector3d value) : this((NormalizedInt16)value.X, (NormalizedInt16)value.Y, (NormalizedInt16)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3ns( ref  Vector3d value) : this((NormalizedInt16)value.X, (NormalizedInt16)value.Y, (NormalizedInt16)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3ns One = new Vector3ns((NormalizedInt16)1, (NormalizedInt16)1, (NormalizedInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3ns UnitX = new Vector3ns((NormalizedInt16)1, (NormalizedInt16)0, (NormalizedInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3ns UnitY = new Vector3ns((NormalizedInt16)0, (NormalizedInt16)1, (NormalizedInt16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3ns UnitZ = new Vector3ns((NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3ns( Vector2ns xy, NormalizedInt16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3ns(NormalizedInt16 x,  Vector2ns y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3ns( ref  Vector2ns xy, NormalizedInt16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3ns(NormalizedInt16 x,  ref  Vector2ns y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3ns other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3ns other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3ns Clamp( Vector3ns min,  Vector3ns max ) {
					Vector3ns result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3ns min,  ref  Vector3ns max , out Vector3ns result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3ns other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3ns other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3ns other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3ns other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3ns result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedInt16)(X * m);  result.Y = (NormalizedInt16)(Y * m);  result.Z = (NormalizedInt16)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedInt16 m = (NormalizedInt16)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3ns Cross(Vector3ns other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3ns other, out Vector3ns result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3ns other, out Vector3ns result) {
							NormalizedInt16 x = (NormalizedInt16)(Y * other.Z - Z * other.Y), y = (NormalizedInt16)(Z * other.X - X * other.Z), z = (NormalizedInt16)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3ns"/>.</summary>
		public NormalizedInt16 X;
			/// <summary>The second axis of the <see cref="Vector3ns"/>.</summary>
		public NormalizedInt16 Y;
			/// <summary>The third axis of the <see cref="Vector3ns"/>.</summary>
		public NormalizedInt16 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3ns"/>.</summary>
	public static readonly Vector3ns Zero = new Vector3ns((NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3ns"/> from the provided values for each factor.</summary>
	public Vector3ns(NormalizedInt16 x, NormalizedInt16 y, NormalizedInt16 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3ns"/> from a list.</summary>
	public Vector3ns(IList<NormalizedInt16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3ns"/> from a single scalar that is applied to all factors.</summary>
	public Vector3ns(NormalizedInt16 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3ns"/> has equal factors as the other <see cref="Vector3ns"/>.</summary>
	public bool Equals(Vector3ns other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3ns"/> of the same type, get whether this <see cref="Vector3ns"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3ns)
			return Equals((Vector3ns)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3ns"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3ns"/> to a string of the form "Vector3ns(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3ns"/> to a string of the form "Vector3ns(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3ns(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3ns"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3ns"/> values are equal.</summary>
	public static bool operator ==(Vector3ns a, Vector3ns b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3ns"/> values are unequal.</summary>
	public static bool operator !=(Vector3ns a, Vector3ns b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3ns"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3ns a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3ns"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3ns a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3ns a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3ns a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3ns a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3ns a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3ns a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3ns a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3ns a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3ns a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3ns a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3ns a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3ns a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3ns a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ns"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3ns a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2ns(Vector3ns a) {
						return new Vector2ns(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3ns operator +(Vector3ns a) { return new Vector3ns((NormalizedInt16)(+a.X), (NormalizedInt16)(+a.Y), (NormalizedInt16)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3ns operator -(Vector3ns a) { return new Vector3ns((NormalizedInt16)(-a.X), (NormalizedInt16)(-a.Y), (NormalizedInt16)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3ns operator +(Vector3ns a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a.X + b.X), (NormalizedInt16)(a.Y + b.Y), (NormalizedInt16)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3ns operator +(Vector3ns a, NormalizedInt16 b) { return new Vector3ns((NormalizedInt16)(a.X + b), (NormalizedInt16)(a.Y + b), (NormalizedInt16)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3ns operator +(NormalizedInt16 a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a + b.X), (NormalizedInt16)(a + b.Y), (NormalizedInt16)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3ns operator -(Vector3ns a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a.X - b.X), (NormalizedInt16)(a.Y - b.Y), (NormalizedInt16)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3ns operator -(Vector3ns a, NormalizedInt16 b) { return new Vector3ns((NormalizedInt16)(a.X - b), (NormalizedInt16)(a.Y - b), (NormalizedInt16)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3ns operator -(NormalizedInt16 a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a - b.X), (NormalizedInt16)(a - b.Y), (NormalizedInt16)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3ns operator *(Vector3ns a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a.X * b.X), (NormalizedInt16)(a.Y * b.Y), (NormalizedInt16)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3ns operator *(Vector3ns a, NormalizedInt16 b) { return new Vector3ns((NormalizedInt16)(a.X * b), (NormalizedInt16)(a.Y * b), (NormalizedInt16)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3ns operator *(NormalizedInt16 a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a * b.X), (NormalizedInt16)(a * b.Y), (NormalizedInt16)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3ns operator /(Vector3ns a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a.X / b.X), (NormalizedInt16)(a.Y / b.Y), (NormalizedInt16)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3ns operator /(Vector3ns a, NormalizedInt16 b) { return new Vector3ns((NormalizedInt16)(a.X / b), (NormalizedInt16)(a.Y / b), (NormalizedInt16)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3ns operator /(NormalizedInt16 a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a / b.X), (NormalizedInt16)(a / b.Y), (NormalizedInt16)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3ns operator %(Vector3ns a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a.X % b.X), (NormalizedInt16)(a.Y % b.Y), (NormalizedInt16)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3ns operator %(Vector3ns a, NormalizedInt16 b) { return new Vector3ns((NormalizedInt16)(a.X % b), (NormalizedInt16)(a.Y % b), (NormalizedInt16)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3ns operator %(NormalizedInt16 a, Vector3ns b) { return new Vector3ns((NormalizedInt16)(a % b.X), (NormalizedInt16)(a % b.Y), (NormalizedInt16)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedInt32), 3, false)]
	public partial struct Vector3ni : IEquatable<Vector3ni>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3ni Normalized { get { Vector3ni result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedInt32 Product { get { return (NormalizedInt32)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedInt32 Sum { get { return (NormalizedInt32)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3ni(double x, double y, double z) : this((NormalizedInt32)x, (NormalizedInt32)y, (NormalizedInt32)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3ni( Vector3d value) : this((NormalizedInt32)value.X, (NormalizedInt32)value.Y, (NormalizedInt32)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3ni( ref  Vector3d value) : this((NormalizedInt32)value.X, (NormalizedInt32)value.Y, (NormalizedInt32)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3ni One = new Vector3ni((NormalizedInt32)1, (NormalizedInt32)1, (NormalizedInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3ni UnitX = new Vector3ni((NormalizedInt32)1, (NormalizedInt32)0, (NormalizedInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3ni UnitY = new Vector3ni((NormalizedInt32)0, (NormalizedInt32)1, (NormalizedInt32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3ni UnitZ = new Vector3ni((NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3ni( Vector2ni xy, NormalizedInt32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3ni(NormalizedInt32 x,  Vector2ni y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3ni( ref  Vector2ni xy, NormalizedInt32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3ni(NormalizedInt32 x,  ref  Vector2ni y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3ni other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3ni other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3ni Clamp( Vector3ni min,  Vector3ni max ) {
					Vector3ni result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3ni min,  ref  Vector3ni max , out Vector3ni result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3ni other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3ni other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3ni other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3ni other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3ni result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedInt32)(X * m);  result.Y = (NormalizedInt32)(Y * m);  result.Z = (NormalizedInt32)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedInt32 m = (NormalizedInt32)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3ni Cross(Vector3ni other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3ni other, out Vector3ni result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3ni other, out Vector3ni result) {
							NormalizedInt32 x = (NormalizedInt32)(Y * other.Z - Z * other.Y), y = (NormalizedInt32)(Z * other.X - X * other.Z), z = (NormalizedInt32)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3ni"/>.</summary>
		public NormalizedInt32 X;
			/// <summary>The second axis of the <see cref="Vector3ni"/>.</summary>
		public NormalizedInt32 Y;
			/// <summary>The third axis of the <see cref="Vector3ni"/>.</summary>
		public NormalizedInt32 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3ni"/>.</summary>
	public static readonly Vector3ni Zero = new Vector3ni((NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3ni"/> from the provided values for each factor.</summary>
	public Vector3ni(NormalizedInt32 x, NormalizedInt32 y, NormalizedInt32 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3ni"/> from a list.</summary>
	public Vector3ni(IList<NormalizedInt32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3ni"/> from a single scalar that is applied to all factors.</summary>
	public Vector3ni(NormalizedInt32 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3ni"/> has equal factors as the other <see cref="Vector3ni"/>.</summary>
	public bool Equals(Vector3ni other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3ni"/> of the same type, get whether this <see cref="Vector3ni"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3ni)
			return Equals((Vector3ni)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3ni"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3ni"/> to a string of the form "Vector3ni(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3ni"/> to a string of the form "Vector3ni(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3ni(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3ni"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3ni"/> values are equal.</summary>
	public static bool operator ==(Vector3ni a, Vector3ni b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3ni"/> values are unequal.</summary>
	public static bool operator !=(Vector3ni a, Vector3ni b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3ni"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3ni a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3ni"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3ni a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3ni a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3ni a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3ni a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3ni a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3ni a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3ni a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3ni a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3ni a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3ni a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3ni a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3ni a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3ni a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3ni"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3ni a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2ni(Vector3ni a) {
						return new Vector2ni(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3ni operator +(Vector3ni a) { return new Vector3ni((NormalizedInt32)(+a.X), (NormalizedInt32)(+a.Y), (NormalizedInt32)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3ni operator -(Vector3ni a) { return new Vector3ni((NormalizedInt32)(-a.X), (NormalizedInt32)(-a.Y), (NormalizedInt32)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3ni operator +(Vector3ni a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a.X + b.X), (NormalizedInt32)(a.Y + b.Y), (NormalizedInt32)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3ni operator +(Vector3ni a, NormalizedInt32 b) { return new Vector3ni((NormalizedInt32)(a.X + b), (NormalizedInt32)(a.Y + b), (NormalizedInt32)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3ni operator +(NormalizedInt32 a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a + b.X), (NormalizedInt32)(a + b.Y), (NormalizedInt32)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3ni operator -(Vector3ni a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a.X - b.X), (NormalizedInt32)(a.Y - b.Y), (NormalizedInt32)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3ni operator -(Vector3ni a, NormalizedInt32 b) { return new Vector3ni((NormalizedInt32)(a.X - b), (NormalizedInt32)(a.Y - b), (NormalizedInt32)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3ni operator -(NormalizedInt32 a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a - b.X), (NormalizedInt32)(a - b.Y), (NormalizedInt32)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3ni operator *(Vector3ni a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a.X * b.X), (NormalizedInt32)(a.Y * b.Y), (NormalizedInt32)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3ni operator *(Vector3ni a, NormalizedInt32 b) { return new Vector3ni((NormalizedInt32)(a.X * b), (NormalizedInt32)(a.Y * b), (NormalizedInt32)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3ni operator *(NormalizedInt32 a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a * b.X), (NormalizedInt32)(a * b.Y), (NormalizedInt32)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3ni operator /(Vector3ni a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a.X / b.X), (NormalizedInt32)(a.Y / b.Y), (NormalizedInt32)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3ni operator /(Vector3ni a, NormalizedInt32 b) { return new Vector3ni((NormalizedInt32)(a.X / b), (NormalizedInt32)(a.Y / b), (NormalizedInt32)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3ni operator /(NormalizedInt32 a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a / b.X), (NormalizedInt32)(a / b.Y), (NormalizedInt32)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3ni operator %(Vector3ni a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a.X % b.X), (NormalizedInt32)(a.Y % b.Y), (NormalizedInt32)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3ni operator %(Vector3ni a, NormalizedInt32 b) { return new Vector3ni((NormalizedInt32)(a.X % b), (NormalizedInt32)(a.Y % b), (NormalizedInt32)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3ni operator %(NormalizedInt32 a, Vector3ni b) { return new Vector3ni((NormalizedInt32)(a % b.X), (NormalizedInt32)(a % b.Y), (NormalizedInt32)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedUInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedUInt16), 3, false)]
	public partial struct Vector3nus : IEquatable<Vector3nus>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3nus Normalized { get { Vector3nus result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedUInt16 Product { get { return (NormalizedUInt16)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedUInt16 Sum { get { return (NormalizedUInt16)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3nus(double x, double y, double z) : this((NormalizedUInt16)x, (NormalizedUInt16)y, (NormalizedUInt16)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nus( Vector3d value) : this((NormalizedUInt16)value.X, (NormalizedUInt16)value.Y, (NormalizedUInt16)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nus( ref  Vector3d value) : this((NormalizedUInt16)value.X, (NormalizedUInt16)value.Y, (NormalizedUInt16)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3nus One = new Vector3nus((NormalizedUInt16)1, (NormalizedUInt16)1, (NormalizedUInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3nus UnitX = new Vector3nus((NormalizedUInt16)1, (NormalizedUInt16)0, (NormalizedUInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3nus UnitY = new Vector3nus((NormalizedUInt16)0, (NormalizedUInt16)1, (NormalizedUInt16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3nus UnitZ = new Vector3nus((NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3nus( Vector2nus xy, NormalizedUInt16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nus(NormalizedUInt16 x,  Vector2nus y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3nus( ref  Vector2nus xy, NormalizedUInt16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nus(NormalizedUInt16 x,  ref  Vector2nus y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3nus other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3nus other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3nus Clamp( Vector3nus min,  Vector3nus max ) {
					Vector3nus result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3nus min,  ref  Vector3nus max , out Vector3nus result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3nus other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3nus other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3nus other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3nus other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3nus result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedUInt16)(X * m);  result.Y = (NormalizedUInt16)(Y * m);  result.Z = (NormalizedUInt16)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedUInt16 m = (NormalizedUInt16)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3nus Cross(Vector3nus other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3nus other, out Vector3nus result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3nus other, out Vector3nus result) {
							NormalizedUInt16 x = (NormalizedUInt16)(Y * other.Z - Z * other.Y), y = (NormalizedUInt16)(Z * other.X - X * other.Z), z = (NormalizedUInt16)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3nus"/>.</summary>
		public NormalizedUInt16 X;
			/// <summary>The second axis of the <see cref="Vector3nus"/>.</summary>
		public NormalizedUInt16 Y;
			/// <summary>The third axis of the <see cref="Vector3nus"/>.</summary>
		public NormalizedUInt16 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3nus"/>.</summary>
	public static readonly Vector3nus Zero = new Vector3nus((NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3nus"/> from the provided values for each factor.</summary>
	public Vector3nus(NormalizedUInt16 x, NormalizedUInt16 y, NormalizedUInt16 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3nus"/> from a list.</summary>
	public Vector3nus(IList<NormalizedUInt16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3nus"/> from a single scalar that is applied to all factors.</summary>
	public Vector3nus(NormalizedUInt16 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3nus"/> has equal factors as the other <see cref="Vector3nus"/>.</summary>
	public bool Equals(Vector3nus other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3nus"/> of the same type, get whether this <see cref="Vector3nus"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3nus)
			return Equals((Vector3nus)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3nus"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3nus"/> to a string of the form "Vector3nus(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3nus"/> to a string of the form "Vector3nus(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3nus(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3nus"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3nus"/> values are equal.</summary>
	public static bool operator ==(Vector3nus a, Vector3nus b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3nus"/> values are unequal.</summary>
	public static bool operator !=(Vector3nus a, Vector3nus b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3nus"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3nus a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3nus"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3nus a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3nus a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3nus a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3nus a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3nus a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3nus a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3nus a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3nus a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3nus a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3nus a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3nus a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3nus a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3nus a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nus"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3nus a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nus(Vector3nus a) {
						return new Vector2nus(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3nus operator +(Vector3nus a) { return new Vector3nus((NormalizedUInt16)(+a.X), (NormalizedUInt16)(+a.Y), (NormalizedUInt16)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3nus operator -(Vector3nus a) { return new Vector3nus((NormalizedUInt16)(-a.X), (NormalizedUInt16)(-a.Y), (NormalizedUInt16)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3nus operator +(Vector3nus a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a.X + b.X), (NormalizedUInt16)(a.Y + b.Y), (NormalizedUInt16)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3nus operator +(Vector3nus a, NormalizedUInt16 b) { return new Vector3nus((NormalizedUInt16)(a.X + b), (NormalizedUInt16)(a.Y + b), (NormalizedUInt16)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3nus operator +(NormalizedUInt16 a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a + b.X), (NormalizedUInt16)(a + b.Y), (NormalizedUInt16)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3nus operator -(Vector3nus a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a.X - b.X), (NormalizedUInt16)(a.Y - b.Y), (NormalizedUInt16)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3nus operator -(Vector3nus a, NormalizedUInt16 b) { return new Vector3nus((NormalizedUInt16)(a.X - b), (NormalizedUInt16)(a.Y - b), (NormalizedUInt16)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3nus operator -(NormalizedUInt16 a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a - b.X), (NormalizedUInt16)(a - b.Y), (NormalizedUInt16)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3nus operator *(Vector3nus a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a.X * b.X), (NormalizedUInt16)(a.Y * b.Y), (NormalizedUInt16)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3nus operator *(Vector3nus a, NormalizedUInt16 b) { return new Vector3nus((NormalizedUInt16)(a.X * b), (NormalizedUInt16)(a.Y * b), (NormalizedUInt16)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3nus operator *(NormalizedUInt16 a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a * b.X), (NormalizedUInt16)(a * b.Y), (NormalizedUInt16)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3nus operator /(Vector3nus a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a.X / b.X), (NormalizedUInt16)(a.Y / b.Y), (NormalizedUInt16)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3nus operator /(Vector3nus a, NormalizedUInt16 b) { return new Vector3nus((NormalizedUInt16)(a.X / b), (NormalizedUInt16)(a.Y / b), (NormalizedUInt16)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3nus operator /(NormalizedUInt16 a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a / b.X), (NormalizedUInt16)(a / b.Y), (NormalizedUInt16)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3nus operator %(Vector3nus a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a.X % b.X), (NormalizedUInt16)(a.Y % b.Y), (NormalizedUInt16)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3nus operator %(Vector3nus a, NormalizedUInt16 b) { return new Vector3nus((NormalizedUInt16)(a.X % b), (NormalizedUInt16)(a.Y % b), (NormalizedUInt16)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3nus operator %(NormalizedUInt16 a, Vector3nus b) { return new Vector3nus((NormalizedUInt16)(a % b.X), (NormalizedUInt16)(a % b.Y), (NormalizedUInt16)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedUInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedUInt32), 3, false)]
	public partial struct Vector3nui : IEquatable<Vector3nui>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3nui Normalized { get { Vector3nui result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedUInt32 Product { get { return (NormalizedUInt32)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedUInt32 Sum { get { return (NormalizedUInt32)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3nui(double x, double y, double z) : this((NormalizedUInt32)x, (NormalizedUInt32)y, (NormalizedUInt32)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nui( Vector3d value) : this((NormalizedUInt32)value.X, (NormalizedUInt32)value.Y, (NormalizedUInt32)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3nui( ref  Vector3d value) : this((NormalizedUInt32)value.X, (NormalizedUInt32)value.Y, (NormalizedUInt32)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3nui One = new Vector3nui((NormalizedUInt32)1, (NormalizedUInt32)1, (NormalizedUInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3nui UnitX = new Vector3nui((NormalizedUInt32)1, (NormalizedUInt32)0, (NormalizedUInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3nui UnitY = new Vector3nui((NormalizedUInt32)0, (NormalizedUInt32)1, (NormalizedUInt32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3nui UnitZ = new Vector3nui((NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3nui( Vector2nui xy, NormalizedUInt32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nui(NormalizedUInt32 x,  Vector2nui y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3nui( ref  Vector2nui xy, NormalizedUInt32 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3nui(NormalizedUInt32 x,  ref  Vector2nui y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3nui other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3nui other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3nui Clamp( Vector3nui min,  Vector3nui max ) {
					Vector3nui result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3nui min,  ref  Vector3nui max , out Vector3nui result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3nui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3nui other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3nui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3nui other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3nui result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedUInt32)(X * m);  result.Y = (NormalizedUInt32)(Y * m);  result.Z = (NormalizedUInt32)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedUInt32 m = (NormalizedUInt32)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3nui Cross(Vector3nui other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3nui other, out Vector3nui result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3nui other, out Vector3nui result) {
							NormalizedUInt32 x = (NormalizedUInt32)(Y * other.Z - Z * other.Y), y = (NormalizedUInt32)(Z * other.X - X * other.Z), z = (NormalizedUInt32)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3nui"/>.</summary>
		public NormalizedUInt32 X;
			/// <summary>The second axis of the <see cref="Vector3nui"/>.</summary>
		public NormalizedUInt32 Y;
			/// <summary>The third axis of the <see cref="Vector3nui"/>.</summary>
		public NormalizedUInt32 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3nui"/>.</summary>
	public static readonly Vector3nui Zero = new Vector3nui((NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3nui"/> from the provided values for each factor.</summary>
	public Vector3nui(NormalizedUInt32 x, NormalizedUInt32 y, NormalizedUInt32 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3nui"/> from a list.</summary>
	public Vector3nui(IList<NormalizedUInt32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3nui"/> from a single scalar that is applied to all factors.</summary>
	public Vector3nui(NormalizedUInt32 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3nui"/> has equal factors as the other <see cref="Vector3nui"/>.</summary>
	public bool Equals(Vector3nui other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3nui"/> of the same type, get whether this <see cref="Vector3nui"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3nui)
			return Equals((Vector3nui)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3nui"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3nui"/> to a string of the form "Vector3nui(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3nui"/> to a string of the form "Vector3nui(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3nui(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3nui"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3nui"/> values are equal.</summary>
	public static bool operator ==(Vector3nui a, Vector3nui b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3nui"/> values are unequal.</summary>
	public static bool operator !=(Vector3nui a, Vector3nui b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3nui"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3nui a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3nui"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3nui a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3nui a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3nui a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3nui a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3nui a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3nui a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3nui a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3nui a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3nui a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3nui a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3nui a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3nui a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3nui a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3nui"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3nui a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nui(Vector3nui a) {
						return new Vector2nui(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3nui operator +(Vector3nui a) { return new Vector3nui((NormalizedUInt32)(+a.X), (NormalizedUInt32)(+a.Y), (NormalizedUInt32)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3nui operator -(Vector3nui a) { return new Vector3nui((NormalizedUInt32)(-a.X), (NormalizedUInt32)(-a.Y), (NormalizedUInt32)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3nui operator +(Vector3nui a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a.X + b.X), (NormalizedUInt32)(a.Y + b.Y), (NormalizedUInt32)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3nui operator +(Vector3nui a, NormalizedUInt32 b) { return new Vector3nui((NormalizedUInt32)(a.X + b), (NormalizedUInt32)(a.Y + b), (NormalizedUInt32)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3nui operator +(NormalizedUInt32 a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a + b.X), (NormalizedUInt32)(a + b.Y), (NormalizedUInt32)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3nui operator -(Vector3nui a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a.X - b.X), (NormalizedUInt32)(a.Y - b.Y), (NormalizedUInt32)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3nui operator -(Vector3nui a, NormalizedUInt32 b) { return new Vector3nui((NormalizedUInt32)(a.X - b), (NormalizedUInt32)(a.Y - b), (NormalizedUInt32)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3nui operator -(NormalizedUInt32 a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a - b.X), (NormalizedUInt32)(a - b.Y), (NormalizedUInt32)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3nui operator *(Vector3nui a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a.X * b.X), (NormalizedUInt32)(a.Y * b.Y), (NormalizedUInt32)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3nui operator *(Vector3nui a, NormalizedUInt32 b) { return new Vector3nui((NormalizedUInt32)(a.X * b), (NormalizedUInt32)(a.Y * b), (NormalizedUInt32)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3nui operator *(NormalizedUInt32 a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a * b.X), (NormalizedUInt32)(a * b.Y), (NormalizedUInt32)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3nui operator /(Vector3nui a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a.X / b.X), (NormalizedUInt32)(a.Y / b.Y), (NormalizedUInt32)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3nui operator /(Vector3nui a, NormalizedUInt32 b) { return new Vector3nui((NormalizedUInt32)(a.X / b), (NormalizedUInt32)(a.Y / b), (NormalizedUInt32)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3nui operator /(NormalizedUInt32 a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a / b.X), (NormalizedUInt32)(a / b.Y), (NormalizedUInt32)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3nui operator %(Vector3nui a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a.X % b.X), (NormalizedUInt32)(a.Y % b.Y), (NormalizedUInt32)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3nui operator %(Vector3nui a, NormalizedUInt32 b) { return new Vector3nui((NormalizedUInt32)(a.X % b), (NormalizedUInt32)(a.Y % b), (NormalizedUInt32)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3nui operator %(NormalizedUInt32 a, Vector3nui b) { return new Vector3nui((NormalizedUInt32)(a % b.X), (NormalizedUInt32)(a % b.Y), (NormalizedUInt32)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="NormalizedByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedByte), 3, false)]
	public partial struct Vector3rgb : IEquatable<Vector3rgb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3rgb Normalized { get { Vector3rgb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedByte Product { get { return (NormalizedByte)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedByte Sum { get { return (NormalizedByte)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector3rgb(double x, double y, double z) : this((NormalizedByte)x, (NormalizedByte)y, (NormalizedByte)z) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3rgb( Vector3d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector3rgb( ref  Vector3d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3rgb One = new Vector3rgb((NormalizedByte)1, (NormalizedByte)1, (NormalizedByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3rgb UnitX = new Vector3rgb((NormalizedByte)1, (NormalizedByte)0, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3rgb UnitY = new Vector3rgb((NormalizedByte)0, (NormalizedByte)1, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3rgb UnitZ = new Vector3rgb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector3rgb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector3rgb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3rgb Clamp( Vector3rgb min,  Vector3rgb max ) {
					Vector3rgb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3rgb min,  ref  Vector3rgb max , out Vector3rgb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3rgb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector3rgb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3rgb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector3rgb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3rgb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (NormalizedByte)(X * m);  result.Y = (NormalizedByte)(Y * m);  result.Z = (NormalizedByte)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedByte m = (NormalizedByte)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3rgb Cross(Vector3rgb other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3rgb other, out Vector3rgb result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3rgb other, out Vector3rgb result) {
							NormalizedByte x = (NormalizedByte)(Y * other.Z - Z * other.Y), y = (NormalizedByte)(Z * other.X - X * other.Z), z = (NormalizedByte)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3rgb"/>.</summary>
		public NormalizedByte X;
			/// <summary>The second axis of the <see cref="Vector3rgb"/>.</summary>
		public NormalizedByte Y;
			/// <summary>The third axis of the <see cref="Vector3rgb"/>.</summary>
		public NormalizedByte Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3rgb"/>.</summary>
	public static readonly Vector3rgb Zero = new Vector3rgb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3rgb"/> from the provided values for each factor.</summary>
	public Vector3rgb(NormalizedByte x, NormalizedByte y, NormalizedByte z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3rgb"/> from a list.</summary>
	public Vector3rgb(IList<NormalizedByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3rgb"/> from a single scalar that is applied to all factors.</summary>
	public Vector3rgb(NormalizedByte value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3rgb"/> has equal factors as the other <see cref="Vector3rgb"/>.</summary>
	public bool Equals(Vector3rgb other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3rgb"/> of the same type, get whether this <see cref="Vector3rgb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3rgb)
			return Equals((Vector3rgb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3rgb"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3rgb"/> to a string of the form "Vector3rgb(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3rgb"/> to a string of the form "Vector3rgb(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3rgb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3rgb"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3rgb"/> values are equal.</summary>
	public static bool operator ==(Vector3rgb a, Vector3rgb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3rgb"/> values are unequal.</summary>
	public static bool operator !=(Vector3rgb a, Vector3rgb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3rgb a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3rgb a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3rgb a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3rgb a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3rgb a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3rgb a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3rgb a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3rgb a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3rgb a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3rgb a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3rgb a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3rgb a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3rgb a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3rgb a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3rgb"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3rgb a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3rgb operator +(Vector3rgb a) { return new Vector3rgb((NormalizedByte)(+a.X), (NormalizedByte)(+a.Y), (NormalizedByte)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3rgb operator -(Vector3rgb a) { return new Vector3rgb((NormalizedByte)(-a.X), (NormalizedByte)(-a.Y), (NormalizedByte)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3rgb operator +(Vector3rgb a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a.X + b.X), (NormalizedByte)(a.Y + b.Y), (NormalizedByte)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3rgb operator +(Vector3rgb a, NormalizedByte b) { return new Vector3rgb((NormalizedByte)(a.X + b), (NormalizedByte)(a.Y + b), (NormalizedByte)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3rgb operator +(NormalizedByte a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a + b.X), (NormalizedByte)(a + b.Y), (NormalizedByte)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3rgb operator -(Vector3rgb a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a.X - b.X), (NormalizedByte)(a.Y - b.Y), (NormalizedByte)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3rgb operator -(Vector3rgb a, NormalizedByte b) { return new Vector3rgb((NormalizedByte)(a.X - b), (NormalizedByte)(a.Y - b), (NormalizedByte)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3rgb operator -(NormalizedByte a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a - b.X), (NormalizedByte)(a - b.Y), (NormalizedByte)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3rgb operator *(Vector3rgb a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a.X * b.X), (NormalizedByte)(a.Y * b.Y), (NormalizedByte)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3rgb operator *(Vector3rgb a, NormalizedByte b) { return new Vector3rgb((NormalizedByte)(a.X * b), (NormalizedByte)(a.Y * b), (NormalizedByte)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3rgb operator *(NormalizedByte a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a * b.X), (NormalizedByte)(a * b.Y), (NormalizedByte)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3rgb operator /(Vector3rgb a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a.X / b.X), (NormalizedByte)(a.Y / b.Y), (NormalizedByte)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3rgb operator /(Vector3rgb a, NormalizedByte b) { return new Vector3rgb((NormalizedByte)(a.X / b), (NormalizedByte)(a.Y / b), (NormalizedByte)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3rgb operator /(NormalizedByte a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a / b.X), (NormalizedByte)(a / b.Y), (NormalizedByte)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3rgb operator %(Vector3rgb a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a.X % b.X), (NormalizedByte)(a.Y % b.Y), (NormalizedByte)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3rgb operator %(Vector3rgb a, NormalizedByte b) { return new Vector3rgb((NormalizedByte)(a.X % b), (NormalizedByte)(a.Y % b), (NormalizedByte)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3rgb operator %(NormalizedByte a, Vector3rgb b) { return new Vector3rgb((NormalizedByte)(a % b.X), (NormalizedByte)(a % b.Y), (NormalizedByte)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="Float16"/> elements.</summary>
	[VectorTypeAttribute(typeof(Float16), 3, false)]
	public partial struct Vector3h : IEquatable<Vector3h>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Float16 MagnitudeSquared { get { return (Float16)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Float16 Magnitude {
				get {
					return (Float16)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector3h Normalized { get { Vector3h result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Float16 Product { get { return (Float16)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Float16 Sum { get { return (Float16)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3h One = new Vector3h((Float16)1, (Float16)1, (Float16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3h UnitX = new Vector3h((Float16)1, (Float16)0, (Float16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3h UnitY = new Vector3h((Float16)0, (Float16)1, (Float16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3h UnitZ = new Vector3h((Float16)0, (Float16)0, (Float16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3h( Vector2h xy, Float16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3h(Float16 x,  Vector2h y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3h( ref  Vector2h xy, Float16 z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3h(Float16 x,  ref  Vector2h y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Float16 Dot( Vector3h other) { return (Float16)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Float16 Dot( ref  Vector3h other) { return (Float16)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3h Clamp( Vector3h min,  Vector3h max ) {
					Vector3h result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3h min,  ref  Vector3h max , out Vector3h result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Float16 Distance( Vector3h other) {
					return (Float16)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Float16 DistanceSquared( Vector3h other) {
					return (Float16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Float16 Distance( ref  Vector3h other) {
					return (Float16)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Float16 DistanceSquared( ref  Vector3h other) {
					return (Float16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector3h result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z );
						 result.X = (Float16)(X * m);  result.Y = (Float16)(Y * m);  result.Z = (Float16)(Z * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Float16 m = (Float16)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z ));
						 X *= m;  Y *= m;  Z *= m; 					}
				
											/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <returns>The cross product.</returns>
						public Vector3h Cross(Vector3h other) { Cross(ref other, out other); return other; }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(Vector3h other, out Vector3h result) { Cross(ref other, out result); }

						/// <summary>Calculates the cross product of the vectors.</summary>
						/// <param name="other">The other vector to perform a cross product with.</param>
						/// <param name="result">Receives the cross product.</param>
						public void Cross(ref Vector3h other, out Vector3h result) {
							Float16 x = (Float16)(Y * other.Z - Z * other.Y), y = (Float16)(Z * other.X - X * other.Z), z = (Float16)(X * other.Y - Y * other.X);
							result.X = x;
							result.Y = y;
							result.Z = z;
						}

												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3h"/>.</summary>
		public Float16 X;
			/// <summary>The second axis of the <see cref="Vector3h"/>.</summary>
		public Float16 Y;
			/// <summary>The third axis of the <see cref="Vector3h"/>.</summary>
		public Float16 Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3h"/>.</summary>
	public static readonly Vector3h Zero = new Vector3h((Float16)0, (Float16)0, (Float16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3h"/> from the provided values for each factor.</summary>
	public Vector3h(Float16 x, Float16 y, Float16 z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3h"/> from a list.</summary>
	public Vector3h(IList<Float16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3h"/> from a single scalar that is applied to all factors.</summary>
	public Vector3h(Float16 value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3h"/> has equal factors as the other <see cref="Vector3h"/>.</summary>
	public bool Equals(Vector3h other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3h"/> of the same type, get whether this <see cref="Vector3h"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3h)
			return Equals((Vector3h)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3h"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3h"/> to a string of the form "Vector3h(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3h"/> to a string of the form "Vector3h(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3h(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3h"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3h"/> values are equal.</summary>
	public static bool operator ==(Vector3h a, Vector3h b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3h"/> values are unequal.</summary>
	public static bool operator !=(Vector3h a, Vector3h b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3h"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3h a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3h"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3h a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3h a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3h a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3h a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3h a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3h a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3h a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3h a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3h a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3h a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3h a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3h a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3h a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3h"/> to <see cref="Vector3sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3sb(Vector3h a) {
						return new Vector3sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2h(Vector3h a) {
						return new Vector2h(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3h operator +(Vector3h a) { return new Vector3h((Float16)(+a.X), (Float16)(+a.Y), (Float16)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3h operator -(Vector3h a) { return new Vector3h((Float16)(-a.X), (Float16)(-a.Y), (Float16)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3h operator +(Vector3h a, Vector3h b) { return new Vector3h((Float16)(a.X + b.X), (Float16)(a.Y + b.Y), (Float16)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3h operator +(Vector3h a, Float16 b) { return new Vector3h((Float16)(a.X + b), (Float16)(a.Y + b), (Float16)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3h operator +(Float16 a, Vector3h b) { return new Vector3h((Float16)(a + b.X), (Float16)(a + b.Y), (Float16)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3h operator -(Vector3h a, Vector3h b) { return new Vector3h((Float16)(a.X - b.X), (Float16)(a.Y - b.Y), (Float16)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3h operator -(Vector3h a, Float16 b) { return new Vector3h((Float16)(a.X - b), (Float16)(a.Y - b), (Float16)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3h operator -(Float16 a, Vector3h b) { return new Vector3h((Float16)(a - b.X), (Float16)(a - b.Y), (Float16)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3h operator *(Vector3h a, Vector3h b) { return new Vector3h((Float16)(a.X * b.X), (Float16)(a.Y * b.Y), (Float16)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3h operator *(Vector3h a, Float16 b) { return new Vector3h((Float16)(a.X * b), (Float16)(a.Y * b), (Float16)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3h operator *(Float16 a, Vector3h b) { return new Vector3h((Float16)(a * b.X), (Float16)(a * b.Y), (Float16)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3h operator /(Vector3h a, Vector3h b) { return new Vector3h((Float16)(a.X / b.X), (Float16)(a.Y / b.Y), (Float16)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3h operator /(Vector3h a, Float16 b) { return new Vector3h((Float16)(a.X / b), (Float16)(a.Y / b), (Float16)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3h operator /(Float16 a, Vector3h b) { return new Vector3h((Float16)(a / b.X), (Float16)(a / b.Y), (Float16)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3h operator %(Vector3h a, Vector3h b) { return new Vector3h((Float16)(a.X % b.X), (Float16)(a.Y % b.Y), (Float16)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3h operator %(Vector3h a, Float16 b) { return new Vector3h((Float16)(a.X % b), (Float16)(a.Y % b), (Float16)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3h operator %(Float16 a, Vector3h b) { return new Vector3h((Float16)(a % b.X), (Float16)(a % b.Y), (Float16)(a % b.Z)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A three-dimensional vector type using <see cref="SByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(SByte), 3, false)]
	public partial struct Vector3sb : IEquatable<Vector3sb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public int MagnitudeSquared { get { return (int)( X * X + Y * Y + Z * Z ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public SByte Product { get { return (SByte)( X * Y * Z ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public SByte Sum { get { return (SByte)( X + Y + Z ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector3sb One = new Vector3sb((SByte)1, (SByte)1, (SByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector3sb UnitX = new Vector3sb((SByte)1, (SByte)0, (SByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector3sb UnitY = new Vector3sb((SByte)0, (SByte)1, (SByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector3sb UnitZ = new Vector3sb((SByte)0, (SByte)0, (SByte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector3sb( Vector2sb xy, SByte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3sb(SByte x,  Vector2sb y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector3sb( ref  Vector2sb xy, SByte z) {
													X = xy.X;
													Y = xy.Y;
										
						Z = z;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector3sb(SByte x,  ref  Vector2sb y) {
						X = x;

													Y = y.X;
													Z = y.Y;
											}
							
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public int Dot( Vector3sb other) { return (int)( X * other.X + Y * other.Y + Z * other.Z ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public int Dot( ref  Vector3sb other) { return (int)( X * other.X + Y * other.Y + Z * other.Z ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector3sb Clamp( Vector3sb min,  Vector3sb max ) {
					Vector3sb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector3sb min,  ref  Vector3sb max , out Vector3sb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector3sb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( Vector3sb other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector3sb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( ref  Vector3sb other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector3sb"/>.</summary>
		public SByte X;
			/// <summary>The second axis of the <see cref="Vector3sb"/>.</summary>
		public SByte Y;
			/// <summary>The third axis of the <see cref="Vector3sb"/>.</summary>
		public SByte Z;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector3sb"/>.</summary>
	public static readonly Vector3sb Zero = new Vector3sb((SByte)0, (SByte)0, (SByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector3sb"/> from the provided values for each factor.</summary>
	public Vector3sb(SByte x, SByte y, SByte z)
	{
					X = x;
					Y = y;
					Z = z;
			}

	/// <summary>Initialise a <see cref="Vector3sb"/> from a list.</summary>
	public Vector3sb(IList<SByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2]) { }

	/// <summary>Initialise a <see cref="Vector3sb"/> from a single scalar that is applied to all factors.</summary>
	public Vector3sb(SByte value) : this(value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector3sb"/> has equal factors as the other <see cref="Vector3sb"/>.</summary>
	public bool Equals(Vector3sb other) {
		return  X == other.X && Y == other.Y && Z == other.Z ;
	}

	/// <summary>If the other object is a <see cref="Vector3sb"/> of the same type, get whether this <see cref="Vector3sb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector3sb)
			return Equals((Vector3sb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector3sb"/> to a string of the form "X, Y, Z".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector3sb"/> to a string of the form "Vector3sb(X, Y, Z)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector3sb"/> to a string of the form "Vector3sb(X, Y, Z)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector3sb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector3sb"/> to a string of the form "{X, Y, Z".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector3sb"/> values are equal.</summary>
	public static bool operator ==(Vector3sb a, Vector3sb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z; }

	/// <summary>Get whether the <see cref="Vector3sb"/> values are unequal.</summary>
	public static bool operator !=(Vector3sb a, Vector3sb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector3sb"/> to <see cref="Vector3f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3f(Vector3sb a) {
						return new Vector3f((Single)a.X, (Single)a.Y, (Single)a.Z);
					}
					/// <summary>An implicit cast from <see cref="Vector3sb"/> to <see cref="Vector3d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector3d(Vector3sb a) {
						return new Vector3d((Double)a.X, (Double)a.Y, (Double)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3s(Vector3sb a) {
						return new Vector3s((Int16)a.X, (Int16)a.Y, (Int16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3us(Vector3sb a) {
						return new Vector3us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3i(Vector3sb a) {
						return new Vector3i((Int32)a.X, (Int32)a.Y, (Int32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ui(Vector3sb a) {
						return new Vector3ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3b(Vector3sb a) {
						return new Vector3b((Byte)a.X, (Byte)a.Y, (Byte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nb(Vector3sb a) {
						return new Vector3nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nsb(Vector3sb a) {
						return new Vector3nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ns(Vector3sb a) {
						return new Vector3ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3ni(Vector3sb a) {
						return new Vector3ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nus(Vector3sb a) {
						return new Vector3nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3nui(Vector3sb a) {
						return new Vector3nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3rgb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3rgb(Vector3sb a) {
						return new Vector3rgb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z);
					}
					/// <summary>An explicit cast from <see cref="Vector3sb"/> to <see cref="Vector3h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector3h(Vector3sb a) {
						return new Vector3h((Float16)a.X, (Float16)a.Y, (Float16)a.Z);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2sb(Vector3sb a) {
						return new Vector2sb(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector3sb operator +(Vector3sb a) { return new Vector3sb((SByte)(+a.X), (SByte)(+a.Y), (SByte)(+a.Z)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector3sb operator -(Vector3sb a) { return new Vector3sb((SByte)(-a.X), (SByte)(-a.Y), (SByte)(-a.Z)); }
								/// <summary>Add the vector.</summary>
					public static Vector3sb operator +(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X + b.X), (SByte)(a.Y + b.Y), (SByte)(a.Z + b.Z)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector3sb operator +(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X + b), (SByte)(a.Y + b), (SByte)(a.Z + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector3sb operator +(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a + b.X), (SByte)(a + b.Y), (SByte)(a + b.Z)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector3sb operator -(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X - b.X), (SByte)(a.Y - b.Y), (SByte)(a.Z - b.Z)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector3sb operator -(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X - b), (SByte)(a.Y - b), (SByte)(a.Z - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector3sb operator -(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a - b.X), (SByte)(a - b.Y), (SByte)(a - b.Z)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector3sb operator *(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X * b.X), (SByte)(a.Y * b.Y), (SByte)(a.Z * b.Z)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector3sb operator *(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X * b), (SByte)(a.Y * b), (SByte)(a.Z * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector3sb operator *(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a * b.X), (SByte)(a * b.Y), (SByte)(a * b.Z)); }
									/// <summary>Divide the vector.</summary>
					public static Vector3sb operator /(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X / b.X), (SByte)(a.Y / b.Y), (SByte)(a.Z / b.Z)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector3sb operator /(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X / b), (SByte)(a.Y / b), (SByte)(a.Z / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector3sb operator /(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a / b.X), (SByte)(a / b.Y), (SByte)(a / b.Z)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector3sb operator %(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X % b.X), (SByte)(a.Y % b.Y), (SByte)(a.Z % b.Z)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector3sb operator %(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X % b), (SByte)(a.Y % b), (SByte)(a.Z % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector3sb operator %(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a % b.X), (SByte)(a % b.Y), (SByte)(a % b.Z)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector3sb operator &(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X & b.X), (SByte)(a.Y & b.Y), (SByte)(a.Z & b.Z)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector3sb operator &(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X & b), (SByte)(a.Y & b), (SByte)(a.Z & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector3sb operator &(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a & b.X), (SByte)(a & b.Y), (SByte)(a & b.Z)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector3sb operator |(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X | b.X), (SByte)(a.Y | b.Y), (SByte)(a.Z | b.Z)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector3sb operator |(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X | b), (SByte)(a.Y | b), (SByte)(a.Z | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector3sb operator |(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a | b.X), (SByte)(a | b.Y), (SByte)(a | b.Z)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector3sb operator ^(Vector3sb a, Vector3sb b) { return new Vector3sb((SByte)(a.X ^ b.X), (SByte)(a.Y ^ b.Y), (SByte)(a.Z ^ b.Z)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector3sb operator ^(Vector3sb a, SByte b) { return new Vector3sb((SByte)(a.X ^ b), (SByte)(a.Y ^ b), (SByte)(a.Z ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector3sb operator ^(SByte a, Vector3sb b) { return new Vector3sb((SByte)(a ^ b.X), (SByte)(a ^ b.Y), (SByte)(a ^ b.Z)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector3sb operator <<(Vector3sb a, int b) { return new Vector3sb((SByte)(a.X << b), (SByte)(a.Y << b), (SByte)(a.Z << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector3sb operator >>(Vector3sb a, int b) { return new Vector3sb((SByte)(a.X >> b), (SByte)(a.Y >> b), (SByte)(a.Z >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Length"/> elements.</summary>
	[VectorTypeAttribute(typeof(Length), 4, false)]
	public partial struct Vector4 : IEquatable<Vector4>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Area MagnitudeSquared { get { return (Area)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Length Magnitude {
				get {
					return Length.Universal(						Math.Sqrt(
															( X).InUniversal.Squared() 
							+								( Y).InUniversal.Squared() 
							+								( Z).InUniversal.Squared() 
							+								( W).InUniversal.Squared() 
													));
				}
			}

										
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Length Sum { get { return (Length)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
												/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
					public static Vector4 Centimetres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Centimetres(x) ,  Length.Centimetres(y) ,  Length.Centimetres(z) ,  Length.Centimetres(w) );
					}
				
					/// <summary>Initialize the vector from the Centimetres value.</summary>.
					public static Vector4 Centimetres(double value) {
						return new Vector4(Length.Centimetres(value));
					}

											/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
						public static Vector4 Centimetres( Vector4d value) {
							return new Vector4(								Length.Centimetres(value.X)
							, 								Length.Centimetres(value.Y)
							, 								Length.Centimetres(value.Z)
							, 								Length.Centimetres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Centimetres units.</summary>.
						public static Vector4 Centimetres( ref  Vector4d value) {
							return new Vector4(								Length.Centimetres(value.X)
							, 								Length.Centimetres(value.Y)
							, 								Length.Centimetres(value.Z)
							, 								Length.Centimetres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Centimetres unit.</summary>
					public Vector4d InCentimetres {
						get {
							return new Vector4d(								X.InCentimetres
							, 								Y.InCentimetres
							, 								Z.InCentimetres
							, 								W.InCentimetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Feet units.</summary>.
					public static Vector4 Feet( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Feet(x) ,  Length.Feet(y) ,  Length.Feet(z) ,  Length.Feet(w) );
					}
				
					/// <summary>Initialize the vector from the Feet value.</summary>.
					public static Vector4 Feet(double value) {
						return new Vector4(Length.Feet(value));
					}

											/// <summary>Initialize the vector from values provided in Feet units.</summary>.
						public static Vector4 Feet( Vector4d value) {
							return new Vector4(								Length.Feet(value.X)
							, 								Length.Feet(value.Y)
							, 								Length.Feet(value.Z)
							, 								Length.Feet(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Feet units.</summary>.
						public static Vector4 Feet( ref  Vector4d value) {
							return new Vector4(								Length.Feet(value.X)
							, 								Length.Feet(value.Y)
							, 								Length.Feet(value.Z)
							, 								Length.Feet(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Feet unit.</summary>
					public Vector4d InFeet {
						get {
							return new Vector4d(								X.InFeet
							, 								Y.InFeet
							, 								Z.InFeet
							, 								W.InFeet
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Inches units.</summary>.
					public static Vector4 Inches( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Inches(x) ,  Length.Inches(y) ,  Length.Inches(z) ,  Length.Inches(w) );
					}
				
					/// <summary>Initialize the vector from the Inches value.</summary>.
					public static Vector4 Inches(double value) {
						return new Vector4(Length.Inches(value));
					}

											/// <summary>Initialize the vector from values provided in Inches units.</summary>.
						public static Vector4 Inches( Vector4d value) {
							return new Vector4(								Length.Inches(value.X)
							, 								Length.Inches(value.Y)
							, 								Length.Inches(value.Z)
							, 								Length.Inches(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Inches units.</summary>.
						public static Vector4 Inches( ref  Vector4d value) {
							return new Vector4(								Length.Inches(value.X)
							, 								Length.Inches(value.Y)
							, 								Length.Inches(value.Z)
							, 								Length.Inches(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Inches unit.</summary>
					public Vector4d InInches {
						get {
							return new Vector4d(								X.InInches
							, 								Y.InInches
							, 								Z.InInches
							, 								W.InInches
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
					public static Vector4 Kilometres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Kilometres(x) ,  Length.Kilometres(y) ,  Length.Kilometres(z) ,  Length.Kilometres(w) );
					}
				
					/// <summary>Initialize the vector from the Kilometres value.</summary>.
					public static Vector4 Kilometres(double value) {
						return new Vector4(Length.Kilometres(value));
					}

											/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
						public static Vector4 Kilometres( Vector4d value) {
							return new Vector4(								Length.Kilometres(value.X)
							, 								Length.Kilometres(value.Y)
							, 								Length.Kilometres(value.Z)
							, 								Length.Kilometres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Kilometres units.</summary>.
						public static Vector4 Kilometres( ref  Vector4d value) {
							return new Vector4(								Length.Kilometres(value.X)
							, 								Length.Kilometres(value.Y)
							, 								Length.Kilometres(value.Z)
							, 								Length.Kilometres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Kilometres unit.</summary>
					public Vector4d InKilometres {
						get {
							return new Vector4d(								X.InKilometres
							, 								Y.InKilometres
							, 								Z.InKilometres
							, 								W.InKilometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
					public static Vector4 Megametres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Megametres(x) ,  Length.Megametres(y) ,  Length.Megametres(z) ,  Length.Megametres(w) );
					}
				
					/// <summary>Initialize the vector from the Megametres value.</summary>.
					public static Vector4 Megametres(double value) {
						return new Vector4(Length.Megametres(value));
					}

											/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
						public static Vector4 Megametres( Vector4d value) {
							return new Vector4(								Length.Megametres(value.X)
							, 								Length.Megametres(value.Y)
							, 								Length.Megametres(value.Z)
							, 								Length.Megametres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Megametres units.</summary>.
						public static Vector4 Megametres( ref  Vector4d value) {
							return new Vector4(								Length.Megametres(value.X)
							, 								Length.Megametres(value.Y)
							, 								Length.Megametres(value.Z)
							, 								Length.Megametres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Megametres unit.</summary>
					public Vector4d InMegametres {
						get {
							return new Vector4d(								X.InMegametres
							, 								Y.InMegametres
							, 								Z.InMegametres
							, 								W.InMegametres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Metres units.</summary>.
					public static Vector4 Metres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Metres(x) ,  Length.Metres(y) ,  Length.Metres(z) ,  Length.Metres(w) );
					}
				
					/// <summary>Initialize the vector from the Metres value.</summary>.
					public static Vector4 Metres(double value) {
						return new Vector4(Length.Metres(value));
					}

											/// <summary>Initialize the vector from values provided in Metres units.</summary>.
						public static Vector4 Metres( Vector4d value) {
							return new Vector4(								Length.Metres(value.X)
							, 								Length.Metres(value.Y)
							, 								Length.Metres(value.Z)
							, 								Length.Metres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Metres units.</summary>.
						public static Vector4 Metres( ref  Vector4d value) {
							return new Vector4(								Length.Metres(value.X)
							, 								Length.Metres(value.Y)
							, 								Length.Metres(value.Z)
							, 								Length.Metres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Metres unit.</summary>
					public Vector4d InMetres {
						get {
							return new Vector4d(								X.InMetres
							, 								Y.InMetres
							, 								Z.InMetres
							, 								W.InMetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
					public static Vector4 Micrometres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Micrometres(x) ,  Length.Micrometres(y) ,  Length.Micrometres(z) ,  Length.Micrometres(w) );
					}
				
					/// <summary>Initialize the vector from the Micrometres value.</summary>.
					public static Vector4 Micrometres(double value) {
						return new Vector4(Length.Micrometres(value));
					}

											/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
						public static Vector4 Micrometres( Vector4d value) {
							return new Vector4(								Length.Micrometres(value.X)
							, 								Length.Micrometres(value.Y)
							, 								Length.Micrometres(value.Z)
							, 								Length.Micrometres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Micrometres units.</summary>.
						public static Vector4 Micrometres( ref  Vector4d value) {
							return new Vector4(								Length.Micrometres(value.X)
							, 								Length.Micrometres(value.Y)
							, 								Length.Micrometres(value.Z)
							, 								Length.Micrometres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Micrometres unit.</summary>
					public Vector4d InMicrometres {
						get {
							return new Vector4d(								X.InMicrometres
							, 								Y.InMicrometres
							, 								Z.InMicrometres
							, 								W.InMicrometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
					public static Vector4 Millimetres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Millimetres(x) ,  Length.Millimetres(y) ,  Length.Millimetres(z) ,  Length.Millimetres(w) );
					}
				
					/// <summary>Initialize the vector from the Millimetres value.</summary>.
					public static Vector4 Millimetres(double value) {
						return new Vector4(Length.Millimetres(value));
					}

											/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
						public static Vector4 Millimetres( Vector4d value) {
							return new Vector4(								Length.Millimetres(value.X)
							, 								Length.Millimetres(value.Y)
							, 								Length.Millimetres(value.Z)
							, 								Length.Millimetres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Millimetres units.</summary>.
						public static Vector4 Millimetres( ref  Vector4d value) {
							return new Vector4(								Length.Millimetres(value.X)
							, 								Length.Millimetres(value.Y)
							, 								Length.Millimetres(value.Z)
							, 								Length.Millimetres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Millimetres unit.</summary>
					public Vector4d InMillimetres {
						get {
							return new Vector4d(								X.InMillimetres
							, 								Y.InMillimetres
							, 								Z.InMillimetres
							, 								W.InMillimetres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
					public static Vector4 Nanometres( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Nanometres(x) ,  Length.Nanometres(y) ,  Length.Nanometres(z) ,  Length.Nanometres(w) );
					}
				
					/// <summary>Initialize the vector from the Nanometres value.</summary>.
					public static Vector4 Nanometres(double value) {
						return new Vector4(Length.Nanometres(value));
					}

											/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
						public static Vector4 Nanometres( Vector4d value) {
							return new Vector4(								Length.Nanometres(value.X)
							, 								Length.Nanometres(value.Y)
							, 								Length.Nanometres(value.Z)
							, 								Length.Nanometres(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Nanometres units.</summary>.
						public static Vector4 Nanometres( ref  Vector4d value) {
							return new Vector4(								Length.Nanometres(value.X)
							, 								Length.Nanometres(value.Y)
							, 								Length.Nanometres(value.Z)
							, 								Length.Nanometres(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Nanometres unit.</summary>
					public Vector4d InNanometres {
						get {
							return new Vector4d(								X.InNanometres
							, 								Y.InNanometres
							, 								Z.InNanometres
							, 								W.InNanometres
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Yards units.</summary>.
					public static Vector4 Yards( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Yards(x) ,  Length.Yards(y) ,  Length.Yards(z) ,  Length.Yards(w) );
					}
				
					/// <summary>Initialize the vector from the Yards value.</summary>.
					public static Vector4 Yards(double value) {
						return new Vector4(Length.Yards(value));
					}

											/// <summary>Initialize the vector from values provided in Yards units.</summary>.
						public static Vector4 Yards( Vector4d value) {
							return new Vector4(								Length.Yards(value.X)
							, 								Length.Yards(value.Y)
							, 								Length.Yards(value.Z)
							, 								Length.Yards(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Yards units.</summary>.
						public static Vector4 Yards( ref  Vector4d value) {
							return new Vector4(								Length.Yards(value.X)
							, 								Length.Yards(value.Y)
							, 								Length.Yards(value.Z)
							, 								Length.Yards(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Yards unit.</summary>
					public Vector4d InYards {
						get {
							return new Vector4d(								X.InYards
							, 								Y.InYards
							, 								Z.InYards
							, 								W.InYards
							);
						}
					}
									/// <summary>Initialize the vector from values provided in Universal units.</summary>.
					public static Vector4 Universal( double x ,  double y ,  double z ,  double w ) {
						return new Vector4( Length.Universal(x) ,  Length.Universal(y) ,  Length.Universal(z) ,  Length.Universal(w) );
					}
				
					/// <summary>Initialize the vector from the Universal value.</summary>.
					public static Vector4 Universal(double value) {
						return new Vector4(Length.Universal(value));
					}

											/// <summary>Initialize the vector from values provided in Universal units.</summary>.
						public static Vector4 Universal( Vector4d value) {
							return new Vector4(								Length.Universal(value.X)
							, 								Length.Universal(value.Y)
							, 								Length.Universal(value.Z)
							, 								Length.Universal(value.W)
							);
						}
											/// <summary>Initialize the vector from values provided in Universal units.</summary>.
						public static Vector4 Universal( ref  Vector4d value) {
							return new Vector4(								Length.Universal(value.X)
							, 								Length.Universal(value.Y)
							, 								Length.Universal(value.Z)
							, 								Length.Universal(value.W)
							);
						}
									
					/// <summary>Convert into a vector in Universal unit.</summary>
					public Vector4d InUniversal {
						get {
							return new Vector4d(								X.InUniversal
							, 								Y.InUniversal
							, 								Z.InUniversal
							, 								W.InUniversal
							);
						}
					}
				
			
			

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4( Vector3 xyz, Length w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4(Length x,  Vector3 yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4( ref  Vector3 xyz, Length w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4(Length x,  ref  Vector3 yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4( Vector2 xy, Length z, Length w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4(Length x,  Vector2 yz, Length w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4(Length x, Length y,  Vector2 zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4( Vector2 xy,  Vector2 zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4( ref  Vector2 xy, Length z, Length w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4(Length x,  ref  Vector2 yz, Length w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4(Length x, Length y,  ref  Vector2 zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4( ref  Vector2 xy,  ref  Vector2 zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Area Dot( Vector4 other) { return (Area)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Area Dot( ref  Vector4 other) { return (Area)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4 Clamp( Vector4 min,  Vector4 max ) {
					Vector4 result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4 min,  ref  Vector4 max , out Vector4 result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Length Distance( Vector4 other) {
					return Length.Universal(						Math.Sqrt(
															( X - other.X ).InUniversal.Squared() 
							+								( Y - other.Y ).InUniversal.Squared() 
							+								( Z - other.Z ).InUniversal.Squared() 
							+								( W - other.W ).InUniversal.Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Area DistanceSquared( Vector4 other) {
					return (Area)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Length Distance( ref  Vector4 other) {
					return Length.Universal(						Math.Sqrt(
															( X - other.X ).InUniversal.Squared() 
							+								( Y - other.Y ).InUniversal.Squared() 
							+								( Z - other.Z ).InUniversal.Squared() 
							+								( W - other.W ).InUniversal.Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Area DistanceSquared( ref  Vector4 other) {
					return (Area)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
										
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4"/>.</summary>
		public Length X;
			/// <summary>The second axis of the <see cref="Vector4"/>.</summary>
		public Length Y;
			/// <summary>The third axis of the <see cref="Vector4"/>.</summary>
		public Length Z;
			/// <summary>The fourth axis of the <see cref="Vector4"/>.</summary>
		public Length W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4"/>.</summary>
	public static readonly Vector4 Zero = new Vector4(Length.Zero, Length.Zero, Length.Zero, Length.Zero);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4"/> from the provided values for each factor.</summary>
	public Vector4(Length x, Length y, Length z, Length w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4"/> from a list.</summary>
	public Vector4(IList<Length> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4"/> from a single scalar that is applied to all factors.</summary>
	public Vector4(Length value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4"/> has equal factors as the other <see cref="Vector4"/>.</summary>
	public bool Equals(Vector4 other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4"/> of the same type, get whether this <see cref="Vector4"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4)
			return Equals((Vector4)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4"/> to a string of the form "Vector4(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4"/> to a string of the form "Vector4(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4"/> values are equal.</summary>
	public static bool operator ==(Vector4 a, Vector4 b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4"/> values are unequal.</summary>
	public static bool operator !=(Vector4 a, Vector4 b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
			
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4 operator +(Vector4 a) { return new Vector4((Length)(+a.X), (Length)(+a.Y), (Length)(+a.Z), (Length)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4 operator -(Vector4 a) { return new Vector4((Length)(-a.X), (Length)(-a.Y), (Length)(-a.Z), (Length)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4 operator +(Vector4 a, Vector4 b) { return new Vector4((Length)(a.X + b.X), (Length)(a.Y + b.Y), (Length)(a.Z + b.Z), (Length)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4 operator +(Vector4 a, Length b) { return new Vector4((Length)(a.X + b), (Length)(a.Y + b), (Length)(a.Z + b), (Length)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4 operator +(Length a, Vector4 b) { return new Vector4((Length)(a + b.X), (Length)(a + b.Y), (Length)(a + b.Z), (Length)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4 operator -(Vector4 a, Vector4 b) { return new Vector4((Length)(a.X - b.X), (Length)(a.Y - b.Y), (Length)(a.Z - b.Z), (Length)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4 operator -(Vector4 a, Length b) { return new Vector4((Length)(a.X - b), (Length)(a.Y - b), (Length)(a.Z - b), (Length)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4 operator -(Length a, Vector4 b) { return new Vector4((Length)(a - b.X), (Length)(a - b.Y), (Length)(a - b.Z), (Length)(a - b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Single"/> elements.</summary>
	[VectorTypeAttribute(typeof(Single), 4, false)]
	public partial struct Vector4f : IEquatable<Vector4f>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Single MagnitudeSquared { get { return (Single)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Single Magnitude {
				get {
					return (Single)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4f Normalized { get { Vector4f result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Single Product { get { return (Single)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Single Sum { get { return (Single)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4f One = new Vector4f((Single)1, (Single)1, (Single)1, (Single)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4f UnitX = new Vector4f((Single)1, (Single)0, (Single)0, (Single)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4f UnitY = new Vector4f((Single)0, (Single)1, (Single)0, (Single)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4f UnitZ = new Vector4f((Single)0, (Single)0, (Single)1, (Single)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4f UnitW = new Vector4f((Single)0, (Single)0, (Single)0, (Single)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4f( Vector3f xyz, Single w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4f(Single x,  Vector3f yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4f( ref  Vector3f xyz, Single w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4f(Single x,  ref  Vector3f yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4f( Vector2f xy, Single z, Single w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4f(Single x,  Vector2f yz, Single w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4f(Single x, Single y,  Vector2f zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4f( Vector2f xy,  Vector2f zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4f( ref  Vector2f xy, Single z, Single w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4f(Single x,  ref  Vector2f yz, Single w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4f(Single x, Single y,  ref  Vector2f zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4f( ref  Vector2f xy,  ref  Vector2f zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Single Dot( Vector4f other) { return (Single)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Single Dot( ref  Vector4f other) { return (Single)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4f Clamp( Vector4f min,  Vector4f max ) {
					Vector4f result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4f min,  ref  Vector4f max , out Vector4f result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Single Distance( Vector4f other) {
					return (Single)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Single DistanceSquared( Vector4f other) {
					return (Single)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Single Distance( ref  Vector4f other) {
					return (Single)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Single DistanceSquared( ref  Vector4f other) {
					return (Single)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4f result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (Single)(X * m);  result.Y = (Single)(Y * m);  result.Z = (Single)(Z * m);  result.W = (Single)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Single m = (Single)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4f"/>.</summary>
		public Single X;
			/// <summary>The second axis of the <see cref="Vector4f"/>.</summary>
		public Single Y;
			/// <summary>The third axis of the <see cref="Vector4f"/>.</summary>
		public Single Z;
			/// <summary>The fourth axis of the <see cref="Vector4f"/>.</summary>
		public Single W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4f"/>.</summary>
	public static readonly Vector4f Zero = new Vector4f((Single)0, (Single)0, (Single)0, (Single)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4f"/> from the provided values for each factor.</summary>
	public Vector4f(Single x, Single y, Single z, Single w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4f"/> from a list.</summary>
	public Vector4f(IList<Single> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4f"/> from a single scalar that is applied to all factors.</summary>
	public Vector4f(Single value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4f"/> has equal factors as the other <see cref="Vector4f"/>.</summary>
	public bool Equals(Vector4f other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4f"/> of the same type, get whether this <see cref="Vector4f"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4f)
			return Equals((Vector4f)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4f"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4f"/> to a string of the form "Vector4f(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4f"/> to a string of the form "Vector4f(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4f(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4f"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4f"/> values are equal.</summary>
	public static bool operator ==(Vector4f a, Vector4f b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4f"/> values are unequal.</summary>
	public static bool operator !=(Vector4f a, Vector4f b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4f"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4f a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4f a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4f a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4f a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4f a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4f a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4f a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4f a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4f a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4f a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4f a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4f a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4f a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4f a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4f"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4f a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3f(Vector4f a) {
						return new Vector3f(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2f(Vector4f a) {
						return new Vector2f(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4f operator +(Vector4f a) { return new Vector4f((Single)(+a.X), (Single)(+a.Y), (Single)(+a.Z), (Single)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4f operator -(Vector4f a) { return new Vector4f((Single)(-a.X), (Single)(-a.Y), (Single)(-a.Z), (Single)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4f operator +(Vector4f a, Vector4f b) { return new Vector4f((Single)(a.X + b.X), (Single)(a.Y + b.Y), (Single)(a.Z + b.Z), (Single)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4f operator +(Vector4f a, Single b) { return new Vector4f((Single)(a.X + b), (Single)(a.Y + b), (Single)(a.Z + b), (Single)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4f operator +(Single a, Vector4f b) { return new Vector4f((Single)(a + b.X), (Single)(a + b.Y), (Single)(a + b.Z), (Single)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4f operator -(Vector4f a, Vector4f b) { return new Vector4f((Single)(a.X - b.X), (Single)(a.Y - b.Y), (Single)(a.Z - b.Z), (Single)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4f operator -(Vector4f a, Single b) { return new Vector4f((Single)(a.X - b), (Single)(a.Y - b), (Single)(a.Z - b), (Single)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4f operator -(Single a, Vector4f b) { return new Vector4f((Single)(a - b.X), (Single)(a - b.Y), (Single)(a - b.Z), (Single)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4f operator *(Vector4f a, Vector4f b) { return new Vector4f((Single)(a.X * b.X), (Single)(a.Y * b.Y), (Single)(a.Z * b.Z), (Single)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4f operator *(Vector4f a, Single b) { return new Vector4f((Single)(a.X * b), (Single)(a.Y * b), (Single)(a.Z * b), (Single)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4f operator *(Single a, Vector4f b) { return new Vector4f((Single)(a * b.X), (Single)(a * b.Y), (Single)(a * b.Z), (Single)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4f operator /(Vector4f a, Vector4f b) { return new Vector4f((Single)(a.X / b.X), (Single)(a.Y / b.Y), (Single)(a.Z / b.Z), (Single)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4f operator /(Vector4f a, Single b) { return new Vector4f((Single)(a.X / b), (Single)(a.Y / b), (Single)(a.Z / b), (Single)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4f operator /(Single a, Vector4f b) { return new Vector4f((Single)(a / b.X), (Single)(a / b.Y), (Single)(a / b.Z), (Single)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4f operator %(Vector4f a, Vector4f b) { return new Vector4f((Single)(a.X % b.X), (Single)(a.Y % b.Y), (Single)(a.Z % b.Z), (Single)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4f operator %(Vector4f a, Single b) { return new Vector4f((Single)(a.X % b), (Single)(a.Y % b), (Single)(a.Z % b), (Single)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4f operator %(Single a, Vector4f b) { return new Vector4f((Single)(a % b.X), (Single)(a % b.Y), (Single)(a % b.Z), (Single)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Double"/> elements.</summary>
	[VectorTypeAttribute(typeof(Double), 4, false)]
	public partial struct Vector4d : IEquatable<Vector4d>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Double Magnitude {
				get {
					return (Double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4d Normalized { get { Vector4d result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Double Product { get { return (Double)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Double Sum { get { return (Double)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4d One = new Vector4d((Double)1, (Double)1, (Double)1, (Double)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4d UnitX = new Vector4d((Double)1, (Double)0, (Double)0, (Double)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4d UnitY = new Vector4d((Double)0, (Double)1, (Double)0, (Double)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4d UnitZ = new Vector4d((Double)0, (Double)0, (Double)1, (Double)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4d UnitW = new Vector4d((Double)0, (Double)0, (Double)0, (Double)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4d( Vector3d xyz, Double w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4d(Double x,  Vector3d yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4d( ref  Vector3d xyz, Double w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4d(Double x,  ref  Vector3d yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4d( Vector2d xy, Double z, Double w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4d(Double x,  Vector2d yz, Double w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4d(Double x, Double y,  Vector2d zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4d( Vector2d xy,  Vector2d zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4d( ref  Vector2d xy, Double z, Double w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4d(Double x,  ref  Vector2d yz, Double w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4d(Double x, Double y,  ref  Vector2d zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4d( ref  Vector2d xy,  ref  Vector2d zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4d other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4d other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4d Clamp( Vector4d min,  Vector4d max ) {
					Vector4d result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4d min,  ref  Vector4d max , out Vector4d result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Double Distance( Vector4d other) {
					return (Double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4d other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Double Distance( ref  Vector4d other) {
					return (Double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4d other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4d result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (Double)(X * m);  result.Y = (Double)(Y * m);  result.Z = (Double)(Z * m);  result.W = (Double)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Double m = (Double)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4d"/>.</summary>
		public Double X;
			/// <summary>The second axis of the <see cref="Vector4d"/>.</summary>
		public Double Y;
			/// <summary>The third axis of the <see cref="Vector4d"/>.</summary>
		public Double Z;
			/// <summary>The fourth axis of the <see cref="Vector4d"/>.</summary>
		public Double W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4d"/>.</summary>
	public static readonly Vector4d Zero = new Vector4d((Double)0, (Double)0, (Double)0, (Double)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4d"/> from the provided values for each factor.</summary>
	public Vector4d(Double x, Double y, Double z, Double w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4d"/> from a list.</summary>
	public Vector4d(IList<Double> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4d"/> from a single scalar that is applied to all factors.</summary>
	public Vector4d(Double value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4d"/> has equal factors as the other <see cref="Vector4d"/>.</summary>
	public bool Equals(Vector4d other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4d"/> of the same type, get whether this <see cref="Vector4d"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4d)
			return Equals((Vector4d)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4d"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4d"/> to a string of the form "Vector4d(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4d"/> to a string of the form "Vector4d(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4d(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4d"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4d"/> values are equal.</summary>
	public static bool operator ==(Vector4d a, Vector4d b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4d"/> values are unequal.</summary>
	public static bool operator !=(Vector4d a, Vector4d b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4f(Vector4d a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4d a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4d a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4d a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4d a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4d a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4d a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4d a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4d a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4d a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4d a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4d a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4d a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4d a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4d"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4d a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3d(Vector4d a) {
						return new Vector3d(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2d(Vector4d a) {
						return new Vector2d(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4d operator +(Vector4d a) { return new Vector4d((Double)(+a.X), (Double)(+a.Y), (Double)(+a.Z), (Double)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4d operator -(Vector4d a) { return new Vector4d((Double)(-a.X), (Double)(-a.Y), (Double)(-a.Z), (Double)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4d operator +(Vector4d a, Vector4d b) { return new Vector4d((Double)(a.X + b.X), (Double)(a.Y + b.Y), (Double)(a.Z + b.Z), (Double)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4d operator +(Vector4d a, Double b) { return new Vector4d((Double)(a.X + b), (Double)(a.Y + b), (Double)(a.Z + b), (Double)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4d operator +(Double a, Vector4d b) { return new Vector4d((Double)(a + b.X), (Double)(a + b.Y), (Double)(a + b.Z), (Double)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4d operator -(Vector4d a, Vector4d b) { return new Vector4d((Double)(a.X - b.X), (Double)(a.Y - b.Y), (Double)(a.Z - b.Z), (Double)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4d operator -(Vector4d a, Double b) { return new Vector4d((Double)(a.X - b), (Double)(a.Y - b), (Double)(a.Z - b), (Double)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4d operator -(Double a, Vector4d b) { return new Vector4d((Double)(a - b.X), (Double)(a - b.Y), (Double)(a - b.Z), (Double)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4d operator *(Vector4d a, Vector4d b) { return new Vector4d((Double)(a.X * b.X), (Double)(a.Y * b.Y), (Double)(a.Z * b.Z), (Double)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4d operator *(Vector4d a, Double b) { return new Vector4d((Double)(a.X * b), (Double)(a.Y * b), (Double)(a.Z * b), (Double)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4d operator *(Double a, Vector4d b) { return new Vector4d((Double)(a * b.X), (Double)(a * b.Y), (Double)(a * b.Z), (Double)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4d operator /(Vector4d a, Vector4d b) { return new Vector4d((Double)(a.X / b.X), (Double)(a.Y / b.Y), (Double)(a.Z / b.Z), (Double)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4d operator /(Vector4d a, Double b) { return new Vector4d((Double)(a.X / b), (Double)(a.Y / b), (Double)(a.Z / b), (Double)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4d operator /(Double a, Vector4d b) { return new Vector4d((Double)(a / b.X), (Double)(a / b.Y), (Double)(a / b.Z), (Double)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4d operator %(Vector4d a, Vector4d b) { return new Vector4d((Double)(a.X % b.X), (Double)(a.Y % b.Y), (Double)(a.Z % b.Z), (Double)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4d operator %(Vector4d a, Double b) { return new Vector4d((Double)(a.X % b), (Double)(a.Y % b), (Double)(a.Z % b), (Double)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4d operator %(Double a, Vector4d b) { return new Vector4d((Double)(a % b.X), (Double)(a % b.Y), (Double)(a % b.Z), (Double)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Int16"/> elements.</summary>
	[VectorTypeAttribute(typeof(Int16), 4, false)]
	public partial struct Vector4s : IEquatable<Vector4s>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Int16 MagnitudeSquared { get { return (Int16)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Int16 Product { get { return (Int16)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Int16 Sum { get { return (Int16)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4s One = new Vector4s((Int16)1, (Int16)1, (Int16)1, (Int16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4s UnitX = new Vector4s((Int16)1, (Int16)0, (Int16)0, (Int16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4s UnitY = new Vector4s((Int16)0, (Int16)1, (Int16)0, (Int16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4s UnitZ = new Vector4s((Int16)0, (Int16)0, (Int16)1, (Int16)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4s UnitW = new Vector4s((Int16)0, (Int16)0, (Int16)0, (Int16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4s( Vector3s xyz, Int16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4s(Int16 x,  Vector3s yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4s( ref  Vector3s xyz, Int16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4s(Int16 x,  ref  Vector3s yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4s( Vector2s xy, Int16 z, Int16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4s(Int16 x,  Vector2s yz, Int16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4s(Int16 x, Int16 y,  Vector2s zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4s( Vector2s xy,  Vector2s zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4s( ref  Vector2s xy, Int16 z, Int16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4s(Int16 x,  ref  Vector2s yz, Int16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4s(Int16 x, Int16 y,  ref  Vector2s zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4s( ref  Vector2s xy,  ref  Vector2s zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Int16 Dot( Vector4s other) { return (Int16)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Int16 Dot( ref  Vector4s other) { return (Int16)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4s Clamp( Vector4s min,  Vector4s max ) {
					Vector4s result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4s min,  ref  Vector4s max , out Vector4s result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4s other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int16 DistanceSquared( Vector4s other) {
					return (Int16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4s other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int16 DistanceSquared( ref  Vector4s other) {
					return (Int16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4s"/>.</summary>
		public Int16 X;
			/// <summary>The second axis of the <see cref="Vector4s"/>.</summary>
		public Int16 Y;
			/// <summary>The third axis of the <see cref="Vector4s"/>.</summary>
		public Int16 Z;
			/// <summary>The fourth axis of the <see cref="Vector4s"/>.</summary>
		public Int16 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4s"/>.</summary>
	public static readonly Vector4s Zero = new Vector4s((Int16)0, (Int16)0, (Int16)0, (Int16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4s"/> from the provided values for each factor.</summary>
	public Vector4s(Int16 x, Int16 y, Int16 z, Int16 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4s"/> from a list.</summary>
	public Vector4s(IList<Int16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4s"/> from a single scalar that is applied to all factors.</summary>
	public Vector4s(Int16 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4s"/> has equal factors as the other <see cref="Vector4s"/>.</summary>
	public bool Equals(Vector4s other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4s"/> of the same type, get whether this <see cref="Vector4s"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4s)
			return Equals((Vector4s)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4s"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4s"/> to a string of the form "Vector4s(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4s"/> to a string of the form "Vector4s(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4s(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4s"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4s"/> values are equal.</summary>
	public static bool operator ==(Vector4s a, Vector4s b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4s"/> values are unequal.</summary>
	public static bool operator !=(Vector4s a, Vector4s b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4s"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4s a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4s"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4s a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4s a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4s a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4s a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4s a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4s a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4s a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4s a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4s a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4s a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4s a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4s a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4s a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4s"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4s a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3s(Vector4s a) {
						return new Vector3s(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2s(Vector4s a) {
						return new Vector2s(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4s operator +(Vector4s a) { return new Vector4s((Int16)(+a.X), (Int16)(+a.Y), (Int16)(+a.Z), (Int16)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4s operator -(Vector4s a) { return new Vector4s((Int16)(-a.X), (Int16)(-a.Y), (Int16)(-a.Z), (Int16)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4s operator +(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X + b.X), (Int16)(a.Y + b.Y), (Int16)(a.Z + b.Z), (Int16)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4s operator +(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X + b), (Int16)(a.Y + b), (Int16)(a.Z + b), (Int16)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4s operator +(Int16 a, Vector4s b) { return new Vector4s((Int16)(a + b.X), (Int16)(a + b.Y), (Int16)(a + b.Z), (Int16)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4s operator -(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X - b.X), (Int16)(a.Y - b.Y), (Int16)(a.Z - b.Z), (Int16)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4s operator -(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X - b), (Int16)(a.Y - b), (Int16)(a.Z - b), (Int16)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4s operator -(Int16 a, Vector4s b) { return new Vector4s((Int16)(a - b.X), (Int16)(a - b.Y), (Int16)(a - b.Z), (Int16)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4s operator *(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X * b.X), (Int16)(a.Y * b.Y), (Int16)(a.Z * b.Z), (Int16)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4s operator *(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X * b), (Int16)(a.Y * b), (Int16)(a.Z * b), (Int16)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4s operator *(Int16 a, Vector4s b) { return new Vector4s((Int16)(a * b.X), (Int16)(a * b.Y), (Int16)(a * b.Z), (Int16)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4s operator /(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X / b.X), (Int16)(a.Y / b.Y), (Int16)(a.Z / b.Z), (Int16)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4s operator /(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X / b), (Int16)(a.Y / b), (Int16)(a.Z / b), (Int16)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4s operator /(Int16 a, Vector4s b) { return new Vector4s((Int16)(a / b.X), (Int16)(a / b.Y), (Int16)(a / b.Z), (Int16)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4s operator %(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X % b.X), (Int16)(a.Y % b.Y), (Int16)(a.Z % b.Z), (Int16)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4s operator %(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X % b), (Int16)(a.Y % b), (Int16)(a.Z % b), (Int16)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4s operator %(Int16 a, Vector4s b) { return new Vector4s((Int16)(a % b.X), (Int16)(a % b.Y), (Int16)(a % b.Z), (Int16)(a % b.W)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector4s operator &(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X & b.X), (Int16)(a.Y & b.Y), (Int16)(a.Z & b.Z), (Int16)(a.W & b.W)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector4s operator &(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X & b), (Int16)(a.Y & b), (Int16)(a.Z & b), (Int16)(a.W & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector4s operator &(Int16 a, Vector4s b) { return new Vector4s((Int16)(a & b.X), (Int16)(a & b.Y), (Int16)(a & b.Z), (Int16)(a & b.W)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector4s operator |(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X | b.X), (Int16)(a.Y | b.Y), (Int16)(a.Z | b.Z), (Int16)(a.W | b.W)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector4s operator |(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X | b), (Int16)(a.Y | b), (Int16)(a.Z | b), (Int16)(a.W | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector4s operator |(Int16 a, Vector4s b) { return new Vector4s((Int16)(a | b.X), (Int16)(a | b.Y), (Int16)(a | b.Z), (Int16)(a | b.W)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector4s operator ^(Vector4s a, Vector4s b) { return new Vector4s((Int16)(a.X ^ b.X), (Int16)(a.Y ^ b.Y), (Int16)(a.Z ^ b.Z), (Int16)(a.W ^ b.W)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector4s operator ^(Vector4s a, Int16 b) { return new Vector4s((Int16)(a.X ^ b), (Int16)(a.Y ^ b), (Int16)(a.Z ^ b), (Int16)(a.W ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector4s operator ^(Int16 a, Vector4s b) { return new Vector4s((Int16)(a ^ b.X), (Int16)(a ^ b.Y), (Int16)(a ^ b.Z), (Int16)(a ^ b.W)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector4s operator <<(Vector4s a, int b) { return new Vector4s((Int16)(a.X << b), (Int16)(a.Y << b), (Int16)(a.Z << b), (Int16)(a.W << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector4s operator >>(Vector4s a, int b) { return new Vector4s((Int16)(a.X >> b), (Int16)(a.Y >> b), (Int16)(a.Z >> b), (Int16)(a.W >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="UInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(UInt16), 4, false)]
	public partial struct Vector4us : IEquatable<Vector4us>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public UInt16 MagnitudeSquared { get { return (UInt16)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public UInt16 Product { get { return (UInt16)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public UInt16 Sum { get { return (UInt16)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4us One = new Vector4us((UInt16)1, (UInt16)1, (UInt16)1, (UInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4us UnitX = new Vector4us((UInt16)1, (UInt16)0, (UInt16)0, (UInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4us UnitY = new Vector4us((UInt16)0, (UInt16)1, (UInt16)0, (UInt16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4us UnitZ = new Vector4us((UInt16)0, (UInt16)0, (UInt16)1, (UInt16)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4us UnitW = new Vector4us((UInt16)0, (UInt16)0, (UInt16)0, (UInt16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4us( Vector3us xyz, UInt16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4us(UInt16 x,  Vector3us yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4us( ref  Vector3us xyz, UInt16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4us(UInt16 x,  ref  Vector3us yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4us( Vector2us xy, UInt16 z, UInt16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4us(UInt16 x,  Vector2us yz, UInt16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4us(UInt16 x, UInt16 y,  Vector2us zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4us( Vector2us xy,  Vector2us zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4us( ref  Vector2us xy, UInt16 z, UInt16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4us(UInt16 x,  ref  Vector2us yz, UInt16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4us(UInt16 x, UInt16 y,  ref  Vector2us zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4us( ref  Vector2us xy,  ref  Vector2us zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public UInt16 Dot( Vector4us other) { return (UInt16)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public UInt16 Dot( ref  Vector4us other) { return (UInt16)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4us Clamp( Vector4us min,  Vector4us max ) {
					Vector4us result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4us min,  ref  Vector4us max , out Vector4us result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4us other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt16 DistanceSquared( Vector4us other) {
					return (UInt16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4us other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt16 DistanceSquared( ref  Vector4us other) {
					return (UInt16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4us"/>.</summary>
		public UInt16 X;
			/// <summary>The second axis of the <see cref="Vector4us"/>.</summary>
		public UInt16 Y;
			/// <summary>The third axis of the <see cref="Vector4us"/>.</summary>
		public UInt16 Z;
			/// <summary>The fourth axis of the <see cref="Vector4us"/>.</summary>
		public UInt16 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4us"/>.</summary>
	public static readonly Vector4us Zero = new Vector4us((UInt16)0, (UInt16)0, (UInt16)0, (UInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4us"/> from the provided values for each factor.</summary>
	public Vector4us(UInt16 x, UInt16 y, UInt16 z, UInt16 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4us"/> from a list.</summary>
	public Vector4us(IList<UInt16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4us"/> from a single scalar that is applied to all factors.</summary>
	public Vector4us(UInt16 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4us"/> has equal factors as the other <see cref="Vector4us"/>.</summary>
	public bool Equals(Vector4us other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4us"/> of the same type, get whether this <see cref="Vector4us"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4us)
			return Equals((Vector4us)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4us"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4us"/> to a string of the form "Vector4us(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4us"/> to a string of the form "Vector4us(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4us(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4us"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4us"/> values are equal.</summary>
	public static bool operator ==(Vector4us a, Vector4us b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4us"/> values are unequal.</summary>
	public static bool operator !=(Vector4us a, Vector4us b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4us"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4us a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4us"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4us a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4us a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4us a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4us a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4us a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4us a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4us a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4us a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4us a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4us a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4us a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4us a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4us a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4us"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4us a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3us(Vector4us a) {
						return new Vector3us(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2us(Vector4us a) {
						return new Vector2us(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4us operator +(Vector4us a) { return new Vector4us((UInt16)(+a.X), (UInt16)(+a.Y), (UInt16)(+a.Z), (UInt16)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4us operator -(Vector4us a) { return new Vector4us((UInt16)(-a.X), (UInt16)(-a.Y), (UInt16)(-a.Z), (UInt16)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4us operator +(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X + b.X), (UInt16)(a.Y + b.Y), (UInt16)(a.Z + b.Z), (UInt16)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4us operator +(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X + b), (UInt16)(a.Y + b), (UInt16)(a.Z + b), (UInt16)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4us operator +(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a + b.X), (UInt16)(a + b.Y), (UInt16)(a + b.Z), (UInt16)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4us operator -(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X - b.X), (UInt16)(a.Y - b.Y), (UInt16)(a.Z - b.Z), (UInt16)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4us operator -(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X - b), (UInt16)(a.Y - b), (UInt16)(a.Z - b), (UInt16)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4us operator -(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a - b.X), (UInt16)(a - b.Y), (UInt16)(a - b.Z), (UInt16)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4us operator *(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X * b.X), (UInt16)(a.Y * b.Y), (UInt16)(a.Z * b.Z), (UInt16)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4us operator *(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X * b), (UInt16)(a.Y * b), (UInt16)(a.Z * b), (UInt16)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4us operator *(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a * b.X), (UInt16)(a * b.Y), (UInt16)(a * b.Z), (UInt16)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4us operator /(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X / b.X), (UInt16)(a.Y / b.Y), (UInt16)(a.Z / b.Z), (UInt16)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4us operator /(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X / b), (UInt16)(a.Y / b), (UInt16)(a.Z / b), (UInt16)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4us operator /(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a / b.X), (UInt16)(a / b.Y), (UInt16)(a / b.Z), (UInt16)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4us operator %(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X % b.X), (UInt16)(a.Y % b.Y), (UInt16)(a.Z % b.Z), (UInt16)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4us operator %(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X % b), (UInt16)(a.Y % b), (UInt16)(a.Z % b), (UInt16)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4us operator %(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a % b.X), (UInt16)(a % b.Y), (UInt16)(a % b.Z), (UInt16)(a % b.W)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector4us operator &(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X & b.X), (UInt16)(a.Y & b.Y), (UInt16)(a.Z & b.Z), (UInt16)(a.W & b.W)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector4us operator &(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X & b), (UInt16)(a.Y & b), (UInt16)(a.Z & b), (UInt16)(a.W & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector4us operator &(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a & b.X), (UInt16)(a & b.Y), (UInt16)(a & b.Z), (UInt16)(a & b.W)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector4us operator |(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X | b.X), (UInt16)(a.Y | b.Y), (UInt16)(a.Z | b.Z), (UInt16)(a.W | b.W)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector4us operator |(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X | b), (UInt16)(a.Y | b), (UInt16)(a.Z | b), (UInt16)(a.W | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector4us operator |(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a | b.X), (UInt16)(a | b.Y), (UInt16)(a | b.Z), (UInt16)(a | b.W)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector4us operator ^(Vector4us a, Vector4us b) { return new Vector4us((UInt16)(a.X ^ b.X), (UInt16)(a.Y ^ b.Y), (UInt16)(a.Z ^ b.Z), (UInt16)(a.W ^ b.W)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector4us operator ^(Vector4us a, UInt16 b) { return new Vector4us((UInt16)(a.X ^ b), (UInt16)(a.Y ^ b), (UInt16)(a.Z ^ b), (UInt16)(a.W ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector4us operator ^(UInt16 a, Vector4us b) { return new Vector4us((UInt16)(a ^ b.X), (UInt16)(a ^ b.Y), (UInt16)(a ^ b.Z), (UInt16)(a ^ b.W)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector4us operator <<(Vector4us a, int b) { return new Vector4us((UInt16)(a.X << b), (UInt16)(a.Y << b), (UInt16)(a.Z << b), (UInt16)(a.W << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector4us operator >>(Vector4us a, int b) { return new Vector4us((UInt16)(a.X >> b), (UInt16)(a.Y >> b), (UInt16)(a.Z >> b), (UInt16)(a.W >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Int32"/> elements.</summary>
	[VectorTypeAttribute(typeof(Int32), 4, false)]
	public partial struct Vector4i : IEquatable<Vector4i>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Int32 MagnitudeSquared { get { return (Int32)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Int32 Product { get { return (Int32)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Int32 Sum { get { return (Int32)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4i One = new Vector4i((Int32)1, (Int32)1, (Int32)1, (Int32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4i UnitX = new Vector4i((Int32)1, (Int32)0, (Int32)0, (Int32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4i UnitY = new Vector4i((Int32)0, (Int32)1, (Int32)0, (Int32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4i UnitZ = new Vector4i((Int32)0, (Int32)0, (Int32)1, (Int32)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4i UnitW = new Vector4i((Int32)0, (Int32)0, (Int32)0, (Int32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4i( Vector3i xyz, Int32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4i(Int32 x,  Vector3i yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4i( ref  Vector3i xyz, Int32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4i(Int32 x,  ref  Vector3i yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4i( Vector2i xy, Int32 z, Int32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4i(Int32 x,  Vector2i yz, Int32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4i(Int32 x, Int32 y,  Vector2i zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4i( Vector2i xy,  Vector2i zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4i( ref  Vector2i xy, Int32 z, Int32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4i(Int32 x,  ref  Vector2i yz, Int32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4i(Int32 x, Int32 y,  ref  Vector2i zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4i( ref  Vector2i xy,  ref  Vector2i zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Int32 Dot( Vector4i other) { return (Int32)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Int32 Dot( ref  Vector4i other) { return (Int32)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4i Clamp( Vector4i min,  Vector4i max ) {
					Vector4i result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4i min,  ref  Vector4i max , out Vector4i result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4i other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int32 DistanceSquared( Vector4i other) {
					return (Int32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4i other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Int32 DistanceSquared( ref  Vector4i other) {
					return (Int32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4i"/>.</summary>
		public Int32 X;
			/// <summary>The second axis of the <see cref="Vector4i"/>.</summary>
		public Int32 Y;
			/// <summary>The third axis of the <see cref="Vector4i"/>.</summary>
		public Int32 Z;
			/// <summary>The fourth axis of the <see cref="Vector4i"/>.</summary>
		public Int32 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4i"/>.</summary>
	public static readonly Vector4i Zero = new Vector4i((Int32)0, (Int32)0, (Int32)0, (Int32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4i"/> from the provided values for each factor.</summary>
	public Vector4i(Int32 x, Int32 y, Int32 z, Int32 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4i"/> from a list.</summary>
	public Vector4i(IList<Int32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4i"/> from a single scalar that is applied to all factors.</summary>
	public Vector4i(Int32 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4i"/> has equal factors as the other <see cref="Vector4i"/>.</summary>
	public bool Equals(Vector4i other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4i"/> of the same type, get whether this <see cref="Vector4i"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4i)
			return Equals((Vector4i)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4i"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4i"/> to a string of the form "Vector4i(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4i"/> to a string of the form "Vector4i(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4i(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4i"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4i"/> values are equal.</summary>
	public static bool operator ==(Vector4i a, Vector4i b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4i"/> values are unequal.</summary>
	public static bool operator !=(Vector4i a, Vector4i b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4i"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4i a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4i"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4i a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4i a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4i a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4i a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4i a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4i a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4i a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4i a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4i a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4i a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4i a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4i a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4i a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4i"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4i a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3i(Vector4i a) {
						return new Vector3i(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2i(Vector4i a) {
						return new Vector2i(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4i operator +(Vector4i a) { return new Vector4i((Int32)(+a.X), (Int32)(+a.Y), (Int32)(+a.Z), (Int32)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4i operator -(Vector4i a) { return new Vector4i((Int32)(-a.X), (Int32)(-a.Y), (Int32)(-a.Z), (Int32)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4i operator +(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X + b.X), (Int32)(a.Y + b.Y), (Int32)(a.Z + b.Z), (Int32)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4i operator +(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X + b), (Int32)(a.Y + b), (Int32)(a.Z + b), (Int32)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4i operator +(Int32 a, Vector4i b) { return new Vector4i((Int32)(a + b.X), (Int32)(a + b.Y), (Int32)(a + b.Z), (Int32)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4i operator -(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X - b.X), (Int32)(a.Y - b.Y), (Int32)(a.Z - b.Z), (Int32)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4i operator -(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X - b), (Int32)(a.Y - b), (Int32)(a.Z - b), (Int32)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4i operator -(Int32 a, Vector4i b) { return new Vector4i((Int32)(a - b.X), (Int32)(a - b.Y), (Int32)(a - b.Z), (Int32)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4i operator *(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X * b.X), (Int32)(a.Y * b.Y), (Int32)(a.Z * b.Z), (Int32)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4i operator *(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X * b), (Int32)(a.Y * b), (Int32)(a.Z * b), (Int32)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4i operator *(Int32 a, Vector4i b) { return new Vector4i((Int32)(a * b.X), (Int32)(a * b.Y), (Int32)(a * b.Z), (Int32)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4i operator /(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X / b.X), (Int32)(a.Y / b.Y), (Int32)(a.Z / b.Z), (Int32)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4i operator /(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X / b), (Int32)(a.Y / b), (Int32)(a.Z / b), (Int32)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4i operator /(Int32 a, Vector4i b) { return new Vector4i((Int32)(a / b.X), (Int32)(a / b.Y), (Int32)(a / b.Z), (Int32)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4i operator %(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X % b.X), (Int32)(a.Y % b.Y), (Int32)(a.Z % b.Z), (Int32)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4i operator %(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X % b), (Int32)(a.Y % b), (Int32)(a.Z % b), (Int32)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4i operator %(Int32 a, Vector4i b) { return new Vector4i((Int32)(a % b.X), (Int32)(a % b.Y), (Int32)(a % b.Z), (Int32)(a % b.W)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector4i operator &(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X & b.X), (Int32)(a.Y & b.Y), (Int32)(a.Z & b.Z), (Int32)(a.W & b.W)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector4i operator &(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X & b), (Int32)(a.Y & b), (Int32)(a.Z & b), (Int32)(a.W & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector4i operator &(Int32 a, Vector4i b) { return new Vector4i((Int32)(a & b.X), (Int32)(a & b.Y), (Int32)(a & b.Z), (Int32)(a & b.W)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector4i operator |(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X | b.X), (Int32)(a.Y | b.Y), (Int32)(a.Z | b.Z), (Int32)(a.W | b.W)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector4i operator |(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X | b), (Int32)(a.Y | b), (Int32)(a.Z | b), (Int32)(a.W | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector4i operator |(Int32 a, Vector4i b) { return new Vector4i((Int32)(a | b.X), (Int32)(a | b.Y), (Int32)(a | b.Z), (Int32)(a | b.W)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector4i operator ^(Vector4i a, Vector4i b) { return new Vector4i((Int32)(a.X ^ b.X), (Int32)(a.Y ^ b.Y), (Int32)(a.Z ^ b.Z), (Int32)(a.W ^ b.W)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector4i operator ^(Vector4i a, Int32 b) { return new Vector4i((Int32)(a.X ^ b), (Int32)(a.Y ^ b), (Int32)(a.Z ^ b), (Int32)(a.W ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector4i operator ^(Int32 a, Vector4i b) { return new Vector4i((Int32)(a ^ b.X), (Int32)(a ^ b.Y), (Int32)(a ^ b.Z), (Int32)(a ^ b.W)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector4i operator <<(Vector4i a, int b) { return new Vector4i((Int32)(a.X << b), (Int32)(a.Y << b), (Int32)(a.Z << b), (Int32)(a.W << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector4i operator >>(Vector4i a, int b) { return new Vector4i((Int32)(a.X >> b), (Int32)(a.Y >> b), (Int32)(a.Z >> b), (Int32)(a.W >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="UInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(UInt32), 4, false)]
	public partial struct Vector4ui : IEquatable<Vector4ui>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public UInt32 MagnitudeSquared { get { return (UInt32)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public UInt32 Product { get { return (UInt32)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public UInt32 Sum { get { return (UInt32)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4ui One = new Vector4ui((UInt32)1, (UInt32)1, (UInt32)1, (UInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4ui UnitX = new Vector4ui((UInt32)1, (UInt32)0, (UInt32)0, (UInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4ui UnitY = new Vector4ui((UInt32)0, (UInt32)1, (UInt32)0, (UInt32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4ui UnitZ = new Vector4ui((UInt32)0, (UInt32)0, (UInt32)1, (UInt32)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4ui UnitW = new Vector4ui((UInt32)0, (UInt32)0, (UInt32)0, (UInt32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4ui( Vector3ui xyz, UInt32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4ui(UInt32 x,  Vector3ui yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4ui( ref  Vector3ui xyz, UInt32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4ui(UInt32 x,  ref  Vector3ui yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4ui( Vector2ui xy, UInt32 z, UInt32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ui(UInt32 x,  Vector2ui yz, UInt32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ui(UInt32 x, UInt32 y,  Vector2ui zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ui( Vector2ui xy,  Vector2ui zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4ui( ref  Vector2ui xy, UInt32 z, UInt32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ui(UInt32 x,  ref  Vector2ui yz, UInt32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ui(UInt32 x, UInt32 y,  ref  Vector2ui zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ui( ref  Vector2ui xy,  ref  Vector2ui zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public UInt32 Dot( Vector4ui other) { return (UInt32)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public UInt32 Dot( ref  Vector4ui other) { return (UInt32)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4ui Clamp( Vector4ui min,  Vector4ui max ) {
					Vector4ui result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4ui min,  ref  Vector4ui max , out Vector4ui result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4ui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt32 DistanceSquared( Vector4ui other) {
					return (UInt32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4ui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public UInt32 DistanceSquared( ref  Vector4ui other) {
					return (UInt32)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4ui"/>.</summary>
		public UInt32 X;
			/// <summary>The second axis of the <see cref="Vector4ui"/>.</summary>
		public UInt32 Y;
			/// <summary>The third axis of the <see cref="Vector4ui"/>.</summary>
		public UInt32 Z;
			/// <summary>The fourth axis of the <see cref="Vector4ui"/>.</summary>
		public UInt32 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4ui"/>.</summary>
	public static readonly Vector4ui Zero = new Vector4ui((UInt32)0, (UInt32)0, (UInt32)0, (UInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4ui"/> from the provided values for each factor.</summary>
	public Vector4ui(UInt32 x, UInt32 y, UInt32 z, UInt32 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4ui"/> from a list.</summary>
	public Vector4ui(IList<UInt32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4ui"/> from a single scalar that is applied to all factors.</summary>
	public Vector4ui(UInt32 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4ui"/> has equal factors as the other <see cref="Vector4ui"/>.</summary>
	public bool Equals(Vector4ui other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4ui"/> of the same type, get whether this <see cref="Vector4ui"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4ui)
			return Equals((Vector4ui)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4ui"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4ui"/> to a string of the form "Vector4ui(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4ui"/> to a string of the form "Vector4ui(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4ui(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4ui"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4ui"/> values are equal.</summary>
	public static bool operator ==(Vector4ui a, Vector4ui b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4ui"/> values are unequal.</summary>
	public static bool operator !=(Vector4ui a, Vector4ui b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4ui"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4ui a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4ui"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4ui a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4ui a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4ui a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4ui a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4ui a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4ui a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4ui a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4ui a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4ui a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4ui a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4ui a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4ui a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4ui a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ui"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4ui a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3ui(Vector4ui a) {
						return new Vector3ui(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2ui(Vector4ui a) {
						return new Vector2ui(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4ui operator +(Vector4ui a) { return new Vector4ui((UInt32)(+a.X), (UInt32)(+a.Y), (UInt32)(+a.Z), (UInt32)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4ui operator -(Vector4ui a) { return new Vector4ui((UInt32)(-a.X), (UInt32)(-a.Y), (UInt32)(-a.Z), (UInt32)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4ui operator +(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X + b.X), (UInt32)(a.Y + b.Y), (UInt32)(a.Z + b.Z), (UInt32)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4ui operator +(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X + b), (UInt32)(a.Y + b), (UInt32)(a.Z + b), (UInt32)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4ui operator +(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a + b.X), (UInt32)(a + b.Y), (UInt32)(a + b.Z), (UInt32)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4ui operator -(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X - b.X), (UInt32)(a.Y - b.Y), (UInt32)(a.Z - b.Z), (UInt32)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4ui operator -(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X - b), (UInt32)(a.Y - b), (UInt32)(a.Z - b), (UInt32)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4ui operator -(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a - b.X), (UInt32)(a - b.Y), (UInt32)(a - b.Z), (UInt32)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4ui operator *(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X * b.X), (UInt32)(a.Y * b.Y), (UInt32)(a.Z * b.Z), (UInt32)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4ui operator *(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X * b), (UInt32)(a.Y * b), (UInt32)(a.Z * b), (UInt32)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4ui operator *(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a * b.X), (UInt32)(a * b.Y), (UInt32)(a * b.Z), (UInt32)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4ui operator /(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X / b.X), (UInt32)(a.Y / b.Y), (UInt32)(a.Z / b.Z), (UInt32)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4ui operator /(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X / b), (UInt32)(a.Y / b), (UInt32)(a.Z / b), (UInt32)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4ui operator /(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a / b.X), (UInt32)(a / b.Y), (UInt32)(a / b.Z), (UInt32)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4ui operator %(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X % b.X), (UInt32)(a.Y % b.Y), (UInt32)(a.Z % b.Z), (UInt32)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4ui operator %(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X % b), (UInt32)(a.Y % b), (UInt32)(a.Z % b), (UInt32)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4ui operator %(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a % b.X), (UInt32)(a % b.Y), (UInt32)(a % b.Z), (UInt32)(a % b.W)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector4ui operator &(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X & b.X), (UInt32)(a.Y & b.Y), (UInt32)(a.Z & b.Z), (UInt32)(a.W & b.W)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector4ui operator &(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X & b), (UInt32)(a.Y & b), (UInt32)(a.Z & b), (UInt32)(a.W & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector4ui operator &(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a & b.X), (UInt32)(a & b.Y), (UInt32)(a & b.Z), (UInt32)(a & b.W)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector4ui operator |(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X | b.X), (UInt32)(a.Y | b.Y), (UInt32)(a.Z | b.Z), (UInt32)(a.W | b.W)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector4ui operator |(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X | b), (UInt32)(a.Y | b), (UInt32)(a.Z | b), (UInt32)(a.W | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector4ui operator |(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a | b.X), (UInt32)(a | b.Y), (UInt32)(a | b.Z), (UInt32)(a | b.W)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector4ui operator ^(Vector4ui a, Vector4ui b) { return new Vector4ui((UInt32)(a.X ^ b.X), (UInt32)(a.Y ^ b.Y), (UInt32)(a.Z ^ b.Z), (UInt32)(a.W ^ b.W)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector4ui operator ^(Vector4ui a, UInt32 b) { return new Vector4ui((UInt32)(a.X ^ b), (UInt32)(a.Y ^ b), (UInt32)(a.Z ^ b), (UInt32)(a.W ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector4ui operator ^(UInt32 a, Vector4ui b) { return new Vector4ui((UInt32)(a ^ b.X), (UInt32)(a ^ b.Y), (UInt32)(a ^ b.Z), (UInt32)(a ^ b.W)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector4ui operator <<(Vector4ui a, int b) { return new Vector4ui((UInt32)(a.X << b), (UInt32)(a.Y << b), (UInt32)(a.Z << b), (UInt32)(a.W << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector4ui operator >>(Vector4ui a, int b) { return new Vector4ui((UInt32)(a.X >> b), (UInt32)(a.Y >> b), (UInt32)(a.Z >> b), (UInt32)(a.W >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Byte"/> elements.</summary>
	[VectorTypeAttribute(typeof(Byte), 4, false)]
	public partial struct Vector4b : IEquatable<Vector4b>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public int MagnitudeSquared { get { return (int)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Byte Product { get { return (Byte)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Byte Sum { get { return (Byte)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4b One = new Vector4b((Byte)1, (Byte)1, (Byte)1, (Byte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4b UnitX = new Vector4b((Byte)1, (Byte)0, (Byte)0, (Byte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4b UnitY = new Vector4b((Byte)0, (Byte)1, (Byte)0, (Byte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4b UnitZ = new Vector4b((Byte)0, (Byte)0, (Byte)1, (Byte)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4b UnitW = new Vector4b((Byte)0, (Byte)0, (Byte)0, (Byte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4b( Vector3b xyz, Byte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4b(Byte x,  Vector3b yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4b( ref  Vector3b xyz, Byte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4b(Byte x,  ref  Vector3b yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4b( Vector2b xy, Byte z, Byte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4b(Byte x,  Vector2b yz, Byte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4b(Byte x, Byte y,  Vector2b zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4b( Vector2b xy,  Vector2b zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4b( ref  Vector2b xy, Byte z, Byte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4b(Byte x,  ref  Vector2b yz, Byte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4b(Byte x, Byte y,  ref  Vector2b zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4b( ref  Vector2b xy,  ref  Vector2b zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public int Dot( Vector4b other) { return (int)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public int Dot( ref  Vector4b other) { return (int)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4b Clamp( Vector4b min,  Vector4b max ) {
					Vector4b result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4b min,  ref  Vector4b max , out Vector4b result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4b other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( Vector4b other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4b other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( ref  Vector4b other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4b"/>.</summary>
		public Byte X;
			/// <summary>The second axis of the <see cref="Vector4b"/>.</summary>
		public Byte Y;
			/// <summary>The third axis of the <see cref="Vector4b"/>.</summary>
		public Byte Z;
			/// <summary>The fourth axis of the <see cref="Vector4b"/>.</summary>
		public Byte W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4b"/>.</summary>
	public static readonly Vector4b Zero = new Vector4b((Byte)0, (Byte)0, (Byte)0, (Byte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4b"/> from the provided values for each factor.</summary>
	public Vector4b(Byte x, Byte y, Byte z, Byte w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4b"/> from a list.</summary>
	public Vector4b(IList<Byte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4b"/> from a single scalar that is applied to all factors.</summary>
	public Vector4b(Byte value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4b"/> has equal factors as the other <see cref="Vector4b"/>.</summary>
	public bool Equals(Vector4b other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4b"/> of the same type, get whether this <see cref="Vector4b"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4b)
			return Equals((Vector4b)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4b"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4b"/> to a string of the form "Vector4b(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4b"/> to a string of the form "Vector4b(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4b(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4b"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4b"/> values are equal.</summary>
	public static bool operator ==(Vector4b a, Vector4b b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4b"/> values are unequal.</summary>
	public static bool operator !=(Vector4b a, Vector4b b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4b"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4b a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4b"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4b a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4b a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4b a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4b a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4b a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4b a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4b a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4b a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4b a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4b a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4b a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4b a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4b a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4b"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4b a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3b(Vector4b a) {
						return new Vector3b(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2b(Vector4b a) {
						return new Vector2b(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4b operator +(Vector4b a) { return new Vector4b((Byte)(+a.X), (Byte)(+a.Y), (Byte)(+a.Z), (Byte)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4b operator -(Vector4b a) { return new Vector4b((Byte)(-a.X), (Byte)(-a.Y), (Byte)(-a.Z), (Byte)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4b operator +(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X + b.X), (Byte)(a.Y + b.Y), (Byte)(a.Z + b.Z), (Byte)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4b operator +(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X + b), (Byte)(a.Y + b), (Byte)(a.Z + b), (Byte)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4b operator +(Byte a, Vector4b b) { return new Vector4b((Byte)(a + b.X), (Byte)(a + b.Y), (Byte)(a + b.Z), (Byte)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4b operator -(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X - b.X), (Byte)(a.Y - b.Y), (Byte)(a.Z - b.Z), (Byte)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4b operator -(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X - b), (Byte)(a.Y - b), (Byte)(a.Z - b), (Byte)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4b operator -(Byte a, Vector4b b) { return new Vector4b((Byte)(a - b.X), (Byte)(a - b.Y), (Byte)(a - b.Z), (Byte)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4b operator *(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X * b.X), (Byte)(a.Y * b.Y), (Byte)(a.Z * b.Z), (Byte)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4b operator *(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X * b), (Byte)(a.Y * b), (Byte)(a.Z * b), (Byte)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4b operator *(Byte a, Vector4b b) { return new Vector4b((Byte)(a * b.X), (Byte)(a * b.Y), (Byte)(a * b.Z), (Byte)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4b operator /(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X / b.X), (Byte)(a.Y / b.Y), (Byte)(a.Z / b.Z), (Byte)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4b operator /(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X / b), (Byte)(a.Y / b), (Byte)(a.Z / b), (Byte)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4b operator /(Byte a, Vector4b b) { return new Vector4b((Byte)(a / b.X), (Byte)(a / b.Y), (Byte)(a / b.Z), (Byte)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4b operator %(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X % b.X), (Byte)(a.Y % b.Y), (Byte)(a.Z % b.Z), (Byte)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4b operator %(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X % b), (Byte)(a.Y % b), (Byte)(a.Z % b), (Byte)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4b operator %(Byte a, Vector4b b) { return new Vector4b((Byte)(a % b.X), (Byte)(a % b.Y), (Byte)(a % b.Z), (Byte)(a % b.W)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector4b operator &(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X & b.X), (Byte)(a.Y & b.Y), (Byte)(a.Z & b.Z), (Byte)(a.W & b.W)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector4b operator &(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X & b), (Byte)(a.Y & b), (Byte)(a.Z & b), (Byte)(a.W & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector4b operator &(Byte a, Vector4b b) { return new Vector4b((Byte)(a & b.X), (Byte)(a & b.Y), (Byte)(a & b.Z), (Byte)(a & b.W)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector4b operator |(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X | b.X), (Byte)(a.Y | b.Y), (Byte)(a.Z | b.Z), (Byte)(a.W | b.W)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector4b operator |(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X | b), (Byte)(a.Y | b), (Byte)(a.Z | b), (Byte)(a.W | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector4b operator |(Byte a, Vector4b b) { return new Vector4b((Byte)(a | b.X), (Byte)(a | b.Y), (Byte)(a | b.Z), (Byte)(a | b.W)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector4b operator ^(Vector4b a, Vector4b b) { return new Vector4b((Byte)(a.X ^ b.X), (Byte)(a.Y ^ b.Y), (Byte)(a.Z ^ b.Z), (Byte)(a.W ^ b.W)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector4b operator ^(Vector4b a, Byte b) { return new Vector4b((Byte)(a.X ^ b), (Byte)(a.Y ^ b), (Byte)(a.Z ^ b), (Byte)(a.W ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector4b operator ^(Byte a, Vector4b b) { return new Vector4b((Byte)(a ^ b.X), (Byte)(a ^ b.Y), (Byte)(a ^ b.Z), (Byte)(a ^ b.W)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector4b operator <<(Vector4b a, int b) { return new Vector4b((Byte)(a.X << b), (Byte)(a.Y << b), (Byte)(a.Z << b), (Byte)(a.W << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector4b operator >>(Vector4b a, int b) { return new Vector4b((Byte)(a.X >> b), (Byte)(a.Y >> b), (Byte)(a.Z >> b), (Byte)(a.W >> b)); }
					
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedByte), 4, false)]
	public partial struct Vector4nb : IEquatable<Vector4nb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4nb Normalized { get { Vector4nb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedByte Product { get { return (NormalizedByte)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedByte Sum { get { return (NormalizedByte)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4nb(double x, double y, double z, double w) : this((NormalizedByte)x, (NormalizedByte)y, (NormalizedByte)z, (NormalizedByte)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nb( Vector4d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z, (NormalizedByte)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nb( ref  Vector4d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z, (NormalizedByte)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4nb One = new Vector4nb((NormalizedByte)1, (NormalizedByte)1, (NormalizedByte)1, (NormalizedByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4nb UnitX = new Vector4nb((NormalizedByte)1, (NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4nb UnitY = new Vector4nb((NormalizedByte)0, (NormalizedByte)1, (NormalizedByte)0, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4nb UnitZ = new Vector4nb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)1, (NormalizedByte)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4nb UnitW = new Vector4nb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nb( Vector3nb xyz, NormalizedByte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nb(NormalizedByte x,  Vector3nb yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4nb( ref  Vector3nb xyz, NormalizedByte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nb(NormalizedByte x,  ref  Vector3nb yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nb( Vector2nb xy, NormalizedByte z, NormalizedByte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nb(NormalizedByte x,  Vector2nb yz, NormalizedByte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nb(NormalizedByte x, NormalizedByte y,  Vector2nb zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nb( Vector2nb xy,  Vector2nb zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4nb( ref  Vector2nb xy, NormalizedByte z, NormalizedByte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nb(NormalizedByte x,  ref  Vector2nb yz, NormalizedByte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nb(NormalizedByte x, NormalizedByte y,  ref  Vector2nb zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nb( ref  Vector2nb xy,  ref  Vector2nb zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4nb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4nb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4nb Clamp( Vector4nb min,  Vector4nb max ) {
					Vector4nb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4nb min,  ref  Vector4nb max , out Vector4nb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4nb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4nb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4nb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4nb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4nb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedByte)(X * m);  result.Y = (NormalizedByte)(Y * m);  result.Z = (NormalizedByte)(Z * m);  result.W = (NormalizedByte)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedByte m = (NormalizedByte)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4nb"/>.</summary>
		public NormalizedByte X;
			/// <summary>The second axis of the <see cref="Vector4nb"/>.</summary>
		public NormalizedByte Y;
			/// <summary>The third axis of the <see cref="Vector4nb"/>.</summary>
		public NormalizedByte Z;
			/// <summary>The fourth axis of the <see cref="Vector4nb"/>.</summary>
		public NormalizedByte W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4nb"/>.</summary>
	public static readonly Vector4nb Zero = new Vector4nb((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4nb"/> from the provided values for each factor.</summary>
	public Vector4nb(NormalizedByte x, NormalizedByte y, NormalizedByte z, NormalizedByte w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4nb"/> from a list.</summary>
	public Vector4nb(IList<NormalizedByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4nb"/> from a single scalar that is applied to all factors.</summary>
	public Vector4nb(NormalizedByte value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4nb"/> has equal factors as the other <see cref="Vector4nb"/>.</summary>
	public bool Equals(Vector4nb other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4nb"/> of the same type, get whether this <see cref="Vector4nb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4nb)
			return Equals((Vector4nb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4nb"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4nb"/> to a string of the form "Vector4nb(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4nb"/> to a string of the form "Vector4nb(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4nb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4nb"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4nb"/> values are equal.</summary>
	public static bool operator ==(Vector4nb a, Vector4nb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4nb"/> values are unequal.</summary>
	public static bool operator !=(Vector4nb a, Vector4nb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4nb"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4nb a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4nb"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4nb a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4nb a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4nb a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4nb a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4nb a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4nb a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4nb a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4nb a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4nb a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4nb a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4nb a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4nb a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4nb a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nb"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4nb a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3nb(Vector4nb a) {
						return new Vector3nb(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nb(Vector4nb a) {
						return new Vector2nb(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4nb operator +(Vector4nb a) { return new Vector4nb((NormalizedByte)(+a.X), (NormalizedByte)(+a.Y), (NormalizedByte)(+a.Z), (NormalizedByte)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4nb operator -(Vector4nb a) { return new Vector4nb((NormalizedByte)(-a.X), (NormalizedByte)(-a.Y), (NormalizedByte)(-a.Z), (NormalizedByte)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4nb operator +(Vector4nb a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a.X + b.X), (NormalizedByte)(a.Y + b.Y), (NormalizedByte)(a.Z + b.Z), (NormalizedByte)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4nb operator +(Vector4nb a, NormalizedByte b) { return new Vector4nb((NormalizedByte)(a.X + b), (NormalizedByte)(a.Y + b), (NormalizedByte)(a.Z + b), (NormalizedByte)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4nb operator +(NormalizedByte a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a + b.X), (NormalizedByte)(a + b.Y), (NormalizedByte)(a + b.Z), (NormalizedByte)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4nb operator -(Vector4nb a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a.X - b.X), (NormalizedByte)(a.Y - b.Y), (NormalizedByte)(a.Z - b.Z), (NormalizedByte)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4nb operator -(Vector4nb a, NormalizedByte b) { return new Vector4nb((NormalizedByte)(a.X - b), (NormalizedByte)(a.Y - b), (NormalizedByte)(a.Z - b), (NormalizedByte)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4nb operator -(NormalizedByte a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a - b.X), (NormalizedByte)(a - b.Y), (NormalizedByte)(a - b.Z), (NormalizedByte)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4nb operator *(Vector4nb a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a.X * b.X), (NormalizedByte)(a.Y * b.Y), (NormalizedByte)(a.Z * b.Z), (NormalizedByte)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4nb operator *(Vector4nb a, NormalizedByte b) { return new Vector4nb((NormalizedByte)(a.X * b), (NormalizedByte)(a.Y * b), (NormalizedByte)(a.Z * b), (NormalizedByte)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4nb operator *(NormalizedByte a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a * b.X), (NormalizedByte)(a * b.Y), (NormalizedByte)(a * b.Z), (NormalizedByte)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4nb operator /(Vector4nb a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a.X / b.X), (NormalizedByte)(a.Y / b.Y), (NormalizedByte)(a.Z / b.Z), (NormalizedByte)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4nb operator /(Vector4nb a, NormalizedByte b) { return new Vector4nb((NormalizedByte)(a.X / b), (NormalizedByte)(a.Y / b), (NormalizedByte)(a.Z / b), (NormalizedByte)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4nb operator /(NormalizedByte a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a / b.X), (NormalizedByte)(a / b.Y), (NormalizedByte)(a / b.Z), (NormalizedByte)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4nb operator %(Vector4nb a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a.X % b.X), (NormalizedByte)(a.Y % b.Y), (NormalizedByte)(a.Z % b.Z), (NormalizedByte)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4nb operator %(Vector4nb a, NormalizedByte b) { return new Vector4nb((NormalizedByte)(a.X % b), (NormalizedByte)(a.Y % b), (NormalizedByte)(a.Z % b), (NormalizedByte)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4nb operator %(NormalizedByte a, Vector4nb b) { return new Vector4nb((NormalizedByte)(a % b.X), (NormalizedByte)(a % b.Y), (NormalizedByte)(a % b.Z), (NormalizedByte)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedSByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedSByte), 4, false)]
	public partial struct Vector4nsb : IEquatable<Vector4nsb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4nsb Normalized { get { Vector4nsb result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedSByte Product { get { return (NormalizedSByte)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedSByte Sum { get { return (NormalizedSByte)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4nsb(double x, double y, double z, double w) : this((NormalizedSByte)x, (NormalizedSByte)y, (NormalizedSByte)z, (NormalizedSByte)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nsb( Vector4d value) : this((NormalizedSByte)value.X, (NormalizedSByte)value.Y, (NormalizedSByte)value.Z, (NormalizedSByte)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nsb( ref  Vector4d value) : this((NormalizedSByte)value.X, (NormalizedSByte)value.Y, (NormalizedSByte)value.Z, (NormalizedSByte)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4nsb One = new Vector4nsb((NormalizedSByte)1, (NormalizedSByte)1, (NormalizedSByte)1, (NormalizedSByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4nsb UnitX = new Vector4nsb((NormalizedSByte)1, (NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4nsb UnitY = new Vector4nsb((NormalizedSByte)0, (NormalizedSByte)1, (NormalizedSByte)0, (NormalizedSByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4nsb UnitZ = new Vector4nsb((NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)1, (NormalizedSByte)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4nsb UnitW = new Vector4nsb((NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nsb( Vector3nsb xyz, NormalizedSByte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nsb(NormalizedSByte x,  Vector3nsb yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4nsb( ref  Vector3nsb xyz, NormalizedSByte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nsb(NormalizedSByte x,  ref  Vector3nsb yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nsb( Vector2nsb xy, NormalizedSByte z, NormalizedSByte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nsb(NormalizedSByte x,  Vector2nsb yz, NormalizedSByte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nsb(NormalizedSByte x, NormalizedSByte y,  Vector2nsb zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nsb( Vector2nsb xy,  Vector2nsb zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4nsb( ref  Vector2nsb xy, NormalizedSByte z, NormalizedSByte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nsb(NormalizedSByte x,  ref  Vector2nsb yz, NormalizedSByte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nsb(NormalizedSByte x, NormalizedSByte y,  ref  Vector2nsb zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nsb( ref  Vector2nsb xy,  ref  Vector2nsb zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4nsb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4nsb other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4nsb Clamp( Vector4nsb min,  Vector4nsb max ) {
					Vector4nsb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4nsb min,  ref  Vector4nsb max , out Vector4nsb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4nsb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4nsb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4nsb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4nsb other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4nsb result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedSByte)(X * m);  result.Y = (NormalizedSByte)(Y * m);  result.Z = (NormalizedSByte)(Z * m);  result.W = (NormalizedSByte)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedSByte m = (NormalizedSByte)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4nsb"/>.</summary>
		public NormalizedSByte X;
			/// <summary>The second axis of the <see cref="Vector4nsb"/>.</summary>
		public NormalizedSByte Y;
			/// <summary>The third axis of the <see cref="Vector4nsb"/>.</summary>
		public NormalizedSByte Z;
			/// <summary>The fourth axis of the <see cref="Vector4nsb"/>.</summary>
		public NormalizedSByte W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4nsb"/>.</summary>
	public static readonly Vector4nsb Zero = new Vector4nsb((NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)0, (NormalizedSByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4nsb"/> from the provided values for each factor.</summary>
	public Vector4nsb(NormalizedSByte x, NormalizedSByte y, NormalizedSByte z, NormalizedSByte w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4nsb"/> from a list.</summary>
	public Vector4nsb(IList<NormalizedSByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4nsb"/> from a single scalar that is applied to all factors.</summary>
	public Vector4nsb(NormalizedSByte value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4nsb"/> has equal factors as the other <see cref="Vector4nsb"/>.</summary>
	public bool Equals(Vector4nsb other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4nsb"/> of the same type, get whether this <see cref="Vector4nsb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4nsb)
			return Equals((Vector4nsb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4nsb"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4nsb"/> to a string of the form "Vector4nsb(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4nsb"/> to a string of the form "Vector4nsb(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4nsb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4nsb"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4nsb"/> values are equal.</summary>
	public static bool operator ==(Vector4nsb a, Vector4nsb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4nsb"/> values are unequal.</summary>
	public static bool operator !=(Vector4nsb a, Vector4nsb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4nsb a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4nsb a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4nsb a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4nsb a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4nsb a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4nsb a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4nsb a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4nsb a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4nsb a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4nsb a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4nsb a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4nsb a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4nsb a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4nsb a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nsb"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4nsb a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3nsb(Vector4nsb a) {
						return new Vector3nsb(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nsb(Vector4nsb a) {
						return new Vector2nsb(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4nsb operator +(Vector4nsb a) { return new Vector4nsb((NormalizedSByte)(+a.X), (NormalizedSByte)(+a.Y), (NormalizedSByte)(+a.Z), (NormalizedSByte)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4nsb operator -(Vector4nsb a) { return new Vector4nsb((NormalizedSByte)(-a.X), (NormalizedSByte)(-a.Y), (NormalizedSByte)(-a.Z), (NormalizedSByte)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4nsb operator +(Vector4nsb a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a.X + b.X), (NormalizedSByte)(a.Y + b.Y), (NormalizedSByte)(a.Z + b.Z), (NormalizedSByte)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4nsb operator +(Vector4nsb a, NormalizedSByte b) { return new Vector4nsb((NormalizedSByte)(a.X + b), (NormalizedSByte)(a.Y + b), (NormalizedSByte)(a.Z + b), (NormalizedSByte)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4nsb operator +(NormalizedSByte a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a + b.X), (NormalizedSByte)(a + b.Y), (NormalizedSByte)(a + b.Z), (NormalizedSByte)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4nsb operator -(Vector4nsb a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a.X - b.X), (NormalizedSByte)(a.Y - b.Y), (NormalizedSByte)(a.Z - b.Z), (NormalizedSByte)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4nsb operator -(Vector4nsb a, NormalizedSByte b) { return new Vector4nsb((NormalizedSByte)(a.X - b), (NormalizedSByte)(a.Y - b), (NormalizedSByte)(a.Z - b), (NormalizedSByte)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4nsb operator -(NormalizedSByte a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a - b.X), (NormalizedSByte)(a - b.Y), (NormalizedSByte)(a - b.Z), (NormalizedSByte)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4nsb operator *(Vector4nsb a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a.X * b.X), (NormalizedSByte)(a.Y * b.Y), (NormalizedSByte)(a.Z * b.Z), (NormalizedSByte)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4nsb operator *(Vector4nsb a, NormalizedSByte b) { return new Vector4nsb((NormalizedSByte)(a.X * b), (NormalizedSByte)(a.Y * b), (NormalizedSByte)(a.Z * b), (NormalizedSByte)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4nsb operator *(NormalizedSByte a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a * b.X), (NormalizedSByte)(a * b.Y), (NormalizedSByte)(a * b.Z), (NormalizedSByte)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4nsb operator /(Vector4nsb a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a.X / b.X), (NormalizedSByte)(a.Y / b.Y), (NormalizedSByte)(a.Z / b.Z), (NormalizedSByte)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4nsb operator /(Vector4nsb a, NormalizedSByte b) { return new Vector4nsb((NormalizedSByte)(a.X / b), (NormalizedSByte)(a.Y / b), (NormalizedSByte)(a.Z / b), (NormalizedSByte)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4nsb operator /(NormalizedSByte a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a / b.X), (NormalizedSByte)(a / b.Y), (NormalizedSByte)(a / b.Z), (NormalizedSByte)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4nsb operator %(Vector4nsb a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a.X % b.X), (NormalizedSByte)(a.Y % b.Y), (NormalizedSByte)(a.Z % b.Z), (NormalizedSByte)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4nsb operator %(Vector4nsb a, NormalizedSByte b) { return new Vector4nsb((NormalizedSByte)(a.X % b), (NormalizedSByte)(a.Y % b), (NormalizedSByte)(a.Z % b), (NormalizedSByte)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4nsb operator %(NormalizedSByte a, Vector4nsb b) { return new Vector4nsb((NormalizedSByte)(a % b.X), (NormalizedSByte)(a % b.Y), (NormalizedSByte)(a % b.Z), (NormalizedSByte)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedInt16), 4, false)]
	public partial struct Vector4ns : IEquatable<Vector4ns>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4ns Normalized { get { Vector4ns result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedInt16 Product { get { return (NormalizedInt16)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedInt16 Sum { get { return (NormalizedInt16)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4ns(double x, double y, double z, double w) : this((NormalizedInt16)x, (NormalizedInt16)y, (NormalizedInt16)z, (NormalizedInt16)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4ns( Vector4d value) : this((NormalizedInt16)value.X, (NormalizedInt16)value.Y, (NormalizedInt16)value.Z, (NormalizedInt16)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4ns( ref  Vector4d value) : this((NormalizedInt16)value.X, (NormalizedInt16)value.Y, (NormalizedInt16)value.Z, (NormalizedInt16)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4ns One = new Vector4ns((NormalizedInt16)1, (NormalizedInt16)1, (NormalizedInt16)1, (NormalizedInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4ns UnitX = new Vector4ns((NormalizedInt16)1, (NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4ns UnitY = new Vector4ns((NormalizedInt16)0, (NormalizedInt16)1, (NormalizedInt16)0, (NormalizedInt16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4ns UnitZ = new Vector4ns((NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)1, (NormalizedInt16)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4ns UnitW = new Vector4ns((NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4ns( Vector3ns xyz, NormalizedInt16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4ns(NormalizedInt16 x,  Vector3ns yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4ns( ref  Vector3ns xyz, NormalizedInt16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4ns(NormalizedInt16 x,  ref  Vector3ns yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4ns( Vector2ns xy, NormalizedInt16 z, NormalizedInt16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ns(NormalizedInt16 x,  Vector2ns yz, NormalizedInt16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ns(NormalizedInt16 x, NormalizedInt16 y,  Vector2ns zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ns( Vector2ns xy,  Vector2ns zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4ns( ref  Vector2ns xy, NormalizedInt16 z, NormalizedInt16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ns(NormalizedInt16 x,  ref  Vector2ns yz, NormalizedInt16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ns(NormalizedInt16 x, NormalizedInt16 y,  ref  Vector2ns zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ns( ref  Vector2ns xy,  ref  Vector2ns zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4ns other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4ns other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4ns Clamp( Vector4ns min,  Vector4ns max ) {
					Vector4ns result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4ns min,  ref  Vector4ns max , out Vector4ns result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4ns other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4ns other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4ns other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4ns other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4ns result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedInt16)(X * m);  result.Y = (NormalizedInt16)(Y * m);  result.Z = (NormalizedInt16)(Z * m);  result.W = (NormalizedInt16)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedInt16 m = (NormalizedInt16)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4ns"/>.</summary>
		public NormalizedInt16 X;
			/// <summary>The second axis of the <see cref="Vector4ns"/>.</summary>
		public NormalizedInt16 Y;
			/// <summary>The third axis of the <see cref="Vector4ns"/>.</summary>
		public NormalizedInt16 Z;
			/// <summary>The fourth axis of the <see cref="Vector4ns"/>.</summary>
		public NormalizedInt16 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4ns"/>.</summary>
	public static readonly Vector4ns Zero = new Vector4ns((NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)0, (NormalizedInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4ns"/> from the provided values for each factor.</summary>
	public Vector4ns(NormalizedInt16 x, NormalizedInt16 y, NormalizedInt16 z, NormalizedInt16 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4ns"/> from a list.</summary>
	public Vector4ns(IList<NormalizedInt16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4ns"/> from a single scalar that is applied to all factors.</summary>
	public Vector4ns(NormalizedInt16 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4ns"/> has equal factors as the other <see cref="Vector4ns"/>.</summary>
	public bool Equals(Vector4ns other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4ns"/> of the same type, get whether this <see cref="Vector4ns"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4ns)
			return Equals((Vector4ns)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4ns"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4ns"/> to a string of the form "Vector4ns(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4ns"/> to a string of the form "Vector4ns(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4ns(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4ns"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4ns"/> values are equal.</summary>
	public static bool operator ==(Vector4ns a, Vector4ns b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4ns"/> values are unequal.</summary>
	public static bool operator !=(Vector4ns a, Vector4ns b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4ns"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4ns a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4ns"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4ns a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4ns a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4ns a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4ns a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4ns a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4ns a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4ns a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4ns a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4ns a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4ns a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4ns a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4ns a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4ns a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ns"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4ns a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3ns(Vector4ns a) {
						return new Vector3ns(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2ns(Vector4ns a) {
						return new Vector2ns(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4ns operator +(Vector4ns a) { return new Vector4ns((NormalizedInt16)(+a.X), (NormalizedInt16)(+a.Y), (NormalizedInt16)(+a.Z), (NormalizedInt16)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4ns operator -(Vector4ns a) { return new Vector4ns((NormalizedInt16)(-a.X), (NormalizedInt16)(-a.Y), (NormalizedInt16)(-a.Z), (NormalizedInt16)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4ns operator +(Vector4ns a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a.X + b.X), (NormalizedInt16)(a.Y + b.Y), (NormalizedInt16)(a.Z + b.Z), (NormalizedInt16)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4ns operator +(Vector4ns a, NormalizedInt16 b) { return new Vector4ns((NormalizedInt16)(a.X + b), (NormalizedInt16)(a.Y + b), (NormalizedInt16)(a.Z + b), (NormalizedInt16)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4ns operator +(NormalizedInt16 a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a + b.X), (NormalizedInt16)(a + b.Y), (NormalizedInt16)(a + b.Z), (NormalizedInt16)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4ns operator -(Vector4ns a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a.X - b.X), (NormalizedInt16)(a.Y - b.Y), (NormalizedInt16)(a.Z - b.Z), (NormalizedInt16)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4ns operator -(Vector4ns a, NormalizedInt16 b) { return new Vector4ns((NormalizedInt16)(a.X - b), (NormalizedInt16)(a.Y - b), (NormalizedInt16)(a.Z - b), (NormalizedInt16)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4ns operator -(NormalizedInt16 a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a - b.X), (NormalizedInt16)(a - b.Y), (NormalizedInt16)(a - b.Z), (NormalizedInt16)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4ns operator *(Vector4ns a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a.X * b.X), (NormalizedInt16)(a.Y * b.Y), (NormalizedInt16)(a.Z * b.Z), (NormalizedInt16)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4ns operator *(Vector4ns a, NormalizedInt16 b) { return new Vector4ns((NormalizedInt16)(a.X * b), (NormalizedInt16)(a.Y * b), (NormalizedInt16)(a.Z * b), (NormalizedInt16)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4ns operator *(NormalizedInt16 a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a * b.X), (NormalizedInt16)(a * b.Y), (NormalizedInt16)(a * b.Z), (NormalizedInt16)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4ns operator /(Vector4ns a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a.X / b.X), (NormalizedInt16)(a.Y / b.Y), (NormalizedInt16)(a.Z / b.Z), (NormalizedInt16)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4ns operator /(Vector4ns a, NormalizedInt16 b) { return new Vector4ns((NormalizedInt16)(a.X / b), (NormalizedInt16)(a.Y / b), (NormalizedInt16)(a.Z / b), (NormalizedInt16)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4ns operator /(NormalizedInt16 a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a / b.X), (NormalizedInt16)(a / b.Y), (NormalizedInt16)(a / b.Z), (NormalizedInt16)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4ns operator %(Vector4ns a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a.X % b.X), (NormalizedInt16)(a.Y % b.Y), (NormalizedInt16)(a.Z % b.Z), (NormalizedInt16)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4ns operator %(Vector4ns a, NormalizedInt16 b) { return new Vector4ns((NormalizedInt16)(a.X % b), (NormalizedInt16)(a.Y % b), (NormalizedInt16)(a.Z % b), (NormalizedInt16)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4ns operator %(NormalizedInt16 a, Vector4ns b) { return new Vector4ns((NormalizedInt16)(a % b.X), (NormalizedInt16)(a % b.Y), (NormalizedInt16)(a % b.Z), (NormalizedInt16)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedInt32), 4, false)]
	public partial struct Vector4ni : IEquatable<Vector4ni>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4ni Normalized { get { Vector4ni result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedInt32 Product { get { return (NormalizedInt32)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedInt32 Sum { get { return (NormalizedInt32)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4ni(double x, double y, double z, double w) : this((NormalizedInt32)x, (NormalizedInt32)y, (NormalizedInt32)z, (NormalizedInt32)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4ni( Vector4d value) : this((NormalizedInt32)value.X, (NormalizedInt32)value.Y, (NormalizedInt32)value.Z, (NormalizedInt32)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4ni( ref  Vector4d value) : this((NormalizedInt32)value.X, (NormalizedInt32)value.Y, (NormalizedInt32)value.Z, (NormalizedInt32)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4ni One = new Vector4ni((NormalizedInt32)1, (NormalizedInt32)1, (NormalizedInt32)1, (NormalizedInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4ni UnitX = new Vector4ni((NormalizedInt32)1, (NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4ni UnitY = new Vector4ni((NormalizedInt32)0, (NormalizedInt32)1, (NormalizedInt32)0, (NormalizedInt32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4ni UnitZ = new Vector4ni((NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)1, (NormalizedInt32)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4ni UnitW = new Vector4ni((NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4ni( Vector3ni xyz, NormalizedInt32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4ni(NormalizedInt32 x,  Vector3ni yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4ni( ref  Vector3ni xyz, NormalizedInt32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4ni(NormalizedInt32 x,  ref  Vector3ni yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4ni( Vector2ni xy, NormalizedInt32 z, NormalizedInt32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ni(NormalizedInt32 x,  Vector2ni yz, NormalizedInt32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ni(NormalizedInt32 x, NormalizedInt32 y,  Vector2ni zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ni( Vector2ni xy,  Vector2ni zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4ni( ref  Vector2ni xy, NormalizedInt32 z, NormalizedInt32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ni(NormalizedInt32 x,  ref  Vector2ni yz, NormalizedInt32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ni(NormalizedInt32 x, NormalizedInt32 y,  ref  Vector2ni zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4ni( ref  Vector2ni xy,  ref  Vector2ni zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4ni other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4ni other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4ni Clamp( Vector4ni min,  Vector4ni max ) {
					Vector4ni result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4ni min,  ref  Vector4ni max , out Vector4ni result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4ni other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4ni other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4ni other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4ni other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4ni result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedInt32)(X * m);  result.Y = (NormalizedInt32)(Y * m);  result.Z = (NormalizedInt32)(Z * m);  result.W = (NormalizedInt32)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedInt32 m = (NormalizedInt32)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4ni"/>.</summary>
		public NormalizedInt32 X;
			/// <summary>The second axis of the <see cref="Vector4ni"/>.</summary>
		public NormalizedInt32 Y;
			/// <summary>The third axis of the <see cref="Vector4ni"/>.</summary>
		public NormalizedInt32 Z;
			/// <summary>The fourth axis of the <see cref="Vector4ni"/>.</summary>
		public NormalizedInt32 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4ni"/>.</summary>
	public static readonly Vector4ni Zero = new Vector4ni((NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)0, (NormalizedInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4ni"/> from the provided values for each factor.</summary>
	public Vector4ni(NormalizedInt32 x, NormalizedInt32 y, NormalizedInt32 z, NormalizedInt32 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4ni"/> from a list.</summary>
	public Vector4ni(IList<NormalizedInt32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4ni"/> from a single scalar that is applied to all factors.</summary>
	public Vector4ni(NormalizedInt32 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4ni"/> has equal factors as the other <see cref="Vector4ni"/>.</summary>
	public bool Equals(Vector4ni other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4ni"/> of the same type, get whether this <see cref="Vector4ni"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4ni)
			return Equals((Vector4ni)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4ni"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4ni"/> to a string of the form "Vector4ni(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4ni"/> to a string of the form "Vector4ni(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4ni(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4ni"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4ni"/> values are equal.</summary>
	public static bool operator ==(Vector4ni a, Vector4ni b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4ni"/> values are unequal.</summary>
	public static bool operator !=(Vector4ni a, Vector4ni b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4ni"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4ni a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4ni"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4ni a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4ni a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4ni a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4ni a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4ni a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4ni a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4ni a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4ni a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4ni a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4ni a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4ni a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4ni a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4ni a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4ni"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4ni a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3ni(Vector4ni a) {
						return new Vector3ni(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2ni(Vector4ni a) {
						return new Vector2ni(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4ni operator +(Vector4ni a) { return new Vector4ni((NormalizedInt32)(+a.X), (NormalizedInt32)(+a.Y), (NormalizedInt32)(+a.Z), (NormalizedInt32)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4ni operator -(Vector4ni a) { return new Vector4ni((NormalizedInt32)(-a.X), (NormalizedInt32)(-a.Y), (NormalizedInt32)(-a.Z), (NormalizedInt32)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4ni operator +(Vector4ni a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a.X + b.X), (NormalizedInt32)(a.Y + b.Y), (NormalizedInt32)(a.Z + b.Z), (NormalizedInt32)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4ni operator +(Vector4ni a, NormalizedInt32 b) { return new Vector4ni((NormalizedInt32)(a.X + b), (NormalizedInt32)(a.Y + b), (NormalizedInt32)(a.Z + b), (NormalizedInt32)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4ni operator +(NormalizedInt32 a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a + b.X), (NormalizedInt32)(a + b.Y), (NormalizedInt32)(a + b.Z), (NormalizedInt32)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4ni operator -(Vector4ni a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a.X - b.X), (NormalizedInt32)(a.Y - b.Y), (NormalizedInt32)(a.Z - b.Z), (NormalizedInt32)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4ni operator -(Vector4ni a, NormalizedInt32 b) { return new Vector4ni((NormalizedInt32)(a.X - b), (NormalizedInt32)(a.Y - b), (NormalizedInt32)(a.Z - b), (NormalizedInt32)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4ni operator -(NormalizedInt32 a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a - b.X), (NormalizedInt32)(a - b.Y), (NormalizedInt32)(a - b.Z), (NormalizedInt32)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4ni operator *(Vector4ni a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a.X * b.X), (NormalizedInt32)(a.Y * b.Y), (NormalizedInt32)(a.Z * b.Z), (NormalizedInt32)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4ni operator *(Vector4ni a, NormalizedInt32 b) { return new Vector4ni((NormalizedInt32)(a.X * b), (NormalizedInt32)(a.Y * b), (NormalizedInt32)(a.Z * b), (NormalizedInt32)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4ni operator *(NormalizedInt32 a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a * b.X), (NormalizedInt32)(a * b.Y), (NormalizedInt32)(a * b.Z), (NormalizedInt32)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4ni operator /(Vector4ni a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a.X / b.X), (NormalizedInt32)(a.Y / b.Y), (NormalizedInt32)(a.Z / b.Z), (NormalizedInt32)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4ni operator /(Vector4ni a, NormalizedInt32 b) { return new Vector4ni((NormalizedInt32)(a.X / b), (NormalizedInt32)(a.Y / b), (NormalizedInt32)(a.Z / b), (NormalizedInt32)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4ni operator /(NormalizedInt32 a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a / b.X), (NormalizedInt32)(a / b.Y), (NormalizedInt32)(a / b.Z), (NormalizedInt32)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4ni operator %(Vector4ni a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a.X % b.X), (NormalizedInt32)(a.Y % b.Y), (NormalizedInt32)(a.Z % b.Z), (NormalizedInt32)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4ni operator %(Vector4ni a, NormalizedInt32 b) { return new Vector4ni((NormalizedInt32)(a.X % b), (NormalizedInt32)(a.Y % b), (NormalizedInt32)(a.Z % b), (NormalizedInt32)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4ni operator %(NormalizedInt32 a, Vector4ni b) { return new Vector4ni((NormalizedInt32)(a % b.X), (NormalizedInt32)(a % b.Y), (NormalizedInt32)(a % b.Z), (NormalizedInt32)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedUInt16"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedUInt16), 4, false)]
	public partial struct Vector4nus : IEquatable<Vector4nus>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4nus Normalized { get { Vector4nus result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedUInt16 Product { get { return (NormalizedUInt16)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedUInt16 Sum { get { return (NormalizedUInt16)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4nus(double x, double y, double z, double w) : this((NormalizedUInt16)x, (NormalizedUInt16)y, (NormalizedUInt16)z, (NormalizedUInt16)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nus( Vector4d value) : this((NormalizedUInt16)value.X, (NormalizedUInt16)value.Y, (NormalizedUInt16)value.Z, (NormalizedUInt16)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nus( ref  Vector4d value) : this((NormalizedUInt16)value.X, (NormalizedUInt16)value.Y, (NormalizedUInt16)value.Z, (NormalizedUInt16)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4nus One = new Vector4nus((NormalizedUInt16)1, (NormalizedUInt16)1, (NormalizedUInt16)1, (NormalizedUInt16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4nus UnitX = new Vector4nus((NormalizedUInt16)1, (NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4nus UnitY = new Vector4nus((NormalizedUInt16)0, (NormalizedUInt16)1, (NormalizedUInt16)0, (NormalizedUInt16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4nus UnitZ = new Vector4nus((NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)1, (NormalizedUInt16)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4nus UnitW = new Vector4nus((NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nus( Vector3nus xyz, NormalizedUInt16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nus(NormalizedUInt16 x,  Vector3nus yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4nus( ref  Vector3nus xyz, NormalizedUInt16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nus(NormalizedUInt16 x,  ref  Vector3nus yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nus( Vector2nus xy, NormalizedUInt16 z, NormalizedUInt16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nus(NormalizedUInt16 x,  Vector2nus yz, NormalizedUInt16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nus(NormalizedUInt16 x, NormalizedUInt16 y,  Vector2nus zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nus( Vector2nus xy,  Vector2nus zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4nus( ref  Vector2nus xy, NormalizedUInt16 z, NormalizedUInt16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nus(NormalizedUInt16 x,  ref  Vector2nus yz, NormalizedUInt16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nus(NormalizedUInt16 x, NormalizedUInt16 y,  ref  Vector2nus zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nus( ref  Vector2nus xy,  ref  Vector2nus zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4nus other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4nus other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4nus Clamp( Vector4nus min,  Vector4nus max ) {
					Vector4nus result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4nus min,  ref  Vector4nus max , out Vector4nus result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4nus other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4nus other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4nus other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4nus other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4nus result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedUInt16)(X * m);  result.Y = (NormalizedUInt16)(Y * m);  result.Z = (NormalizedUInt16)(Z * m);  result.W = (NormalizedUInt16)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedUInt16 m = (NormalizedUInt16)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4nus"/>.</summary>
		public NormalizedUInt16 X;
			/// <summary>The second axis of the <see cref="Vector4nus"/>.</summary>
		public NormalizedUInt16 Y;
			/// <summary>The third axis of the <see cref="Vector4nus"/>.</summary>
		public NormalizedUInt16 Z;
			/// <summary>The fourth axis of the <see cref="Vector4nus"/>.</summary>
		public NormalizedUInt16 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4nus"/>.</summary>
	public static readonly Vector4nus Zero = new Vector4nus((NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)0, (NormalizedUInt16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4nus"/> from the provided values for each factor.</summary>
	public Vector4nus(NormalizedUInt16 x, NormalizedUInt16 y, NormalizedUInt16 z, NormalizedUInt16 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4nus"/> from a list.</summary>
	public Vector4nus(IList<NormalizedUInt16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4nus"/> from a single scalar that is applied to all factors.</summary>
	public Vector4nus(NormalizedUInt16 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4nus"/> has equal factors as the other <see cref="Vector4nus"/>.</summary>
	public bool Equals(Vector4nus other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4nus"/> of the same type, get whether this <see cref="Vector4nus"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4nus)
			return Equals((Vector4nus)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4nus"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4nus"/> to a string of the form "Vector4nus(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4nus"/> to a string of the form "Vector4nus(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4nus(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4nus"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4nus"/> values are equal.</summary>
	public static bool operator ==(Vector4nus a, Vector4nus b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4nus"/> values are unequal.</summary>
	public static bool operator !=(Vector4nus a, Vector4nus b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4nus"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4nus a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4nus"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4nus a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4nus a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4nus a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4nus a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4nus a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4nus a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4nus a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4nus a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4nus a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4nus a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4nus a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4nus a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4nus a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nus"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4nus a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3nus(Vector4nus a) {
						return new Vector3nus(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nus(Vector4nus a) {
						return new Vector2nus(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4nus operator +(Vector4nus a) { return new Vector4nus((NormalizedUInt16)(+a.X), (NormalizedUInt16)(+a.Y), (NormalizedUInt16)(+a.Z), (NormalizedUInt16)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4nus operator -(Vector4nus a) { return new Vector4nus((NormalizedUInt16)(-a.X), (NormalizedUInt16)(-a.Y), (NormalizedUInt16)(-a.Z), (NormalizedUInt16)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4nus operator +(Vector4nus a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a.X + b.X), (NormalizedUInt16)(a.Y + b.Y), (NormalizedUInt16)(a.Z + b.Z), (NormalizedUInt16)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4nus operator +(Vector4nus a, NormalizedUInt16 b) { return new Vector4nus((NormalizedUInt16)(a.X + b), (NormalizedUInt16)(a.Y + b), (NormalizedUInt16)(a.Z + b), (NormalizedUInt16)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4nus operator +(NormalizedUInt16 a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a + b.X), (NormalizedUInt16)(a + b.Y), (NormalizedUInt16)(a + b.Z), (NormalizedUInt16)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4nus operator -(Vector4nus a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a.X - b.X), (NormalizedUInt16)(a.Y - b.Y), (NormalizedUInt16)(a.Z - b.Z), (NormalizedUInt16)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4nus operator -(Vector4nus a, NormalizedUInt16 b) { return new Vector4nus((NormalizedUInt16)(a.X - b), (NormalizedUInt16)(a.Y - b), (NormalizedUInt16)(a.Z - b), (NormalizedUInt16)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4nus operator -(NormalizedUInt16 a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a - b.X), (NormalizedUInt16)(a - b.Y), (NormalizedUInt16)(a - b.Z), (NormalizedUInt16)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4nus operator *(Vector4nus a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a.X * b.X), (NormalizedUInt16)(a.Y * b.Y), (NormalizedUInt16)(a.Z * b.Z), (NormalizedUInt16)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4nus operator *(Vector4nus a, NormalizedUInt16 b) { return new Vector4nus((NormalizedUInt16)(a.X * b), (NormalizedUInt16)(a.Y * b), (NormalizedUInt16)(a.Z * b), (NormalizedUInt16)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4nus operator *(NormalizedUInt16 a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a * b.X), (NormalizedUInt16)(a * b.Y), (NormalizedUInt16)(a * b.Z), (NormalizedUInt16)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4nus operator /(Vector4nus a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a.X / b.X), (NormalizedUInt16)(a.Y / b.Y), (NormalizedUInt16)(a.Z / b.Z), (NormalizedUInt16)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4nus operator /(Vector4nus a, NormalizedUInt16 b) { return new Vector4nus((NormalizedUInt16)(a.X / b), (NormalizedUInt16)(a.Y / b), (NormalizedUInt16)(a.Z / b), (NormalizedUInt16)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4nus operator /(NormalizedUInt16 a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a / b.X), (NormalizedUInt16)(a / b.Y), (NormalizedUInt16)(a / b.Z), (NormalizedUInt16)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4nus operator %(Vector4nus a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a.X % b.X), (NormalizedUInt16)(a.Y % b.Y), (NormalizedUInt16)(a.Z % b.Z), (NormalizedUInt16)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4nus operator %(Vector4nus a, NormalizedUInt16 b) { return new Vector4nus((NormalizedUInt16)(a.X % b), (NormalizedUInt16)(a.Y % b), (NormalizedUInt16)(a.Z % b), (NormalizedUInt16)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4nus operator %(NormalizedUInt16 a, Vector4nus b) { return new Vector4nus((NormalizedUInt16)(a % b.X), (NormalizedUInt16)(a % b.Y), (NormalizedUInt16)(a % b.Z), (NormalizedUInt16)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedUInt32"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedUInt32), 4, false)]
	public partial struct Vector4nui : IEquatable<Vector4nui>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4nui Normalized { get { Vector4nui result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedUInt32 Product { get { return (NormalizedUInt32)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedUInt32 Sum { get { return (NormalizedUInt32)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4nui(double x, double y, double z, double w) : this((NormalizedUInt32)x, (NormalizedUInt32)y, (NormalizedUInt32)z, (NormalizedUInt32)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nui( Vector4d value) : this((NormalizedUInt32)value.X, (NormalizedUInt32)value.Y, (NormalizedUInt32)value.Z, (NormalizedUInt32)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4nui( ref  Vector4d value) : this((NormalizedUInt32)value.X, (NormalizedUInt32)value.Y, (NormalizedUInt32)value.Z, (NormalizedUInt32)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4nui One = new Vector4nui((NormalizedUInt32)1, (NormalizedUInt32)1, (NormalizedUInt32)1, (NormalizedUInt32)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4nui UnitX = new Vector4nui((NormalizedUInt32)1, (NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4nui UnitY = new Vector4nui((NormalizedUInt32)0, (NormalizedUInt32)1, (NormalizedUInt32)0, (NormalizedUInt32)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4nui UnitZ = new Vector4nui((NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)1, (NormalizedUInt32)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4nui UnitW = new Vector4nui((NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nui( Vector3nui xyz, NormalizedUInt32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nui(NormalizedUInt32 x,  Vector3nui yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4nui( ref  Vector3nui xyz, NormalizedUInt32 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4nui(NormalizedUInt32 x,  ref  Vector3nui yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4nui( Vector2nui xy, NormalizedUInt32 z, NormalizedUInt32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nui(NormalizedUInt32 x,  Vector2nui yz, NormalizedUInt32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nui(NormalizedUInt32 x, NormalizedUInt32 y,  Vector2nui zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nui( Vector2nui xy,  Vector2nui zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4nui( ref  Vector2nui xy, NormalizedUInt32 z, NormalizedUInt32 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nui(NormalizedUInt32 x,  ref  Vector2nui yz, NormalizedUInt32 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nui(NormalizedUInt32 x, NormalizedUInt32 y,  ref  Vector2nui zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4nui( ref  Vector2nui xy,  ref  Vector2nui zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4nui other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4nui other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4nui Clamp( Vector4nui min,  Vector4nui max ) {
					Vector4nui result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4nui min,  ref  Vector4nui max , out Vector4nui result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4nui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4nui other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4nui other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4nui other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4nui result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedUInt32)(X * m);  result.Y = (NormalizedUInt32)(Y * m);  result.Z = (NormalizedUInt32)(Z * m);  result.W = (NormalizedUInt32)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedUInt32 m = (NormalizedUInt32)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4nui"/>.</summary>
		public NormalizedUInt32 X;
			/// <summary>The second axis of the <see cref="Vector4nui"/>.</summary>
		public NormalizedUInt32 Y;
			/// <summary>The third axis of the <see cref="Vector4nui"/>.</summary>
		public NormalizedUInt32 Z;
			/// <summary>The fourth axis of the <see cref="Vector4nui"/>.</summary>
		public NormalizedUInt32 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4nui"/>.</summary>
	public static readonly Vector4nui Zero = new Vector4nui((NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)0, (NormalizedUInt32)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4nui"/> from the provided values for each factor.</summary>
	public Vector4nui(NormalizedUInt32 x, NormalizedUInt32 y, NormalizedUInt32 z, NormalizedUInt32 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4nui"/> from a list.</summary>
	public Vector4nui(IList<NormalizedUInt32> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4nui"/> from a single scalar that is applied to all factors.</summary>
	public Vector4nui(NormalizedUInt32 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4nui"/> has equal factors as the other <see cref="Vector4nui"/>.</summary>
	public bool Equals(Vector4nui other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4nui"/> of the same type, get whether this <see cref="Vector4nui"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4nui)
			return Equals((Vector4nui)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4nui"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4nui"/> to a string of the form "Vector4nui(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4nui"/> to a string of the form "Vector4nui(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4nui(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4nui"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4nui"/> values are equal.</summary>
	public static bool operator ==(Vector4nui a, Vector4nui b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4nui"/> values are unequal.</summary>
	public static bool operator !=(Vector4nui a, Vector4nui b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4nui"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4nui a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4nui"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4nui a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4nui a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4nui a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4nui a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4nui a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4nui a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4nui a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4nui a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4nui a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4nui a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4nui a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4nui a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4nui a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4nui"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4nui a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3nui(Vector4nui a) {
						return new Vector3nui(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2nui(Vector4nui a) {
						return new Vector2nui(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4nui operator +(Vector4nui a) { return new Vector4nui((NormalizedUInt32)(+a.X), (NormalizedUInt32)(+a.Y), (NormalizedUInt32)(+a.Z), (NormalizedUInt32)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4nui operator -(Vector4nui a) { return new Vector4nui((NormalizedUInt32)(-a.X), (NormalizedUInt32)(-a.Y), (NormalizedUInt32)(-a.Z), (NormalizedUInt32)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4nui operator +(Vector4nui a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a.X + b.X), (NormalizedUInt32)(a.Y + b.Y), (NormalizedUInt32)(a.Z + b.Z), (NormalizedUInt32)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4nui operator +(Vector4nui a, NormalizedUInt32 b) { return new Vector4nui((NormalizedUInt32)(a.X + b), (NormalizedUInt32)(a.Y + b), (NormalizedUInt32)(a.Z + b), (NormalizedUInt32)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4nui operator +(NormalizedUInt32 a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a + b.X), (NormalizedUInt32)(a + b.Y), (NormalizedUInt32)(a + b.Z), (NormalizedUInt32)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4nui operator -(Vector4nui a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a.X - b.X), (NormalizedUInt32)(a.Y - b.Y), (NormalizedUInt32)(a.Z - b.Z), (NormalizedUInt32)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4nui operator -(Vector4nui a, NormalizedUInt32 b) { return new Vector4nui((NormalizedUInt32)(a.X - b), (NormalizedUInt32)(a.Y - b), (NormalizedUInt32)(a.Z - b), (NormalizedUInt32)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4nui operator -(NormalizedUInt32 a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a - b.X), (NormalizedUInt32)(a - b.Y), (NormalizedUInt32)(a - b.Z), (NormalizedUInt32)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4nui operator *(Vector4nui a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a.X * b.X), (NormalizedUInt32)(a.Y * b.Y), (NormalizedUInt32)(a.Z * b.Z), (NormalizedUInt32)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4nui operator *(Vector4nui a, NormalizedUInt32 b) { return new Vector4nui((NormalizedUInt32)(a.X * b), (NormalizedUInt32)(a.Y * b), (NormalizedUInt32)(a.Z * b), (NormalizedUInt32)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4nui operator *(NormalizedUInt32 a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a * b.X), (NormalizedUInt32)(a * b.Y), (NormalizedUInt32)(a * b.Z), (NormalizedUInt32)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4nui operator /(Vector4nui a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a.X / b.X), (NormalizedUInt32)(a.Y / b.Y), (NormalizedUInt32)(a.Z / b.Z), (NormalizedUInt32)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4nui operator /(Vector4nui a, NormalizedUInt32 b) { return new Vector4nui((NormalizedUInt32)(a.X / b), (NormalizedUInt32)(a.Y / b), (NormalizedUInt32)(a.Z / b), (NormalizedUInt32)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4nui operator /(NormalizedUInt32 a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a / b.X), (NormalizedUInt32)(a / b.Y), (NormalizedUInt32)(a / b.Z), (NormalizedUInt32)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4nui operator %(Vector4nui a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a.X % b.X), (NormalizedUInt32)(a.Y % b.Y), (NormalizedUInt32)(a.Z % b.Z), (NormalizedUInt32)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4nui operator %(Vector4nui a, NormalizedUInt32 b) { return new Vector4nui((NormalizedUInt32)(a.X % b), (NormalizedUInt32)(a.Y % b), (NormalizedUInt32)(a.Z % b), (NormalizedUInt32)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4nui operator %(NormalizedUInt32 a, Vector4nui b) { return new Vector4nui((NormalizedUInt32)(a % b.X), (NormalizedUInt32)(a % b.Y), (NormalizedUInt32)(a % b.Z), (NormalizedUInt32)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="NormalizedByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(NormalizedByte), 4, false)]
	public partial struct Vector4rgba : IEquatable<Vector4rgba>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Double MagnitudeSquared { get { return (Double)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4rgba Normalized { get { Vector4rgba result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public NormalizedByte Product { get { return (NormalizedByte)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public NormalizedByte Sum { get { return (NormalizedByte)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
							/// <summary>Initialise a vector from double values that are converted into normalised form.</summary>
				public Vector4rgba(double x, double y, double z, double w) : this((NormalizedByte)x, (NormalizedByte)y, (NormalizedByte)z, (NormalizedByte)w) { }

									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4rgba( Vector4d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z, (NormalizedByte)value.W) { }
									/// <summary>Initialize a vector from double values that are converted into normalized form.</summary>
					public Vector4rgba( ref  Vector4d value) : this((NormalizedByte)value.X, (NormalizedByte)value.Y, (NormalizedByte)value.Z, (NormalizedByte)value.W) { }
									
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4rgba One = new Vector4rgba((NormalizedByte)1, (NormalizedByte)1, (NormalizedByte)1, (NormalizedByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4rgba UnitX = new Vector4rgba((NormalizedByte)1, (NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4rgba UnitY = new Vector4rgba((NormalizedByte)0, (NormalizedByte)1, (NormalizedByte)0, (NormalizedByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4rgba UnitZ = new Vector4rgba((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)1, (NormalizedByte)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4rgba UnitW = new Vector4rgba((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)1);
							

			// Constructors built up of smaller vectors.
			
			// Constructors from much smaller vectors.
			
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Double Dot( Vector4rgba other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Double Dot( ref  Vector4rgba other) { return (Double)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4rgba Clamp( Vector4rgba min,  Vector4rgba max ) {
					Vector4rgba result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4rgba min,  ref  Vector4rgba max , out Vector4rgba result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4rgba other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( Vector4rgba other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4rgba other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Double DistanceSquared( ref  Vector4rgba other) {
					return (Double)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4rgba result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (NormalizedByte)(X * m);  result.Y = (NormalizedByte)(Y * m);  result.Z = (NormalizedByte)(Z * m);  result.W = (NormalizedByte)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						NormalizedByte m = (NormalizedByte)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4rgba"/>.</summary>
		public NormalizedByte X;
			/// <summary>The second axis of the <see cref="Vector4rgba"/>.</summary>
		public NormalizedByte Y;
			/// <summary>The third axis of the <see cref="Vector4rgba"/>.</summary>
		public NormalizedByte Z;
			/// <summary>The fourth axis of the <see cref="Vector4rgba"/>.</summary>
		public NormalizedByte W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4rgba"/>.</summary>
	public static readonly Vector4rgba Zero = new Vector4rgba((NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0, (NormalizedByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4rgba"/> from the provided values for each factor.</summary>
	public Vector4rgba(NormalizedByte x, NormalizedByte y, NormalizedByte z, NormalizedByte w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4rgba"/> from a list.</summary>
	public Vector4rgba(IList<NormalizedByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4rgba"/> from a single scalar that is applied to all factors.</summary>
	public Vector4rgba(NormalizedByte value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4rgba"/> has equal factors as the other <see cref="Vector4rgba"/>.</summary>
	public bool Equals(Vector4rgba other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4rgba"/> of the same type, get whether this <see cref="Vector4rgba"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4rgba)
			return Equals((Vector4rgba)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4rgba"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4rgba"/> to a string of the form "Vector4rgba(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4rgba"/> to a string of the form "Vector4rgba(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4rgba(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4rgba"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4rgba"/> values are equal.</summary>
	public static bool operator ==(Vector4rgba a, Vector4rgba b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4rgba"/> values are unequal.</summary>
	public static bool operator !=(Vector4rgba a, Vector4rgba b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4rgba a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4rgba a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4rgba a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4rgba a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4rgba a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4rgba a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4rgba a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4rgba a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4rgba a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4rgba a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4rgba a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4rgba a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4rgba a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4rgba a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4rgba"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4rgba a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4rgba operator +(Vector4rgba a) { return new Vector4rgba((NormalizedByte)(+a.X), (NormalizedByte)(+a.Y), (NormalizedByte)(+a.Z), (NormalizedByte)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4rgba operator -(Vector4rgba a) { return new Vector4rgba((NormalizedByte)(-a.X), (NormalizedByte)(-a.Y), (NormalizedByte)(-a.Z), (NormalizedByte)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4rgba operator +(Vector4rgba a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a.X + b.X), (NormalizedByte)(a.Y + b.Y), (NormalizedByte)(a.Z + b.Z), (NormalizedByte)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4rgba operator +(Vector4rgba a, NormalizedByte b) { return new Vector4rgba((NormalizedByte)(a.X + b), (NormalizedByte)(a.Y + b), (NormalizedByte)(a.Z + b), (NormalizedByte)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4rgba operator +(NormalizedByte a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a + b.X), (NormalizedByte)(a + b.Y), (NormalizedByte)(a + b.Z), (NormalizedByte)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4rgba operator -(Vector4rgba a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a.X - b.X), (NormalizedByte)(a.Y - b.Y), (NormalizedByte)(a.Z - b.Z), (NormalizedByte)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4rgba operator -(Vector4rgba a, NormalizedByte b) { return new Vector4rgba((NormalizedByte)(a.X - b), (NormalizedByte)(a.Y - b), (NormalizedByte)(a.Z - b), (NormalizedByte)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4rgba operator -(NormalizedByte a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a - b.X), (NormalizedByte)(a - b.Y), (NormalizedByte)(a - b.Z), (NormalizedByte)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4rgba operator *(Vector4rgba a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a.X * b.X), (NormalizedByte)(a.Y * b.Y), (NormalizedByte)(a.Z * b.Z), (NormalizedByte)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4rgba operator *(Vector4rgba a, NormalizedByte b) { return new Vector4rgba((NormalizedByte)(a.X * b), (NormalizedByte)(a.Y * b), (NormalizedByte)(a.Z * b), (NormalizedByte)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4rgba operator *(NormalizedByte a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a * b.X), (NormalizedByte)(a * b.Y), (NormalizedByte)(a * b.Z), (NormalizedByte)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4rgba operator /(Vector4rgba a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a.X / b.X), (NormalizedByte)(a.Y / b.Y), (NormalizedByte)(a.Z / b.Z), (NormalizedByte)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4rgba operator /(Vector4rgba a, NormalizedByte b) { return new Vector4rgba((NormalizedByte)(a.X / b), (NormalizedByte)(a.Y / b), (NormalizedByte)(a.Z / b), (NormalizedByte)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4rgba operator /(NormalizedByte a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a / b.X), (NormalizedByte)(a / b.Y), (NormalizedByte)(a / b.Z), (NormalizedByte)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4rgba operator %(Vector4rgba a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a.X % b.X), (NormalizedByte)(a.Y % b.Y), (NormalizedByte)(a.Z % b.Z), (NormalizedByte)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4rgba operator %(Vector4rgba a, NormalizedByte b) { return new Vector4rgba((NormalizedByte)(a.X % b), (NormalizedByte)(a.Y % b), (NormalizedByte)(a.Z % b), (NormalizedByte)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4rgba operator %(NormalizedByte a, Vector4rgba b) { return new Vector4rgba((NormalizedByte)(a % b.X), (NormalizedByte)(a % b.Y), (NormalizedByte)(a % b.Z), (NormalizedByte)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="Float16"/> elements.</summary>
	[VectorTypeAttribute(typeof(Float16), 4, false)]
	public partial struct Vector4h : IEquatable<Vector4h>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public Float16 MagnitudeSquared { get { return (Float16)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public Float16 Magnitude {
				get {
					return (Float16)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

												/// <summary>Get the normalized form of this vector, with a magnitude of one.</summary>
					public Vector4h Normalized { get { Vector4h result; Normalize(out result); return result; } }
							
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public Float16 Product { get { return (Float16)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public Float16 Sum { get { return (Float16)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4h One = new Vector4h((Float16)1, (Float16)1, (Float16)1, (Float16)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4h UnitX = new Vector4h((Float16)1, (Float16)0, (Float16)0, (Float16)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4h UnitY = new Vector4h((Float16)0, (Float16)1, (Float16)0, (Float16)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4h UnitZ = new Vector4h((Float16)0, (Float16)0, (Float16)1, (Float16)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4h UnitW = new Vector4h((Float16)0, (Float16)0, (Float16)0, (Float16)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4h( Vector3h xyz, Float16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4h(Float16 x,  Vector3h yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4h( ref  Vector3h xyz, Float16 w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4h(Float16 x,  ref  Vector3h yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4h( Vector2h xy, Float16 z, Float16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4h(Float16 x,  Vector2h yz, Float16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4h(Float16 x, Float16 y,  Vector2h zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4h( Vector2h xy,  Vector2h zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4h( ref  Vector2h xy, Float16 z, Float16 w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4h(Float16 x,  ref  Vector2h yz, Float16 w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4h(Float16 x, Float16 y,  ref  Vector2h zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4h( ref  Vector2h xy,  ref  Vector2h zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public Float16 Dot( Vector4h other) { return (Float16)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public Float16 Dot( ref  Vector4h other) { return (Float16)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4h Clamp( Vector4h min,  Vector4h max ) {
					Vector4h result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4h min,  ref  Vector4h max , out Vector4h result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public Float16 Distance( Vector4h other) {
					return (Float16)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Float16 DistanceSquared( Vector4h other) {
					return (Float16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public Float16 Distance( ref  Vector4h other) {
					return (Float16)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public Float16 DistanceSquared( ref  Vector4h other) {
					return (Float16)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
												/// <summary>Get the normalized form of this vector, which has a magnitude of one.</summary>
					public void Normalize(out Vector4h result) {
						double m = 1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W );
						 result.X = (Float16)(X * m);  result.Y = (Float16)(Y * m);  result.Z = (Float16)(Z * m);  result.W = (Float16)(W * m); 					}

					/// <summary>Normalize this vector in place, giving it a magnitude of one. An identity vector will become NaN.</summary>
					public void NormalizeInPlace() {
						Float16 m = (Float16)(1.0 / Math.Sqrt( X * X + Y * Y + Z * Z + W * W ));
						 X *= m;  Y *= m;  Z *= m;  W *= m; 					}
				
												
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4h"/>.</summary>
		public Float16 X;
			/// <summary>The second axis of the <see cref="Vector4h"/>.</summary>
		public Float16 Y;
			/// <summary>The third axis of the <see cref="Vector4h"/>.</summary>
		public Float16 Z;
			/// <summary>The fourth axis of the <see cref="Vector4h"/>.</summary>
		public Float16 W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4h"/>.</summary>
	public static readonly Vector4h Zero = new Vector4h((Float16)0, (Float16)0, (Float16)0, (Float16)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4h"/> from the provided values for each factor.</summary>
	public Vector4h(Float16 x, Float16 y, Float16 z, Float16 w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4h"/> from a list.</summary>
	public Vector4h(IList<Float16> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4h"/> from a single scalar that is applied to all factors.</summary>
	public Vector4h(Float16 value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4h"/> has equal factors as the other <see cref="Vector4h"/>.</summary>
	public bool Equals(Vector4h other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4h"/> of the same type, get whether this <see cref="Vector4h"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4h)
			return Equals((Vector4h)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4h"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4h"/> to a string of the form "Vector4h(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4h"/> to a string of the form "Vector4h(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4h(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4h"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4h"/> values are equal.</summary>
	public static bool operator ==(Vector4h a, Vector4h b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4h"/> values are unequal.</summary>
	public static bool operator !=(Vector4h a, Vector4h b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4h"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4h a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4h"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4h a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4h a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4h a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4h a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4h a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4h a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4h a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4h a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4h a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4h a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4h a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4h a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4h a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4h"/> to <see cref="Vector4sb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4sb(Vector4h a) {
						return new Vector4sb((SByte)a.X, (SByte)a.Y, (SByte)a.Z, (SByte)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3h(Vector4h a) {
						return new Vector3h(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2h(Vector4h a) {
						return new Vector2h(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4h operator +(Vector4h a) { return new Vector4h((Float16)(+a.X), (Float16)(+a.Y), (Float16)(+a.Z), (Float16)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4h operator -(Vector4h a) { return new Vector4h((Float16)(-a.X), (Float16)(-a.Y), (Float16)(-a.Z), (Float16)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4h operator +(Vector4h a, Vector4h b) { return new Vector4h((Float16)(a.X + b.X), (Float16)(a.Y + b.Y), (Float16)(a.Z + b.Z), (Float16)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4h operator +(Vector4h a, Float16 b) { return new Vector4h((Float16)(a.X + b), (Float16)(a.Y + b), (Float16)(a.Z + b), (Float16)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4h operator +(Float16 a, Vector4h b) { return new Vector4h((Float16)(a + b.X), (Float16)(a + b.Y), (Float16)(a + b.Z), (Float16)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4h operator -(Vector4h a, Vector4h b) { return new Vector4h((Float16)(a.X - b.X), (Float16)(a.Y - b.Y), (Float16)(a.Z - b.Z), (Float16)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4h operator -(Vector4h a, Float16 b) { return new Vector4h((Float16)(a.X - b), (Float16)(a.Y - b), (Float16)(a.Z - b), (Float16)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4h operator -(Float16 a, Vector4h b) { return new Vector4h((Float16)(a - b.X), (Float16)(a - b.Y), (Float16)(a - b.Z), (Float16)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4h operator *(Vector4h a, Vector4h b) { return new Vector4h((Float16)(a.X * b.X), (Float16)(a.Y * b.Y), (Float16)(a.Z * b.Z), (Float16)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4h operator *(Vector4h a, Float16 b) { return new Vector4h((Float16)(a.X * b), (Float16)(a.Y * b), (Float16)(a.Z * b), (Float16)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4h operator *(Float16 a, Vector4h b) { return new Vector4h((Float16)(a * b.X), (Float16)(a * b.Y), (Float16)(a * b.Z), (Float16)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4h operator /(Vector4h a, Vector4h b) { return new Vector4h((Float16)(a.X / b.X), (Float16)(a.Y / b.Y), (Float16)(a.Z / b.Z), (Float16)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4h operator /(Vector4h a, Float16 b) { return new Vector4h((Float16)(a.X / b), (Float16)(a.Y / b), (Float16)(a.Z / b), (Float16)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4h operator /(Float16 a, Vector4h b) { return new Vector4h((Float16)(a / b.X), (Float16)(a / b.Y), (Float16)(a / b.Z), (Float16)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4h operator %(Vector4h a, Vector4h b) { return new Vector4h((Float16)(a.X % b.X), (Float16)(a.Y % b.Y), (Float16)(a.Z % b.Z), (Float16)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4h operator %(Vector4h a, Float16 b) { return new Vector4h((Float16)(a.X % b), (Float16)(a.Y % b), (Float16)(a.Z % b), (Float16)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4h operator %(Float16 a, Vector4h b) { return new Vector4h((Float16)(a % b.X), (Float16)(a % b.Y), (Float16)(a % b.Z), (Float16)(a % b.W)); }
				
		#endregion Operators
	}
	
	
	/// <summary>A four-dimensional vector type using <see cref="SByte"/> elements.</summary>
	[VectorTypeAttribute(typeof(SByte), 4, false)]
	public partial struct Vector4sb : IEquatable<Vector4sb>, IFormattable
	{
		#region Properties
		
			/// <summary>Compute the squared magnitude of the vector, which is the distance from the origin squared. Use <see cref="Magnitude"/> for the unsquared version, which is slower to compute.</summary>
			public int MagnitudeSquared { get { return (int)( X * X + Y * Y + Z * Z + W * W ); } }
			
			/// <summary>Compute the magnitude of the vector, which is the distance from the origin.</summary>
			public double Magnitude {
				get {
					return (double)(						Math.Sqrt(
															 X.Squared() 
							+								 Y.Squared() 
							+								 Z.Squared() 
							+								 W.Squared() 
													));
				}
			}

			
							/// <summary>Get the product of multiplying all of the axes together.</summary>
				public SByte Product { get { return (SByte)( X * Y * Z * W ); } }
			
			/// <summary>Get the sum of all of the axes.</summary>
			public SByte Sum { get { return (SByte)( X + Y + Z + W ); } }

		#endregion Properties

		#region Constructors
		
			
			
							/// <summary>Get a vector that has one for each axis.</summary>
				public static readonly Vector4sb One = new Vector4sb((SByte)1, (SByte)1, (SByte)1, (SByte)1);

									/// <summary>Get a normalized vector where X is 1 and all other axes are 0.</summary>
					public static readonly Vector4sb UnitX = new Vector4sb((SByte)1, (SByte)0, (SByte)0, (SByte)0);
									/// <summary>Get a normalized vector where Y is 1 and all other axes are 0.</summary>
					public static readonly Vector4sb UnitY = new Vector4sb((SByte)0, (SByte)1, (SByte)0, (SByte)0);
									/// <summary>Get a normalized vector where Z is 1 and all other axes are 0.</summary>
					public static readonly Vector4sb UnitZ = new Vector4sb((SByte)0, (SByte)0, (SByte)1, (SByte)0);
									/// <summary>Get a normalized vector where W is 1 and all other axes are 0.</summary>
					public static readonly Vector4sb UnitW = new Vector4sb((SByte)0, (SByte)0, (SByte)0, (SByte)1);
							

			// Constructors built up of smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4sb( Vector3sb xyz, SByte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4sb(SByte x,  Vector3sb yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
									/// <summary>Initialise the vector.</summary>
					public Vector4sb( ref  Vector3sb xyz, SByte w) {
													X = xyz.X;
													Y = xyz.Y;
													Z = xyz.Z;
										
						W = w;
					}
				
					/// <summary>Initialise the vector.</summary>
					public Vector4sb(SByte x,  ref  Vector3sb yz) {
						X = x;

													Y = yz.X;
													Z = yz.Y;
													W = yz.Z;
											}
							
			// Constructors from much smaller vectors.
												/// <summary>Initialise the vector.</summary>
					public Vector4sb( Vector2sb xy, SByte z, SByte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4sb(SByte x,  Vector2sb yz, SByte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4sb(SByte x, SByte y,  Vector2sb zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4sb( Vector2sb xy,  Vector2sb zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
									/// <summary>Initialise the vector.</summary>
					public Vector4sb( ref  Vector2sb xy, SByte z, SByte w) { X = xy.X; Y = xy.Y; Z = z; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4sb(SByte x,  ref  Vector2sb yz, SByte w) { X = x; Y = yz.X; Z = yz.Y; W = w; }

					/// <summary>Initialise the vector.</summary>
					public Vector4sb(SByte x, SByte y,  ref  Vector2sb zw) { X = x; Y = y; Z = zw.X; W = zw.Y; }

					/// <summary>Initialise the vector.</summary>
					public Vector4sb( ref  Vector2sb xy,  ref  Vector2sb zw) { X = xy.X; Y = xy.Y; Z = zw.X; W = zw.Y; }
							
		#endregion Constructors

		#region Methods

			// Methods that have joint ref forms.
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. </param>
				public int Dot( Vector4sb other) { return (int)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
							/// <summary>Compute the dot product of this and other vector, which is the sum of the product of each axis of each vector.</summary>
				/// <param name="other">The other vector to calculate a dot product with. The value of the parameter will not be changed; <c>ref</c> is used for optimisation only.</param>
				public int Dot( ref  Vector4sb other) { return (int)( X * other.X + Y * other.Y + Z * other.Z + W * other.W ); }
			
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public Vector4sb Clamp( Vector4sb min,  Vector4sb max ) {
					Vector4sb result;
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return result;
				}
							/// <summary>Get a vector that clamps each axis to the given range.</summary>
				public void Clamp( ref  Vector4sb min,  ref  Vector4sb max , out Vector4sb result) {
					
											result.X = X < min.X ? min.X : X > max.X ? max.X : X;
											result.Y = Y < min.Y ? min.Y : Y > max.Y ? max.Y : Y;
											result.Z = Z < min.Z ? min.Z : Z > max.Z ? max.Z : Z;
											result.W = W < min.W ? min.W : W > max.W ? max.W : W;
										return;
				}
			
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( Vector4sb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( Vector4sb other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
							/// <summary>Get the distance between the vectors.</summary>
				public double Distance( ref  Vector4sb other) {
					return (double)(						Math.Sqrt(
															 X - other.X .Squared() 
							+								 Y - other.Y .Squared() 
							+								 Z - other.Z .Squared() 
							+								 W - other.W .Squared() 
													));
				}

				/// <summary>Get the squared distance between the vectors.</summary>
				public int DistanceSquared( ref  Vector4sb other) {
					return (int)((X - other.X).Squared() + (Y - other.Y).Squared() + (Z - other.Z).Squared() + (W - other.W).Squared());
				}
			
			// Floating-point methods
			
		#endregion Methods

			#region Fields

			/// <summary>The first axis of the <see cref="Vector4sb"/>.</summary>
		public SByte X;
			/// <summary>The second axis of the <see cref="Vector4sb"/>.</summary>
		public SByte Y;
			/// <summary>The third axis of the <see cref="Vector4sb"/>.</summary>
		public SByte Z;
			/// <summary>The fourth axis of the <see cref="Vector4sb"/>.</summary>
		public SByte W;
	
	#endregion Fields

	#region Properties

	/// <summary>Get the zero value of the <see cref="Vector4sb"/>.</summary>
	public static readonly Vector4sb Zero = new Vector4sb((SByte)0, (SByte)0, (SByte)0, (SByte)0);

	#endregion Properties

	#region Constructors

	/// <summary>Initialise a <see cref="Vector4sb"/> from the provided values for each factor.</summary>
	public Vector4sb(SByte x, SByte y, SByte z, SByte w)
	{
					X = x;
					Y = y;
					Z = z;
					W = w;
			}

	/// <summary>Initialise a <see cref="Vector4sb"/> from a list.</summary>
	public Vector4sb(IList<SByte> list, int index = 0) : this(list[index + 0], list[index + 1], list[index + 2], list[index + 3]) { }

	/// <summary>Initialise a <see cref="Vector4sb"/> from a single scalar that is applied to all factors.</summary>
	public Vector4sb(SByte value) : this(value, value, value, value) { }

	#endregion Constructors

	#region Methods

	/// <summary>Get whether this <see cref="Vector4sb"/> has equal factors as the other <see cref="Vector4sb"/>.</summary>
	public bool Equals(Vector4sb other) {
		return  X == other.X && Y == other.Y && Z == other.Z && W == other.W ;
	}

	/// <summary>If the other object is a <see cref="Vector4sb"/> of the same type, get whether this <see cref="Vector4sb"/> has equal factors as it; otherwise return false.</summary>
	public override bool Equals(object other)
	{
		if(other is Vector4sb)
			return Equals((Vector4sb)other);
		return base.Equals(other);
	}

	/// <summary>Compute a hash code from combining the axes.</summary>
	public override int GetHashCode()
	{
		return  X.GetHashCode() ^ Y.GetHashCode() ^ Z.GetHashCode() ^ W.GetHashCode() ;
	}

	/// <summary>Convert this <see cref="Vector4sb"/> to a string of the form "X, Y, Z, W".</summary>
	public string ToCommaSeparatedString(string format = null, IFormatProvider provider = null) {
		return X.ToString(format, provider) + ", " + Y.ToString(format, provider) + ", " + Z.ToString(format, provider) + ", " + W.ToString(format, provider);
	}

	/// <summary>Convert this <see cref="Vector4sb"/> to a string of the form "Vector4sb(X, Y, Z, W)".</summary>
	public override string ToString()
	{
		return ToString(null, null);
	}

	/// <summary>Convert this <see cref="Vector4sb"/> to a string of the form "Vector4sb(X, Y, Z, W)".</summary>
	public string ToString(string format, IFormatProvider provider)
	{
		return "Vector4sb(" + ToCommaSeparatedString(format, provider) + ")";
	}

	/// <summary>Convert this <see cref="Vector4sb"/> to a string of the form "{X, Y, Z, W".</summary>
	public string ToShortString(string format = null, IFormatProvider provider = null) { return "{" + ToCommaSeparatedString(format, provider) + "}"; }	

	#endregion Methods
	
	/// <summary>Get whether the <see cref="Vector4sb"/> values are equal.</summary>
	public static bool operator ==(Vector4sb a, Vector4sb b) { return a.X == b.X&&a.Y == b.Y&&a.Z == b.Z&&a.W == b.W; }

	/// <summary>Get whether the <see cref="Vector4sb"/> values are unequal.</summary>
	public static bool operator !=(Vector4sb a, Vector4sb b) { return a.X != b.X||a.Y != b.Y||a.Z != b.Z||a.W != b.W; }

		#region Operators
		

			// Casting
							/// <summary>An implicit cast from <see cref="Vector4sb"/> to <see cref="Vector4f"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4f(Vector4sb a) {
						return new Vector4f((Single)a.X, (Single)a.Y, (Single)a.Z, (Single)a.W);
					}
					/// <summary>An implicit cast from <see cref="Vector4sb"/> to <see cref="Vector4d"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static implicit operator Vector4d(Vector4sb a) {
						return new Vector4d((Double)a.X, (Double)a.Y, (Double)a.Z, (Double)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4s"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4s(Vector4sb a) {
						return new Vector4s((Int16)a.X, (Int16)a.Y, (Int16)a.Z, (Int16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4us"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4us(Vector4sb a) {
						return new Vector4us((UInt16)a.X, (UInt16)a.Y, (UInt16)a.Z, (UInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4i"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4i(Vector4sb a) {
						return new Vector4i((Int32)a.X, (Int32)a.Y, (Int32)a.Z, (Int32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4ui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ui(Vector4sb a) {
						return new Vector4ui((UInt32)a.X, (UInt32)a.Y, (UInt32)a.Z, (UInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4b"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4b(Vector4sb a) {
						return new Vector4b((Byte)a.X, (Byte)a.Y, (Byte)a.Z, (Byte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4nb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nb(Vector4sb a) {
						return new Vector4nb((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4nsb"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nsb(Vector4sb a) {
						return new Vector4nsb((NormalizedSByte)a.X, (NormalizedSByte)a.Y, (NormalizedSByte)a.Z, (NormalizedSByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4ns"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ns(Vector4sb a) {
						return new Vector4ns((NormalizedInt16)a.X, (NormalizedInt16)a.Y, (NormalizedInt16)a.Z, (NormalizedInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4ni"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4ni(Vector4sb a) {
						return new Vector4ni((NormalizedInt32)a.X, (NormalizedInt32)a.Y, (NormalizedInt32)a.Z, (NormalizedInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4nus"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nus(Vector4sb a) {
						return new Vector4nus((NormalizedUInt16)a.X, (NormalizedUInt16)a.Y, (NormalizedUInt16)a.Z, (NormalizedUInt16)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4nui"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4nui(Vector4sb a) {
						return new Vector4nui((NormalizedUInt32)a.X, (NormalizedUInt32)a.Y, (NormalizedUInt32)a.Z, (NormalizedUInt32)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4rgba"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4rgba(Vector4sb a) {
						return new Vector4rgba((NormalizedByte)a.X, (NormalizedByte)a.Y, (NormalizedByte)a.Z, (NormalizedByte)a.W);
					}
					/// <summary>An explicit cast from <see cref="Vector4sb"/> to <see cref="Vector4h"/></summary>
					/// <param name="a">The value to cast.</param>
					/// <returns>The casted value.</returns>
					public static explicit operator Vector4h(Vector4sb a) {
						return new Vector4h((Float16)a.X, (Float16)a.Y, (Float16)a.Z, (Float16)a.W);
					}
					
				// Explicit casting to vectors with a lower order, trimming off axes.
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector3sb(Vector4sb a) {
						return new Vector3sb(a.X, a.Y, a.Z);
					}
									/// <summary>Explicitly cast to a vector with fewer axes, dropping the final ones.</summary>
					public static explicit operator Vector2sb(Vector4sb a) {
						return new Vector2sb(a.X, a.Y);
					}
							
			/// <summary>Get the positive of this vector, which is this vector.</summary>
			public static Vector4sb operator +(Vector4sb a) { return new Vector4sb((SByte)(+a.X), (SByte)(+a.Y), (SByte)(+a.Z), (SByte)(+a.W)); }

			/// <summary>Get the negative of this vector.</summary>
			public static Vector4sb operator -(Vector4sb a) { return new Vector4sb((SByte)(-a.X), (SByte)(-a.Y), (SByte)(-a.Z), (SByte)(-a.W)); }
								/// <summary>Add the vector.</summary>
					public static Vector4sb operator +(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X + b.X), (SByte)(a.Y + b.Y), (SByte)(a.Z + b.Z), (SByte)(a.W + b.W)); }

					/// <summary>Add the vector and the scalar.</summary>
					public static Vector4sb operator +(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X + b), (SByte)(a.Y + b), (SByte)(a.Z + b), (SByte)(a.W + b)); }

					/// <summary>Add the scalar and the vector.</summary>
					public static Vector4sb operator +(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a + b.X), (SByte)(a + b.Y), (SByte)(a + b.Z), (SByte)(a + b.W)); }
									/// <summary>Subtract the vector.</summary>
					public static Vector4sb operator -(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X - b.X), (SByte)(a.Y - b.Y), (SByte)(a.Z - b.Z), (SByte)(a.W - b.W)); }

					/// <summary>Subtract the vector and the scalar.</summary>
					public static Vector4sb operator -(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X - b), (SByte)(a.Y - b), (SByte)(a.Z - b), (SByte)(a.W - b)); }

					/// <summary>Subtract the scalar and the vector.</summary>
					public static Vector4sb operator -(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a - b.X), (SByte)(a - b.Y), (SByte)(a - b.Z), (SByte)(a - b.W)); }
									/// <summary>Multiply the vector.</summary>
					public static Vector4sb operator *(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X * b.X), (SByte)(a.Y * b.Y), (SByte)(a.Z * b.Z), (SByte)(a.W * b.W)); }

					/// <summary>Multiply the vector and the scalar.</summary>
					public static Vector4sb operator *(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X * b), (SByte)(a.Y * b), (SByte)(a.Z * b), (SByte)(a.W * b)); }

					/// <summary>Multiply the scalar and the vector.</summary>
					public static Vector4sb operator *(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a * b.X), (SByte)(a * b.Y), (SByte)(a * b.Z), (SByte)(a * b.W)); }
									/// <summary>Divide the vector.</summary>
					public static Vector4sb operator /(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X / b.X), (SByte)(a.Y / b.Y), (SByte)(a.Z / b.Z), (SByte)(a.W / b.W)); }

					/// <summary>Divide the vector and the scalar.</summary>
					public static Vector4sb operator /(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X / b), (SByte)(a.Y / b), (SByte)(a.Z / b), (SByte)(a.W / b)); }

					/// <summary>Divide the scalar and the vector.</summary>
					public static Vector4sb operator /(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a / b.X), (SByte)(a / b.Y), (SByte)(a / b.Z), (SByte)(a / b.W)); }
									/// <summary>Modulo the vector.</summary>
					public static Vector4sb operator %(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X % b.X), (SByte)(a.Y % b.Y), (SByte)(a.Z % b.Z), (SByte)(a.W % b.W)); }

					/// <summary>Modulo the vector and the scalar.</summary>
					public static Vector4sb operator %(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X % b), (SByte)(a.Y % b), (SByte)(a.Z % b), (SByte)(a.W % b)); }

					/// <summary>Modulo the scalar and the vector.</summary>
					public static Vector4sb operator %(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a % b.X), (SByte)(a % b.Y), (SByte)(a % b.Z), (SByte)(a % b.W)); }
									/// <summary>Bitwise AND the vector.</summary>
					public static Vector4sb operator &(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X & b.X), (SByte)(a.Y & b.Y), (SByte)(a.Z & b.Z), (SByte)(a.W & b.W)); }

					/// <summary>Bitwise AND the vector and the scalar.</summary>
					public static Vector4sb operator &(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X & b), (SByte)(a.Y & b), (SByte)(a.Z & b), (SByte)(a.W & b)); }

					/// <summary>Bitwise AND the scalar and the vector.</summary>
					public static Vector4sb operator &(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a & b.X), (SByte)(a & b.Y), (SByte)(a & b.Z), (SByte)(a & b.W)); }
									/// <summary>Bitwise OR the vector.</summary>
					public static Vector4sb operator |(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X | b.X), (SByte)(a.Y | b.Y), (SByte)(a.Z | b.Z), (SByte)(a.W | b.W)); }

					/// <summary>Bitwise OR the vector and the scalar.</summary>
					public static Vector4sb operator |(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X | b), (SByte)(a.Y | b), (SByte)(a.Z | b), (SByte)(a.W | b)); }

					/// <summary>Bitwise OR the scalar and the vector.</summary>
					public static Vector4sb operator |(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a | b.X), (SByte)(a | b.Y), (SByte)(a | b.Z), (SByte)(a | b.W)); }
									/// <summary>Exclusive OR the vector.</summary>
					public static Vector4sb operator ^(Vector4sb a, Vector4sb b) { return new Vector4sb((SByte)(a.X ^ b.X), (SByte)(a.Y ^ b.Y), (SByte)(a.Z ^ b.Z), (SByte)(a.W ^ b.W)); }

					/// <summary>Exclusive OR the vector and the scalar.</summary>
					public static Vector4sb operator ^(Vector4sb a, SByte b) { return new Vector4sb((SByte)(a.X ^ b), (SByte)(a.Y ^ b), (SByte)(a.Z ^ b), (SByte)(a.W ^ b)); }

					/// <summary>Exclusive OR the scalar and the vector.</summary>
					public static Vector4sb operator ^(SByte a, Vector4sb b) { return new Vector4sb((SByte)(a ^ b.X), (SByte)(a ^ b.Y), (SByte)(a ^ b.Z), (SByte)(a ^ b.W)); }
										/// <summary>Shift left the vector and the scalar.</summary>
						public static Vector4sb operator <<(Vector4sb a, int b) { return new Vector4sb((SByte)(a.X << b), (SByte)(a.Y << b), (SByte)(a.Z << b), (SByte)(a.W << b)); }
											/// <summary>Shift right the vector and the scalar.</summary>
						public static Vector4sb operator >>(Vector4sb a, int b) { return new Vector4sb((SByte)(a.X >> b), (SByte)(a.Y >> b), (SByte)(a.Z >> b), (SByte)(a.W >> b)); }
					
		#endregion Operators
	}
	
	}





